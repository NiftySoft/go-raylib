// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 07 Sep 2020 11:05:38 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raylib

/*
#include "../lib/raylib/src/raylib.h"
#include "../lib/raylib/src/raymath.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("reference add into gc collector, gc collector count: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// convert struct for mapping C struct unanimous.
func (x *Vector2) convert() *vector2 {
	if x.ref29ca61a5 != nil {
		return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.PassRef()
	return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(gX float32, gY float32) Vector2 {
	obj := *new(Vector2)
	obj.gX = gX
	obj.gY = gY
	obj.PassRef()
	return obj
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		if x.allocs29ca61a5 != nil {
			return x.ref29ca61a5, x.allocs29ca61a5.(*cgoAllocMap)
		} else {
			return x.ref29ca61a5, nil
		}
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	x.This = x.convert()

	return ref29ca61a5, allocs29ca61a5
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Vector2) Index(index int32) *Vector2 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	ret := NewVector2Ref(unsafe.Pointer(ptr1))
	return ret
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector3) ref() *C.Vector3 {
	if x == nil {
		return nil
	}
	return x.ref5ecd5133
}

// convert struct for mapping C struct unanimous.
func (x *Vector3) convert() *vector3 {
	if x.ref5ecd5133 != nil {
		return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.PassRef()
	return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector3(x *Vector3) {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		// fmt.Printf("Vector3 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ecd5133.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector3 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector3 new Go object and Mapping to C object.
func NewVector3(gX float32, gY float32, gZ float32) Vector3 {
	obj := *new(Vector3)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	obj.PassRef()
	return obj
}

// NewVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector3Ref(ref unsafe.Pointer) *Vector3 {
	if ref == nil {
		return nil
	}
	obj := new(Vector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector3) PassRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		if x.allocs5ecd5133 != nil {
			return x.ref5ecd5133, x.allocs5ecd5133.(*cgoAllocMap)
		} else {
			return x.ref5ecd5133, nil
		}
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)
	defer func() {
		if len(x.allocs5ecd5133.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector3)
		}
	}()

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.gZ = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133
	x.This = x.convert()

	return ref5ecd5133, allocs5ecd5133
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector3) PassValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Vector3) Index(index int32) *Vector3 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector3)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector3Value)))
	ret := NewVector3Ref(unsafe.Pointer(ptr1))
	return ret
}

// allocVector4Memory allocates memory for type C.Vector4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector4Value = unsafe.Sizeof([1]C.Vector4{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector4) ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// convert struct for mapping C struct unanimous.
func (x *Vector4) convert() *vector4 {
	if x.refc0a9c490 != nil {
		return (*vector4)(unsafe.Pointer(x.refc0a9c490))
	}
	x.PassRef()
	return (*vector4)(unsafe.Pointer(x.refc0a9c490))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector4(x *Vector4) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		// fmt.Printf("Vector4 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector4 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector4 new Go object and Mapping to C object.
func NewVector4(gX float32, gY float32, gZ float32, gW float32) Vector4 {
	obj := *new(Vector4)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	obj.gW = gW
	obj.PassRef()
	return obj
}

// NewVector4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector4Ref(ref unsafe.Pointer) *Vector4 {
	if ref == nil {
		return nil
	}
	obj := new(Vector4)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector4) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		if x.allocsc0a9c490 != nil {
			return x.refc0a9c490, x.allocsc0a9c490.(*cgoAllocMap)
		} else {
			return x.refc0a9c490, nil
		}
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)
	defer func() {
		if len(x.allocsc0a9c490.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector4)
		}
	}()

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	x.This = x.convert()

	return refc0a9c490, allocsc0a9c490
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector4) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Vector4) Index(index int32) *Vector4 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector4)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector4Value)))
	ret := NewVector4Ref(unsafe.Pointer(ptr1))
	return ret
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Quaternion) ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// convert struct for mapping C struct unanimous.
func (x *Quaternion) convert() *vector4 {
	if x.refc0a9c490 != nil {
		return (*vector4)(unsafe.Pointer(x.refc0a9c490))
	}
	x.PassRef()
	return (*vector4)(unsafe.Pointer(x.refc0a9c490))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeQuaternion(x *Quaternion) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		// fmt.Printf("Quaternion memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector4 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewQuaternion new Go object and Mapping to C object.
func NewQuaternion(gX float32, gY float32, gZ float32, gW float32) Quaternion {
	obj := *new(Quaternion)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	obj.gW = gW
	obj.PassRef()
	return obj
}

// NewQuaternionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQuaternionRef(ref unsafe.Pointer) *Quaternion {
	if ref == nil {
		return nil
	}
	obj := new(Quaternion)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Quaternion) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		if x.allocsc0a9c490 != nil {
			return x.refc0a9c490, x.allocsc0a9c490.(*cgoAllocMap)
		} else {
			return x.refc0a9c490, nil
		}
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)
	defer func() {
		if len(x.allocsc0a9c490.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeQuaternion)
		}
	}()

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	x.This = x.convert()

	return refc0a9c490, allocsc0a9c490
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Quaternion) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Quaternion) Index(index int32) *Quaternion {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector4)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector4Value)))
	ret := NewQuaternionRef(unsafe.Pointer(ptr1))
	return ret
}

// allocMatrixMemory allocates memory for type C.Matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.Matrix{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix) ref() *C.Matrix {
	if x == nil {
		return nil
	}
	return x.refff9f44f9
}

// convert struct for mapping C struct unanimous.
func (x *Matrix) convert() *matrix {
	if x.refff9f44f9 != nil {
		return (*matrix)(unsafe.Pointer(x.refff9f44f9))
	}
	x.PassRef()
	return (*matrix)(unsafe.Pointer(x.refff9f44f9))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMatrix(x *Matrix) {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
		// fmt.Printf("Matrix memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsff9f44f9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Matrix memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewMatrix new Go object and Mapping to C object.
func NewMatrix(gM0 float32, gM4 float32, gM8 float32, gM12 float32, gM1 float32, gM5 float32, gM9 float32, gM13 float32, gM2 float32, gM6 float32, gM10 float32, gM14 float32, gM3 float32, gM7 float32, gM11 float32, gM15 float32) Matrix {
	obj := *new(Matrix)
	obj.gM0 = gM0
	obj.gM4 = gM4
	obj.gM8 = gM8
	obj.gM12 = gM12
	obj.gM1 = gM1
	obj.gM5 = gM5
	obj.gM9 = gM9
	obj.gM13 = gM13
	obj.gM2 = gM2
	obj.gM6 = gM6
	obj.gM10 = gM10
	obj.gM14 = gM14
	obj.gM3 = gM3
	obj.gM7 = gM7
	obj.gM11 = gM11
	obj.gM15 = gM15
	obj.PassRef()
	return obj
}

// NewMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	if ref == nil {
		return nil
	}
	obj := new(Matrix)
	obj.refff9f44f9 = (*C.Matrix)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix) PassRef() (*C.Matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff9f44f9 != nil {
		if x.allocsff9f44f9 != nil {
			return x.refff9f44f9, x.allocsff9f44f9.(*cgoAllocMap)
		} else {
			return x.refff9f44f9, nil
		}
	}
	memff9f44f9 := unsafe.Pointer(new(C.Matrix))
	refff9f44f9 := (*C.Matrix)(memff9f44f9)
	allocsff9f44f9 := new(cgoAllocMap)
	// allocsff9f44f9.Add(memff9f44f9)
	defer func() {
		if len(x.allocsff9f44f9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMatrix)
		}
	}()

	var cm0_allocs *cgoAllocMap
	refff9f44f9.m0, cm0_allocs = (C.float)(x.gM0), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm0_allocs)
	x.gM0 = *new(float32)

	var cm4_allocs *cgoAllocMap
	refff9f44f9.m4, cm4_allocs = (C.float)(x.gM4), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm4_allocs)
	x.gM4 = *new(float32)

	var cm8_allocs *cgoAllocMap
	refff9f44f9.m8, cm8_allocs = (C.float)(x.gM8), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm8_allocs)
	x.gM8 = *new(float32)

	var cm12_allocs *cgoAllocMap
	refff9f44f9.m12, cm12_allocs = (C.float)(x.gM12), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm12_allocs)
	x.gM12 = *new(float32)

	var cm1_allocs *cgoAllocMap
	refff9f44f9.m1, cm1_allocs = (C.float)(x.gM1), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm1_allocs)
	x.gM1 = *new(float32)

	var cm5_allocs *cgoAllocMap
	refff9f44f9.m5, cm5_allocs = (C.float)(x.gM5), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm5_allocs)
	x.gM5 = *new(float32)

	var cm9_allocs *cgoAllocMap
	refff9f44f9.m9, cm9_allocs = (C.float)(x.gM9), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm9_allocs)
	x.gM9 = *new(float32)

	var cm13_allocs *cgoAllocMap
	refff9f44f9.m13, cm13_allocs = (C.float)(x.gM13), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm13_allocs)
	x.gM13 = *new(float32)

	var cm2_allocs *cgoAllocMap
	refff9f44f9.m2, cm2_allocs = (C.float)(x.gM2), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm2_allocs)
	x.gM2 = *new(float32)

	var cm6_allocs *cgoAllocMap
	refff9f44f9.m6, cm6_allocs = (C.float)(x.gM6), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm6_allocs)
	x.gM6 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refff9f44f9.m10, cm10_allocs = (C.float)(x.gM10), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm10_allocs)
	x.gM10 = *new(float32)

	var cm14_allocs *cgoAllocMap
	refff9f44f9.m14, cm14_allocs = (C.float)(x.gM14), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm14_allocs)
	x.gM14 = *new(float32)

	var cm3_allocs *cgoAllocMap
	refff9f44f9.m3, cm3_allocs = (C.float)(x.gM3), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm3_allocs)
	x.gM3 = *new(float32)

	var cm7_allocs *cgoAllocMap
	refff9f44f9.m7, cm7_allocs = (C.float)(x.gM7), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm7_allocs)
	x.gM7 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refff9f44f9.m11, cm11_allocs = (C.float)(x.gM11), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm11_allocs)
	x.gM11 = *new(float32)

	var cm15_allocs *cgoAllocMap
	refff9f44f9.m15, cm15_allocs = (C.float)(x.gM15), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm15_allocs)
	x.gM15 = *new(float32)

	x.refff9f44f9 = refff9f44f9
	x.allocsff9f44f9 = allocsff9f44f9
	x.This = x.convert()

	return refff9f44f9, allocsff9f44f9
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix) PassValue() (C.Matrix, *cgoAllocMap) {
	if x.refff9f44f9 != nil {
		return *x.refff9f44f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Matrix) Index(index int32) *Matrix {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Matrix)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMatrixValue)))
	ret := NewMatrixRef(unsafe.Pointer(ptr1))
	return ret
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) ref() *C.Color {
	if x == nil {
		return nil
	}
	return x.refa79767ed
}

// convert struct for mapping C struct unanimous.
func (x *Color) convert() *color {
	if x.refa79767ed != nil {
		return (*color)(unsafe.Pointer(x.refa79767ed))
	}
	x.PassRef()
	return (*color)(unsafe.Pointer(x.refa79767ed))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeColor(x *Color) {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		// fmt.Printf("Color memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa79767ed.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Color memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewColor new Go object and Mapping to C object.
func NewColor(gR byte, gG byte, gB byte, gA byte) Color {
	obj := *new(Color)
	obj.gR = gR
	obj.gG = gG
	obj.gB = gB
	obj.gA = gA
	obj.PassRef()
	return obj
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		if x.allocsa79767ed != nil {
			return x.refa79767ed, x.allocsa79767ed.(*cgoAllocMap)
		} else {
			return x.refa79767ed, nil
		}
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)
	defer func() {
		if len(x.allocsa79767ed.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeColor)
		}
	}()

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.gR), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.gR = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.gG), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.gG = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.gB), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.gB = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.gA), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.gA = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed
	x.This = x.convert()

	return refa79767ed, allocsa79767ed
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Color) Index(index int32) *Color {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Color)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfColorValue)))
	ret := NewColorRef(unsafe.Pointer(ptr1))
	return ret
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) ref() *C.Rectangle {
	if x == nil {
		return nil
	}
	return x.refcee8783a
}

// convert struct for mapping C struct unanimous.
func (x *Rectangle) convert() *rectangle {
	if x.refcee8783a != nil {
		return (*rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.PassRef()
	return (*rectangle)(unsafe.Pointer(x.refcee8783a))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRectangle(x *Rectangle) {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		// fmt.Printf("Rectangle memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocscee8783a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Rectangle memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewRectangle new Go object and Mapping to C object.
func NewRectangle(gX float32, gY float32, gWidth float32, gHeight float32) Rectangle {
	obj := *new(Rectangle)
	obj.gX = gX
	obj.gY = gY
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.PassRef()
	return obj
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		if x.allocscee8783a != nil {
			return x.refcee8783a, x.allocscee8783a.(*cgoAllocMap)
		} else {
			return x.refcee8783a, nil
		}
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)
	defer func() {
		if len(x.allocscee8783a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRectangle)
		}
	}()

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.gWidth), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.gWidth = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.gHeight), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.gHeight = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a
	x.This = x.convert()

	return refcee8783a, allocscee8783a
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Rectangle) Index(index int32) *Rectangle {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	ret := NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) ref() *C.Image {
	if x == nil {
		return nil
	}
	return x.ref4fc2b5b
}

// convert struct for mapping C struct unanimous.
func (x *Image) convert() *image {
	if x.ref4fc2b5b != nil {
		return (*image)(unsafe.Pointer(x.ref4fc2b5b))
	}
	x.PassRef()
	return (*image)(unsafe.Pointer(x.ref4fc2b5b))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeImage(x *Image) {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
		// fmt.Printf("Image memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs4fc2b5b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Image memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewImage new Go object and Mapping to C object.
func NewImage(gData unsafe.Pointer, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Image {
	obj := *new(Image)
	obj.gData = gData
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	obj.PassRef()
	return obj
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		if x.allocs4fc2b5b != nil {
			return x.ref4fc2b5b, x.allocs4fc2b5b.(*cgoAllocMap)
		} else {
			return x.ref4fc2b5b, nil
		}
	}
	mem4fc2b5b := unsafe.Pointer(new(C.Image))
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	// allocs4fc2b5b.Add(mem4fc2b5b)
	defer func() {
		if len(x.allocs4fc2b5b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeImage)
		}
	}()

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b
	x.This = x.convert()

	return ref4fc2b5b, allocs4fc2b5b
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Image) Index(index int32) *Image {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Image)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfImageValue)))
	ret := NewImageRef(unsafe.Pointer(ptr1))
	return ret
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture2D) ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// convert struct for mapping C struct unanimous.
func (x *Texture2D) convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture2D(x *Texture2D) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture2D new Go object and Mapping to C object.
func NewTexture2D(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Texture2D {
	obj := *new(Texture2D)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	obj.PassRef()
	return obj
}

// NewTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTexture2DRef(ref unsafe.Pointer) *Texture2D {
	if ref == nil {
		return nil
	}
	obj := new(Texture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture2D) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		if x.allocs3c51a40b != nil {
			return x.ref3c51a40b, x.allocs3c51a40b.(*cgoAllocMap)
		} else {
			return x.ref3c51a40b, nil
		}
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture2D)
		}
	}()

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	x.This = x.convert()

	return ref3c51a40b, allocs3c51a40b
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture2D) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Texture2D) Index(index int32) *Texture2D {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	ret := NewTexture2DRef(unsafe.Pointer(ptr1))
	return ret
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture) ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// convert struct for mapping C struct unanimous.
func (x *Texture) convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture(x *Texture) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture new Go object and Mapping to C object.
func NewTexture(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Texture {
	obj := *new(Texture)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	obj.PassRef()
	return obj
}

// NewTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureRef(ref unsafe.Pointer) *Texture {
	if ref == nil {
		return nil
	}
	obj := new(Texture)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		if x.allocs3c51a40b != nil {
			return x.ref3c51a40b, x.allocs3c51a40b.(*cgoAllocMap)
		} else {
			return x.ref3c51a40b, nil
		}
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture)
		}
	}()

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	x.This = x.convert()

	return ref3c51a40b, allocs3c51a40b
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Texture) Index(index int32) *Texture {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	ret := NewTextureRef(unsafe.Pointer(ptr1))
	return ret
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureCubemap) ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// convert struct for mapping C struct unanimous.
func (x *TextureCubemap) convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTextureCubemap(x *TextureCubemap) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("TextureCubemap memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewTextureCubemap new Go object and Mapping to C object.
func NewTextureCubemap(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) TextureCubemap {
	obj := *new(TextureCubemap)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	obj.PassRef()
	return obj
}

// NewTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureCubemapRef(ref unsafe.Pointer) *TextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(TextureCubemap)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureCubemap) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		if x.allocs3c51a40b != nil {
			return x.ref3c51a40b, x.allocs3c51a40b.(*cgoAllocMap)
		} else {
			return x.ref3c51a40b, nil
		}
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTextureCubemap)
		}
	}()

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	x.This = x.convert()

	return ref3c51a40b, allocs3c51a40b
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureCubemap) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *TextureCubemap) Index(index int32) *TextureCubemap {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	ret := NewTextureCubemapRef(unsafe.Pointer(ptr1))
	return ret
}

// allocRenderTexture2DMemory allocates memory for type C.RenderTexture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderTexture2DValue = unsafe.Sizeof([1]C.RenderTexture2D{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture2D) ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// convert struct for mapping C struct unanimous.
func (x *RenderTexture2D) convert() *renderTexture2D {
	if x.ref2f94e9e3 != nil {
		return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.PassRef()
	return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRenderTexture2D(x *RenderTexture2D) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		// fmt.Printf("RenderTexture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RenderTexture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewRenderTexture2D new Go object and Mapping to C object.
func NewRenderTexture2D(gId uint32, gTexture Texture2D, gDepth Texture2D, gDepthTexture bool) RenderTexture2D {
	obj := *new(RenderTexture2D)
	obj.gId = gId
	obj.gTexture = gTexture
	obj.gDepth = gDepth
	obj.gDepthTexture = gDepthTexture
	obj.PassRef()
	return obj
}

// NewRenderTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTexture2DRef(ref unsafe.Pointer) *RenderTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture2D)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture2D) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		if x.allocs2f94e9e3 != nil {
			return x.ref2f94e9e3, x.allocs2f94e9e3.(*cgoAllocMap)
		} else {
			return x.ref2f94e9e3, nil
		}
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)
	defer func() {
		if len(x.allocs2f94e9e3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRenderTexture2D)
		}
	}()

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.gDepth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.gDepth = *new(Texture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.gDepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.gDepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	x.This = x.convert()

	return ref2f94e9e3, allocs2f94e9e3
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture2D) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *RenderTexture2D) Index(index int32) *RenderTexture2D {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.RenderTexture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRenderTexture2DValue)))
	ret := NewRenderTexture2DRef(unsafe.Pointer(ptr1))
	return ret
}

// Texture returns a reference to C object within a struct
func (s *RenderTexture2D) Texture() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().texture))
	return ret
}

// Depth returns a reference to C object within a struct
func (s *RenderTexture2D) Depth() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().depth))
	return ret
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture) ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// convert struct for mapping C struct unanimous.
func (x *RenderTexture) convert() *renderTexture2D {
	if x.ref2f94e9e3 != nil {
		return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.PassRef()
	return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRenderTexture(x *RenderTexture) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		// fmt.Printf("RenderTexture memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RenderTexture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewRenderTexture new Go object and Mapping to C object.
func NewRenderTexture(gId uint32, gTexture Texture2D, gDepth Texture2D, gDepthTexture bool) RenderTexture {
	obj := *new(RenderTexture)
	obj.gId = gId
	obj.gTexture = gTexture
	obj.gDepth = gDepth
	obj.gDepthTexture = gDepthTexture
	obj.PassRef()
	return obj
}

// NewRenderTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTextureRef(ref unsafe.Pointer) *RenderTexture {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		if x.allocs2f94e9e3 != nil {
			return x.ref2f94e9e3, x.allocs2f94e9e3.(*cgoAllocMap)
		} else {
			return x.ref2f94e9e3, nil
		}
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)
	defer func() {
		if len(x.allocs2f94e9e3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRenderTexture)
		}
	}()

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.gDepth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.gDepth = *new(Texture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.gDepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.gDepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	x.This = x.convert()

	return ref2f94e9e3, allocs2f94e9e3
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *RenderTexture) Index(index int32) *RenderTexture {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.RenderTexture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRenderTexture2DValue)))
	ret := NewRenderTextureRef(unsafe.Pointer(ptr1))
	return ret
}

// Texture returns a reference to C object within a struct
func (s *RenderTexture) Texture() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().texture))
	return ret
}

// Depth returns a reference to C object within a struct
func (s *RenderTexture) Depth() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().depth))
	return ret
}

// allocNPatchInfoMemory allocates memory for type C.NPatchInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNPatchInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNPatchInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNPatchInfoValue = unsafe.Sizeof([1]C.NPatchInfo{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *NPatchInfo) ref() *C.NPatchInfo {
	if x == nil {
		return nil
	}
	return x.ref78104a03
}

// convert struct for mapping C struct unanimous.
func (x *NPatchInfo) convert() *nPatchInfo {
	if x.ref78104a03 != nil {
		return (*nPatchInfo)(unsafe.Pointer(x.ref78104a03))
	}
	x.PassRef()
	return (*nPatchInfo)(unsafe.Pointer(x.ref78104a03))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeNPatchInfo(x *NPatchInfo) {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
		// fmt.Printf("NPatchInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs78104a03.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.NPatchInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewNPatchInfo new Go object and Mapping to C object.
func NewNPatchInfo(gSourceRec Rectangle, gLeft int32, gTop int32, gRight int32, gBottom int32, gType int32) NPatchInfo {
	obj := *new(NPatchInfo)
	obj.gSourceRec = gSourceRec
	obj.gLeft = gLeft
	obj.gTop = gTop
	obj.gRight = gRight
	obj.gBottom = gBottom
	obj.gType = gType
	obj.PassRef()
	return obj
}

// NewNPatchInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNPatchInfoRef(ref unsafe.Pointer) *NPatchInfo {
	if ref == nil {
		return nil
	}
	obj := new(NPatchInfo)
	obj.ref78104a03 = (*C.NPatchInfo)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NPatchInfo) PassRef() (*C.NPatchInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78104a03 != nil {
		if x.allocs78104a03 != nil {
			return x.ref78104a03, x.allocs78104a03.(*cgoAllocMap)
		} else {
			return x.ref78104a03, nil
		}
	}
	mem78104a03 := unsafe.Pointer(new(C.NPatchInfo))
	ref78104a03 := (*C.NPatchInfo)(mem78104a03)
	allocs78104a03 := new(cgoAllocMap)
	// allocs78104a03.Add(mem78104a03)
	defer func() {
		if len(x.allocs78104a03.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeNPatchInfo)
		}
	}()

	var csourceRec_allocs *cgoAllocMap
	ref78104a03.sourceRec, csourceRec_allocs = x.gSourceRec.PassValue()
	allocs78104a03.Borrow(csourceRec_allocs)
	x.gSourceRec = *new(Rectangle)

	var cleft_allocs *cgoAllocMap
	ref78104a03.left, cleft_allocs = (C.int)(x.gLeft), cgoAllocsUnknown
	allocs78104a03.Borrow(cleft_allocs)
	x.gLeft = *new(int32)

	var ctop_allocs *cgoAllocMap
	ref78104a03.top, ctop_allocs = (C.int)(x.gTop), cgoAllocsUnknown
	allocs78104a03.Borrow(ctop_allocs)
	x.gTop = *new(int32)

	var cright_allocs *cgoAllocMap
	ref78104a03.right, cright_allocs = (C.int)(x.gRight), cgoAllocsUnknown
	allocs78104a03.Borrow(cright_allocs)
	x.gRight = *new(int32)

	var cbottom_allocs *cgoAllocMap
	ref78104a03.bottom, cbottom_allocs = (C.int)(x.gBottom), cgoAllocsUnknown
	allocs78104a03.Borrow(cbottom_allocs)
	x.gBottom = *new(int32)

	var c_type_allocs *cgoAllocMap
	ref78104a03._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs78104a03.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref78104a03 = ref78104a03
	x.allocs78104a03 = allocs78104a03
	x.This = x.convert()

	return ref78104a03, allocs78104a03
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NPatchInfo) PassValue() (C.NPatchInfo, *cgoAllocMap) {
	if x.ref78104a03 != nil {
		return *x.ref78104a03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *NPatchInfo) Index(index int32) *NPatchInfo {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.NPatchInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfNPatchInfoValue)))
	ret := NewNPatchInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// SourceRec returns a reference to C object within a struct
func (s *NPatchInfo) SourceRec() *Rectangle {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	ret = NewRectangleRef(unsafe.Pointer(&s.ref().sourceRec))
	return ret
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *CharInfo) ref() *C.CharInfo {
	if x == nil {
		return nil
	}
	return x.ref702c36c0
}

// convert struct for mapping C struct unanimous.
func (x *CharInfo) convert() *charInfo {
	if x.ref702c36c0 != nil {
		return (*charInfo)(unsafe.Pointer(x.ref702c36c0))
	}
	x.PassRef()
	return (*charInfo)(unsafe.Pointer(x.ref702c36c0))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCharInfo(x *CharInfo) {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
		// fmt.Printf("CharInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs702c36c0.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.CharInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewCharInfo new Go object and Mapping to C object.
func NewCharInfo(gValue int32, gOffsetX int32, gOffsetY int32, gAdvanceX int32, gImage Image) CharInfo {
	obj := *new(CharInfo)
	obj.gValue = gValue
	obj.gOffsetX = gOffsetX
	obj.gOffsetY = gOffsetY
	obj.gAdvanceX = gAdvanceX
	obj.gImage = gImage
	obj.PassRef()
	return obj
}

// NewCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCharInfoRef(ref unsafe.Pointer) *CharInfo {
	if ref == nil {
		return nil
	}
	obj := new(CharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CharInfo) PassRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		if x.allocs702c36c0 != nil {
			return x.ref702c36c0, x.allocs702c36c0.(*cgoAllocMap)
		} else {
			return x.ref702c36c0, nil
		}
	}
	mem702c36c0 := unsafe.Pointer(new(C.CharInfo))
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	// allocs702c36c0.Add(mem702c36c0)
	defer func() {
		if len(x.allocs702c36c0.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCharInfo)
		}
	}()

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.gValue), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)
	x.gValue = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.gOffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)
	x.gOffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.gOffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)
	x.gOffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.gAdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)
	x.gAdvanceX = *new(int32)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.gImage.PassValue()
	allocs702c36c0.Borrow(cimage_allocs)
	x.gImage = *new(Image)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0
	x.This = x.convert()

	return ref702c36c0, allocs702c36c0
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CharInfo) PassValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *CharInfo) Index(index int32) *CharInfo {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfCharInfoValue)))
	ret := NewCharInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// Image returns a reference to C object within a struct
func (s *CharInfo) Image() *Image {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Image
	ret = NewImageRef(unsafe.Pointer(&s.ref().image))
	return ret
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []CharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Font) ref() *C.Font {
	if x == nil {
		return nil
	}
	return x.ref70a6a7ec
}

// convert struct for mapping C struct unanimous.
func (x *Font) convert() *font {
	if x.ref70a6a7ec != nil {
		return (*font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.PassRef()
	return (*font)(unsafe.Pointer(x.ref70a6a7ec))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeFont(x *Font) {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		// fmt.Printf("Font memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs70a6a7ec.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Font memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewFont new Go object and Mapping to C object.
func NewFont(gBaseSize int32, gCharsCount int32, gTexture Texture2D, gRecs []Rectangle, gChars []CharInfo) Font {
	obj := *new(Font)
	obj.gBaseSize = gBaseSize
	obj.gCharsCount = gCharsCount
	obj.gTexture = gTexture
	obj.gRecs = gRecs
	obj.gChars = gChars
	obj.PassRef()
	return obj
}

// NewFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontRef(ref unsafe.Pointer) *Font {
	if ref == nil {
		return nil
	}
	obj := new(Font)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Font) PassRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		if x.allocs70a6a7ec != nil {
			return x.ref70a6a7ec, x.allocs70a6a7ec.(*cgoAllocMap)
		} else {
			return x.ref70a6a7ec, nil
		}
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)
	defer func() {
		if len(x.allocs70a6a7ec.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeFont)
		}
	}()

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.gBaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.gBaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.gCharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.gCharsCount = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.gRecs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.gRecs = *new([]Rectangle)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.gChars)
	allocs70a6a7ec.Borrow(cchars_allocs)
	x.gChars = *new([]CharInfo)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec
	x.This = x.convert()

	return ref70a6a7ec, allocs70a6a7ec
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Font) PassValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Font) Index(index int32) *Font {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Font)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfFontValue)))
	ret := NewFontRef(unsafe.Pointer(ptr1))
	return ret
}

// Texture returns a reference to C object within a struct
func (s *Font) Texture() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().texture))
	return ret
}

// Recs returns a reference to C object within a struct
func (s *Font) Recs(recsIndex int32) *Rectangle {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	// c struct pointer offset
	ptr0 := s.ref().recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(recsIndex)*uintptr(sizeOfRectangleValue)))

	ret = NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// Chars returns a reference to C object within a struct
func (s *Font) Chars(charsIndex int32) *CharInfo {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *CharInfo
	// c struct pointer offset
	ptr0 := s.ref().chars
	ptr1 := (*C.CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(charsIndex)*uintptr(sizeOfCharInfoValue)))

	ret = NewCharInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// allocCamera3DMemory allocates memory for type C.Camera3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera3DValue = unsafe.Sizeof([1]C.Camera3D{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera3D) ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// convert struct for mapping C struct unanimous.
func (x *Camera3D) convert() *camera3D {
	if x.ref7b09036 != nil {
		return (*camera3D)(unsafe.Pointer(x.ref7b09036))
	}
	x.PassRef()
	return (*camera3D)(unsafe.Pointer(x.ref7b09036))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera3D(x *Camera3D) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		// fmt.Printf("Camera3D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7b09036.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera3D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera3D new Go object and Mapping to C object.
func NewCamera3D(gPosition Vector3, gTarget Vector3, gUp Vector3, gFovy float32, gType int32) Camera3D {
	obj := *new(Camera3D)
	obj.gPosition = gPosition
	obj.gTarget = gTarget
	obj.gUp = gUp
	obj.gFovy = gFovy
	obj.gType = gType
	obj.PassRef()
	return obj
}

// NewCamera3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera3DRef(ref unsafe.Pointer) *Camera3D {
	if ref == nil {
		return nil
	}
	obj := new(Camera3D)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera3D) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		if x.allocs7b09036 != nil {
			return x.ref7b09036, x.allocs7b09036.(*cgoAllocMap)
		} else {
			return x.ref7b09036, nil
		}
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)
	defer func() {
		if len(x.allocs7b09036.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera3D)
		}
	}()

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.PassValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(Vector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.PassValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(Vector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	x.This = x.convert()

	return ref7b09036, allocs7b09036
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera3D) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Camera3D) Index(index int32) *Camera3D {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Camera3D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfCamera3DValue)))
	ret := NewCamera3DRef(unsafe.Pointer(ptr1))
	return ret
}

// Position returns a reference to C object within a struct
func (s *Camera3D) Position() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().position))
	return ret
}

// Target returns a reference to C object within a struct
func (s *Camera3D) Target() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().target))
	return ret
}

// Up returns a reference to C object within a struct
func (s *Camera3D) Up() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().up))
	return ret
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera) ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// convert struct for mapping C struct unanimous.
func (x *Camera) convert() *camera3D {
	if x.ref7b09036 != nil {
		return (*camera3D)(unsafe.Pointer(x.ref7b09036))
	}
	x.PassRef()
	return (*camera3D)(unsafe.Pointer(x.ref7b09036))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera(x *Camera) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		// fmt.Printf("Camera memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7b09036.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera3D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera new Go object and Mapping to C object.
func NewCamera(gPosition Vector3, gTarget Vector3, gUp Vector3, gFovy float32, gType int32) Camera {
	obj := *new(Camera)
	obj.gPosition = gPosition
	obj.gTarget = gTarget
	obj.gUp = gUp
	obj.gFovy = gFovy
	obj.gType = gType
	obj.PassRef()
	return obj
}

// NewCameraRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCameraRef(ref unsafe.Pointer) *Camera {
	if ref == nil {
		return nil
	}
	obj := new(Camera)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		if x.allocs7b09036 != nil {
			return x.ref7b09036, x.allocs7b09036.(*cgoAllocMap)
		} else {
			return x.ref7b09036, nil
		}
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)
	defer func() {
		if len(x.allocs7b09036.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera)
		}
	}()

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.PassValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(Vector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.PassValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(Vector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	x.This = x.convert()

	return ref7b09036, allocs7b09036
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Camera) Index(index int32) *Camera {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Camera3D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfCamera3DValue)))
	ret := NewCameraRef(unsafe.Pointer(ptr1))
	return ret
}

// Position returns a reference to C object within a struct
func (s *Camera) Position() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().position))
	return ret
}

// Target returns a reference to C object within a struct
func (s *Camera) Target() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().target))
	return ret
}

// Up returns a reference to C object within a struct
func (s *Camera) Up() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().up))
	return ret
}

// allocCamera2DMemory allocates memory for type C.Camera2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera2DValue = unsafe.Sizeof([1]C.Camera2D{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera2D) ref() *C.Camera2D {
	if x == nil {
		return nil
	}
	return x.ref1eaba177
}

// convert struct for mapping C struct unanimous.
func (x *Camera2D) convert() *camera2D {
	if x.ref1eaba177 != nil {
		return (*camera2D)(unsafe.Pointer(x.ref1eaba177))
	}
	x.PassRef()
	return (*camera2D)(unsafe.Pointer(x.ref1eaba177))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera2D(x *Camera2D) {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
		// fmt.Printf("Camera2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs1eaba177.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera2D new Go object and Mapping to C object.
func NewCamera2D(gOffset Vector2, gTarget Vector2, gRotation float32, gZoom float32) Camera2D {
	obj := *new(Camera2D)
	obj.gOffset = gOffset
	obj.gTarget = gTarget
	obj.gRotation = gRotation
	obj.gZoom = gZoom
	obj.PassRef()
	return obj
}

// NewCamera2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera2DRef(ref unsafe.Pointer) *Camera2D {
	if ref == nil {
		return nil
	}
	obj := new(Camera2D)
	obj.ref1eaba177 = (*C.Camera2D)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera2D) PassRef() (*C.Camera2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eaba177 != nil {
		if x.allocs1eaba177 != nil {
			return x.ref1eaba177, x.allocs1eaba177.(*cgoAllocMap)
		} else {
			return x.ref1eaba177, nil
		}
	}
	mem1eaba177 := unsafe.Pointer(new(C.Camera2D))
	ref1eaba177 := (*C.Camera2D)(mem1eaba177)
	allocs1eaba177 := new(cgoAllocMap)
	// allocs1eaba177.Add(mem1eaba177)
	defer func() {
		if len(x.allocs1eaba177.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera2D)
		}
	}()

	var coffset_allocs *cgoAllocMap
	ref1eaba177.offset, coffset_allocs = x.gOffset.PassValue()
	allocs1eaba177.Borrow(coffset_allocs)
	x.gOffset = *new(Vector2)

	var ctarget_allocs *cgoAllocMap
	ref1eaba177.target, ctarget_allocs = x.gTarget.PassValue()
	allocs1eaba177.Borrow(ctarget_allocs)
	x.gTarget = *new(Vector2)

	var crotation_allocs *cgoAllocMap
	ref1eaba177.rotation, crotation_allocs = (C.float)(x.gRotation), cgoAllocsUnknown
	allocs1eaba177.Borrow(crotation_allocs)
	x.gRotation = *new(float32)

	var czoom_allocs *cgoAllocMap
	ref1eaba177.zoom, czoom_allocs = (C.float)(x.gZoom), cgoAllocsUnknown
	allocs1eaba177.Borrow(czoom_allocs)
	x.gZoom = *new(float32)

	x.ref1eaba177 = ref1eaba177
	x.allocs1eaba177 = allocs1eaba177
	x.This = x.convert()

	return ref1eaba177, allocs1eaba177
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera2D) PassValue() (C.Camera2D, *cgoAllocMap) {
	if x.ref1eaba177 != nil {
		return *x.ref1eaba177, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Camera2D) Index(index int32) *Camera2D {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Camera2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfCamera2DValue)))
	ret := NewCamera2DRef(unsafe.Pointer(ptr1))
	return ret
}

// Offset returns a reference to C object within a struct
func (s *Camera2D) Offset() *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.ref().offset))
	return ret
}

// Target returns a reference to C object within a struct
func (s *Camera2D) Target() *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.ref().target))
	return ret
}

// allocMeshMemory allocates memory for type C.Mesh in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMeshMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMeshValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMeshValue = unsafe.Sizeof([1]C.Mesh{})

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// unpackSFloat32 transforms a sliced Go data structure into plain C format.
func unpackSFloat32(x []float32) (unpacked *C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.float)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.float)(h.Data)
	return
}

// allocUcharMemory allocates memory for type C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

// unpackSByte transforms a sliced Go data structure into plain C format.
func unpackSByte(x []byte) (unpacked *C.uchar, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.uchar) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUcharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uchar)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.uchar)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uchar)(h.Data)
	return
}

// allocUshortMemory allocates memory for type C.ushort in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUshortMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUshortValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUshortValue = unsafe.Sizeof([1]C.ushort{})

// unpackSUUint16 transforms a sliced Go data structure into plain C format.
func unpackSUUint16(x []uint16) (unpacked *C.ushort, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.ushort) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUshortMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ushort)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.ushort)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ushort)(h.Data)
	return
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// unpackSInt32 transforms a sliced Go data structure into plain C format.
func unpackSInt32(x []int32) (unpacked *C.int, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.int) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIntMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.int)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.int)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.int)(h.Data)
	return
}

// allocUintMemory allocates memory for type C.uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUintValue = unsafe.Sizeof([1]C.uint{})

// unpackSUUint32 transforms a sliced Go data structure into plain C format.
func unpackSUUint32(x []uint32) (unpacked *C.uint, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.uint) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUintMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.uint)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mesh) ref() *C.Mesh {
	if x == nil {
		return nil
	}
	return x.ref415d9568
}

// convert struct for mapping C struct unanimous.
func (x *Mesh) convert() *mesh {
	if x.ref415d9568 != nil {
		return (*mesh)(unsafe.Pointer(x.ref415d9568))
	}
	x.PassRef()
	return (*mesh)(unsafe.Pointer(x.ref415d9568))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMesh(x *Mesh) {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
		// fmt.Printf("Mesh memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs415d9568.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Mesh memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewMesh new Go object and Mapping to C object.
func NewMesh(gVertexCount int32, gTriangleCount int32, gVertices []float32, gTexcoords []float32, gTexcoords2 []float32, gNormals []float32, gTangents []float32, gColors []byte, gIndices []uint16, gAnimVertices []float32, gAnimNormals []float32, gBoneIds []int32, gBoneWeights []float32, gVaoId uint32, gVboId []uint32) Mesh {
	obj := *new(Mesh)
	obj.gVertexCount = gVertexCount
	obj.gTriangleCount = gTriangleCount
	obj.gVertices = gVertices
	obj.gTexcoords = gTexcoords
	obj.gTexcoords2 = gTexcoords2
	obj.gNormals = gNormals
	obj.gTangents = gTangents
	obj.gColors = gColors
	obj.gIndices = gIndices
	obj.gAnimVertices = gAnimVertices
	obj.gAnimNormals = gAnimNormals
	obj.gBoneIds = gBoneIds
	obj.gBoneWeights = gBoneWeights
	obj.gVaoId = gVaoId
	obj.gVboId = gVboId
	obj.PassRef()
	return obj
}

// NewMeshRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMeshRef(ref unsafe.Pointer) *Mesh {
	if ref == nil {
		return nil
	}
	obj := new(Mesh)
	obj.ref415d9568 = (*C.Mesh)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mesh) PassRef() (*C.Mesh, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref415d9568 != nil {
		if x.allocs415d9568 != nil {
			return x.ref415d9568, x.allocs415d9568.(*cgoAllocMap)
		} else {
			return x.ref415d9568, nil
		}
	}
	mem415d9568 := unsafe.Pointer(new(C.Mesh))
	ref415d9568 := (*C.Mesh)(mem415d9568)
	allocs415d9568 := new(cgoAllocMap)
	// allocs415d9568.Add(mem415d9568)
	defer func() {
		if len(x.allocs415d9568.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMesh)
		}
	}()

	var cvertexCount_allocs *cgoAllocMap
	ref415d9568.vertexCount, cvertexCount_allocs = (C.int)(x.gVertexCount), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertexCount_allocs)
	x.gVertexCount = *new(int32)

	var ctriangleCount_allocs *cgoAllocMap
	ref415d9568.triangleCount, ctriangleCount_allocs = (C.int)(x.gTriangleCount), cgoAllocsUnknown
	allocs415d9568.Borrow(ctriangleCount_allocs)
	x.gTriangleCount = *new(int32)

	var cvertices_allocs *cgoAllocMap
	ref415d9568.vertices, cvertices_allocs = unpackSFloat32(x.gVertices)
	allocs415d9568.Borrow(cvertices_allocs)
	x.gVertices = *new([]float32)

	var ctexcoords_allocs *cgoAllocMap
	ref415d9568.texcoords, ctexcoords_allocs = unpackSFloat32(x.gTexcoords)
	allocs415d9568.Borrow(ctexcoords_allocs)
	x.gTexcoords = *new([]float32)

	var ctexcoords2_allocs *cgoAllocMap
	ref415d9568.texcoords2, ctexcoords2_allocs = unpackSFloat32(x.gTexcoords2)
	allocs415d9568.Borrow(ctexcoords2_allocs)
	x.gTexcoords2 = *new([]float32)

	var cnormals_allocs *cgoAllocMap
	ref415d9568.normals, cnormals_allocs = unpackSFloat32(x.gNormals)
	allocs415d9568.Borrow(cnormals_allocs)
	x.gNormals = *new([]float32)

	var ctangents_allocs *cgoAllocMap
	ref415d9568.tangents, ctangents_allocs = unpackSFloat32(x.gTangents)
	allocs415d9568.Borrow(ctangents_allocs)
	x.gTangents = *new([]float32)

	var ccolors_allocs *cgoAllocMap
	ref415d9568.colors, ccolors_allocs = unpackSByte(x.gColors)
	allocs415d9568.Borrow(ccolors_allocs)
	x.gColors = *new([]byte)

	var cindices_allocs *cgoAllocMap
	ref415d9568.indices, cindices_allocs = unpackSUUint16(x.gIndices)
	allocs415d9568.Borrow(cindices_allocs)
	x.gIndices = *new([]uint16)

	var canimVertices_allocs *cgoAllocMap
	ref415d9568.animVertices, canimVertices_allocs = unpackSFloat32(x.gAnimVertices)
	allocs415d9568.Borrow(canimVertices_allocs)
	x.gAnimVertices = *new([]float32)

	var canimNormals_allocs *cgoAllocMap
	ref415d9568.animNormals, canimNormals_allocs = unpackSFloat32(x.gAnimNormals)
	allocs415d9568.Borrow(canimNormals_allocs)
	x.gAnimNormals = *new([]float32)

	var cboneIds_allocs *cgoAllocMap
	ref415d9568.boneIds, cboneIds_allocs = unpackSInt32(x.gBoneIds)
	allocs415d9568.Borrow(cboneIds_allocs)
	x.gBoneIds = *new([]int32)

	var cboneWeights_allocs *cgoAllocMap
	ref415d9568.boneWeights, cboneWeights_allocs = unpackSFloat32(x.gBoneWeights)
	allocs415d9568.Borrow(cboneWeights_allocs)
	x.gBoneWeights = *new([]float32)

	var cvaoId_allocs *cgoAllocMap
	ref415d9568.vaoId, cvaoId_allocs = (C.uint)(x.gVaoId), cgoAllocsUnknown
	allocs415d9568.Borrow(cvaoId_allocs)
	x.gVaoId = *new(uint32)

	var cvboId_allocs *cgoAllocMap
	ref415d9568.vboId, cvboId_allocs = unpackSUUint32(x.gVboId)
	allocs415d9568.Borrow(cvboId_allocs)
	x.gVboId = *new([]uint32)

	x.ref415d9568 = ref415d9568
	x.allocs415d9568 = allocs415d9568
	x.This = x.convert()

	return ref415d9568, allocs415d9568
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mesh) PassValue() (C.Mesh, *cgoAllocMap) {
	if x.ref415d9568 != nil {
		return *x.ref415d9568, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Mesh) Index(index int32) *Mesh {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMeshValue)))
	ret := NewMeshRef(unsafe.Pointer(ptr1))
	return ret
}

// Vertices returns a reference to C object within a struct
func (s *Mesh) Vertices(verticesCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, verticesCount)
	ptr0 := s.ref().vertices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Texcoords returns a reference to C object within a struct
func (s *Mesh) Texcoords(texcoordsCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, texcoordsCount)
	ptr0 := s.ref().texcoords
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Texcoords2 returns a reference to C object within a struct
func (s *Mesh) Texcoords2(texcoords2Count int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, texcoords2Count)
	ptr0 := s.ref().texcoords2
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Normals returns a reference to C object within a struct
func (s *Mesh) Normals(normalsCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, normalsCount)
	ptr0 := s.ref().normals
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Tangents returns a reference to C object within a struct
func (s *Mesh) Tangents(tangentsCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, tangentsCount)
	ptr0 := s.ref().tangents
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Colors returns a reference to C object within a struct
func (s *Mesh) Colors(colorsCount int32) []*byte {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*byte

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uchar{})
	ret = make([]*byte, colorsCount)
	ptr0 := s.ref().colors
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*byte)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Indices returns a reference to C object within a struct
func (s *Mesh) Indices(indicesCount int32) []*uint16 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*uint16

	const sizeOfPlainValue = unsafe.Sizeof([1]C.ushort{})
	ret = make([]*uint16, indicesCount)
	ptr0 := s.ref().indices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.ushort)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*uint16)(unsafe.Pointer(ptr1))
	}
	return ret
}

// AnimVertices returns a reference to C object within a struct
func (s *Mesh) AnimVertices(animVerticesCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, animVerticesCount)
	ptr0 := s.ref().animVertices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// AnimNormals returns a reference to C object within a struct
func (s *Mesh) AnimNormals(animNormalsCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, animNormalsCount)
	ptr0 := s.ref().animNormals
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// BoneIds returns a reference to C object within a struct
func (s *Mesh) BoneIds(boneIdsCount int32) []*int32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, boneIdsCount)
	ptr0 := s.ref().boneIds
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// BoneWeights returns a reference to C object within a struct
func (s *Mesh) BoneWeights(boneWeightsCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, boneWeightsCount)
	ptr0 := s.ref().boneWeights
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// VboId returns a reference to C object within a struct
func (s *Mesh) VboId(vboIdCount int32) []*uint32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*uint32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uint{})
	ret = make([]*uint32, vboIdCount)
	ptr0 := s.ref().vboId
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.uint)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*uint32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocShaderMemory allocates memory for type C.Shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderValue = unsafe.Sizeof([1]C.Shader{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Shader) ref() *C.Shader {
	if x == nil {
		return nil
	}
	return x.reff85f9b1e
}

// convert struct for mapping C struct unanimous.
func (x *Shader) convert() *shader {
	if x.reff85f9b1e != nil {
		return (*shader)(unsafe.Pointer(x.reff85f9b1e))
	}
	x.PassRef()
	return (*shader)(unsafe.Pointer(x.reff85f9b1e))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeShader(x *Shader) {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
		// fmt.Printf("Shader memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsf85f9b1e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Shader memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewShader new Go object and Mapping to C object.
func NewShader(gId uint32, gLocs []int32) Shader {
	obj := *new(Shader)
	obj.gId = gId
	obj.gLocs = gLocs
	obj.PassRef()
	return obj
}

// NewShaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderRef(ref unsafe.Pointer) *Shader {
	if ref == nil {
		return nil
	}
	obj := new(Shader)
	obj.reff85f9b1e = (*C.Shader)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Shader) PassRef() (*C.Shader, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff85f9b1e != nil {
		if x.allocsf85f9b1e != nil {
			return x.reff85f9b1e, x.allocsf85f9b1e.(*cgoAllocMap)
		} else {
			return x.reff85f9b1e, nil
		}
	}
	memf85f9b1e := unsafe.Pointer(new(C.Shader))
	reff85f9b1e := (*C.Shader)(memf85f9b1e)
	allocsf85f9b1e := new(cgoAllocMap)
	// allocsf85f9b1e.Add(memf85f9b1e)
	defer func() {
		if len(x.allocsf85f9b1e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeShader)
		}
	}()

	var cid_allocs *cgoAllocMap
	reff85f9b1e.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var clocs_allocs *cgoAllocMap
	reff85f9b1e.locs, clocs_allocs = unpackSInt32(x.gLocs)
	allocsf85f9b1e.Borrow(clocs_allocs)
	x.gLocs = *new([]int32)

	x.reff85f9b1e = reff85f9b1e
	x.allocsf85f9b1e = allocsf85f9b1e
	x.This = x.convert()

	return reff85f9b1e, allocsf85f9b1e
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Shader) PassValue() (C.Shader, *cgoAllocMap) {
	if x.reff85f9b1e != nil {
		return *x.reff85f9b1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Shader) Index(index int32) *Shader {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Shader)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfShaderValue)))
	ret := NewShaderRef(unsafe.Pointer(ptr1))
	return ret
}

// Locs returns a reference to C object within a struct
func (s *Shader) Locs(locsCount int32) []*int32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, locsCount)
	ptr0 := s.ref().locs
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocMaterialMapMemory allocates memory for type C.MaterialMap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialMapValue = unsafe.Sizeof([1]C.MaterialMap{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *MaterialMap) ref() *C.MaterialMap {
	if x == nil {
		return nil
	}
	return x.refa8350ad3
}

// convert struct for mapping C struct unanimous.
func (x *MaterialMap) convert() *materialMap {
	if x.refa8350ad3 != nil {
		return (*materialMap)(unsafe.Pointer(x.refa8350ad3))
	}
	x.PassRef()
	return (*materialMap)(unsafe.Pointer(x.refa8350ad3))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMaterialMap(x *MaterialMap) {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
		// fmt.Printf("MaterialMap memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa8350ad3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.MaterialMap memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewMaterialMap new Go object and Mapping to C object.
func NewMaterialMap(gTexture Texture2D, gColor Color, gValue float32) MaterialMap {
	obj := *new(MaterialMap)
	obj.gTexture = gTexture
	obj.gColor = gColor
	obj.gValue = gValue
	obj.PassRef()
	return obj
}

// NewMaterialMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialMapRef(ref unsafe.Pointer) *MaterialMap {
	if ref == nil {
		return nil
	}
	obj := new(MaterialMap)
	obj.refa8350ad3 = (*C.MaterialMap)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MaterialMap) PassRef() (*C.MaterialMap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8350ad3 != nil {
		if x.allocsa8350ad3 != nil {
			return x.refa8350ad3, x.allocsa8350ad3.(*cgoAllocMap)
		} else {
			return x.refa8350ad3, nil
		}
	}
	mema8350ad3 := unsafe.Pointer(new(C.MaterialMap))
	refa8350ad3 := (*C.MaterialMap)(mema8350ad3)
	allocsa8350ad3 := new(cgoAllocMap)
	// allocsa8350ad3.Add(mema8350ad3)
	defer func() {
		if len(x.allocsa8350ad3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMaterialMap)
		}
	}()

	var ctexture_allocs *cgoAllocMap
	refa8350ad3.texture, ctexture_allocs = x.gTexture.PassValue()
	allocsa8350ad3.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var ccolor_allocs *cgoAllocMap
	refa8350ad3.color, ccolor_allocs = x.gColor.PassValue()
	allocsa8350ad3.Borrow(ccolor_allocs)
	x.gColor = *new(Color)

	var cvalue_allocs *cgoAllocMap
	refa8350ad3.value, cvalue_allocs = (C.float)(x.gValue), cgoAllocsUnknown
	allocsa8350ad3.Borrow(cvalue_allocs)
	x.gValue = *new(float32)

	x.refa8350ad3 = refa8350ad3
	x.allocsa8350ad3 = allocsa8350ad3
	x.This = x.convert()

	return refa8350ad3, allocsa8350ad3
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MaterialMap) PassValue() (C.MaterialMap, *cgoAllocMap) {
	if x.refa8350ad3 != nil {
		return *x.refa8350ad3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *MaterialMap) Index(index int32) *MaterialMap {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMaterialMapValue)))
	ret := NewMaterialMapRef(unsafe.Pointer(ptr1))
	return ret
}

// Texture returns a reference to C object within a struct
func (s *MaterialMap) Texture() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().texture))
	return ret
}

// Color returns a reference to C object within a struct
func (s *MaterialMap) Color() *Color {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Color
	ret = NewColorRef(unsafe.Pointer(&s.ref().color))
	return ret
}

// allocMaterialMemory allocates memory for type C.Material in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialValue = unsafe.Sizeof([1]C.Material{})

// unpackSMaterialMap transforms a sliced Go data structure into plain C format.
func unpackSMaterialMap(x []MaterialMap) (unpacked *C.MaterialMap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.MaterialMap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.MaterialMap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.MaterialMap)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Material) ref() *C.Material {
	if x == nil {
		return nil
	}
	return x.ref85c817c3
}

// convert struct for mapping C struct unanimous.
func (x *Material) convert() *material {
	if x.ref85c817c3 != nil {
		return (*material)(unsafe.Pointer(x.ref85c817c3))
	}
	x.PassRef()
	return (*material)(unsafe.Pointer(x.ref85c817c3))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMaterial(x *Material) {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
		// fmt.Printf("Material memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs85c817c3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Material memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewMaterial new Go object and Mapping to C object.
func NewMaterial(gShader Shader, gMaps []MaterialMap, gParams []float32) Material {
	obj := *new(Material)
	obj.gShader = gShader
	obj.gMaps = gMaps
	obj.gParams = gParams
	obj.PassRef()
	return obj
}

// NewMaterialRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialRef(ref unsafe.Pointer) *Material {
	if ref == nil {
		return nil
	}
	obj := new(Material)
	obj.ref85c817c3 = (*C.Material)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Material) PassRef() (*C.Material, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c817c3 != nil {
		if x.allocs85c817c3 != nil {
			return x.ref85c817c3, x.allocs85c817c3.(*cgoAllocMap)
		} else {
			return x.ref85c817c3, nil
		}
	}
	mem85c817c3 := unsafe.Pointer(new(C.Material))
	ref85c817c3 := (*C.Material)(mem85c817c3)
	allocs85c817c3 := new(cgoAllocMap)
	// allocs85c817c3.Add(mem85c817c3)
	defer func() {
		if len(x.allocs85c817c3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMaterial)
		}
	}()

	var cshader_allocs *cgoAllocMap
	ref85c817c3.shader, cshader_allocs = x.gShader.PassValue()
	allocs85c817c3.Borrow(cshader_allocs)
	x.gShader = *new(Shader)

	var cmaps_allocs *cgoAllocMap
	ref85c817c3.maps, cmaps_allocs = unpackSMaterialMap(x.gMaps)
	allocs85c817c3.Borrow(cmaps_allocs)
	x.gMaps = *new([]MaterialMap)

	var cparams_allocs *cgoAllocMap
	ref85c817c3.params, cparams_allocs = unpackSFloat32(x.gParams)
	allocs85c817c3.Borrow(cparams_allocs)
	x.gParams = *new([]float32)

	x.ref85c817c3 = ref85c817c3
	x.allocs85c817c3 = allocs85c817c3
	x.This = x.convert()

	return ref85c817c3, allocs85c817c3
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Material) PassValue() (C.Material, *cgoAllocMap) {
	if x.ref85c817c3 != nil {
		return *x.ref85c817c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Material) Index(index int32) *Material {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Material)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMaterialValue)))
	ret := NewMaterialRef(unsafe.Pointer(ptr1))
	return ret
}

// Shader returns a reference to C object within a struct
func (s *Material) Shader() *Shader {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Shader
	ret = NewShaderRef(unsafe.Pointer(&s.ref().shader))
	return ret
}

// Maps returns a reference to C object within a struct
func (s *Material) Maps(mapsIndex int32) *MaterialMap {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *MaterialMap
	// c struct pointer offset
	ptr0 := s.ref().maps
	ptr1 := (*C.MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(mapsIndex)*uintptr(sizeOfMaterialMapValue)))

	ret = NewMaterialMapRef(unsafe.Pointer(ptr1))
	return ret
}

// Params returns a reference to C object within a struct
func (s *Material) Params(paramsCount int32) []*float32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, paramsCount)
	ptr0 := s.ref().params
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocTransformMemory allocates memory for type C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransformValue = unsafe.Sizeof([1]C.Transform{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Transform) ref() *C.Transform {
	if x == nil {
		return nil
	}
	return x.reff543030e
}

// convert struct for mapping C struct unanimous.
func (x *Transform) convert() *transform {
	if x.reff543030e != nil {
		return (*transform)(unsafe.Pointer(x.reff543030e))
	}
	x.PassRef()
	return (*transform)(unsafe.Pointer(x.reff543030e))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTransform(x *Transform) {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
		// fmt.Printf("Transform memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsf543030e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Transform memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewTransform new Go object and Mapping to C object.
func NewTransform(gTranslation Vector3, gRotation Quaternion, gScale Vector3) Transform {
	obj := *new(Transform)
	obj.gTranslation = gTranslation
	obj.gRotation = gRotation
	obj.gScale = gScale
	obj.PassRef()
	return obj
}

// NewTransformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransformRef(ref unsafe.Pointer) *Transform {
	if ref == nil {
		return nil
	}
	obj := new(Transform)
	obj.reff543030e = (*C.Transform)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Transform) PassRef() (*C.Transform, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff543030e != nil {
		if x.allocsf543030e != nil {
			return x.reff543030e, x.allocsf543030e.(*cgoAllocMap)
		} else {
			return x.reff543030e, nil
		}
	}
	memf543030e := unsafe.Pointer(new(C.Transform))
	reff543030e := (*C.Transform)(memf543030e)
	allocsf543030e := new(cgoAllocMap)
	// allocsf543030e.Add(memf543030e)
	defer func() {
		if len(x.allocsf543030e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTransform)
		}
	}()

	var ctranslation_allocs *cgoAllocMap
	reff543030e.translation, ctranslation_allocs = x.gTranslation.PassValue()
	allocsf543030e.Borrow(ctranslation_allocs)
	x.gTranslation = *new(Vector3)

	var crotation_allocs *cgoAllocMap
	reff543030e.rotation, crotation_allocs = x.gRotation.PassValue()
	allocsf543030e.Borrow(crotation_allocs)
	x.gRotation = *new(Quaternion)

	var cscale_allocs *cgoAllocMap
	reff543030e.scale, cscale_allocs = x.gScale.PassValue()
	allocsf543030e.Borrow(cscale_allocs)
	x.gScale = *new(Vector3)

	x.reff543030e = reff543030e
	x.allocsf543030e = allocsf543030e
	x.This = x.convert()

	return reff543030e, allocsf543030e
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Transform) PassValue() (C.Transform, *cgoAllocMap) {
	if x.reff543030e != nil {
		return *x.reff543030e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Transform) Index(index int32) *Transform {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTransformValue)))
	ret := NewTransformRef(unsafe.Pointer(ptr1))
	return ret
}

// Translation returns a reference to C object within a struct
func (s *Transform) Translation() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().translation))
	return ret
}

// Rotation returns a reference to C object within a struct
func (s *Transform) Rotation() *Quaternion {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Quaternion
	ret = NewQuaternionRef(unsafe.Pointer(&s.ref().rotation))
	return ret
}

// Scale returns a reference to C object within a struct
func (s *Transform) Scale() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().scale))
	return ret
}

// allocBoneInfoMemory allocates memory for type C.BoneInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoneInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoneInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoneInfoValue = unsafe.Sizeof([1]C.BoneInfo{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoneInfo) ref() *C.BoneInfo {
	if x == nil {
		return nil
	}
	return x.ref5ab7f197
}

// convert struct for mapping C struct unanimous.
func (x *BoneInfo) convert() *boneInfo {
	if x.ref5ab7f197 != nil {
		return (*boneInfo)(unsafe.Pointer(x.ref5ab7f197))
	}
	x.PassRef()
	return (*boneInfo)(unsafe.Pointer(x.ref5ab7f197))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeBoneInfo(x *BoneInfo) {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
		// fmt.Printf("BoneInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ab7f197.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.BoneInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewBoneInfo new Go object and Mapping to C object.
func NewBoneInfo(gName [32]byte, gParent int32) BoneInfo {
	obj := *new(BoneInfo)
	obj.gName = gName
	obj.gParent = gParent
	obj.PassRef()
	return obj
}

// NewBoneInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoneInfoRef(ref unsafe.Pointer) *BoneInfo {
	if ref == nil {
		return nil
	}
	obj := new(BoneInfo)
	obj.ref5ab7f197 = (*C.BoneInfo)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoneInfo) PassRef() (*C.BoneInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ab7f197 != nil {
		if x.allocs5ab7f197 != nil {
			return x.ref5ab7f197, x.allocs5ab7f197.(*cgoAllocMap)
		} else {
			return x.ref5ab7f197, nil
		}
	}
	mem5ab7f197 := unsafe.Pointer(new(C.BoneInfo))
	ref5ab7f197 := (*C.BoneInfo)(mem5ab7f197)
	allocs5ab7f197 := new(cgoAllocMap)
	// allocs5ab7f197.Add(mem5ab7f197)
	defer func() {
		if len(x.allocs5ab7f197.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeBoneInfo)
		}
	}()

	var cname_allocs *cgoAllocMap
	ref5ab7f197.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.gName)), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cname_allocs)
	x.gName = *new([32]byte)

	var cparent_allocs *cgoAllocMap
	ref5ab7f197.parent, cparent_allocs = (C.int)(x.gParent), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cparent_allocs)
	x.gParent = *new(int32)

	x.ref5ab7f197 = ref5ab7f197
	x.allocs5ab7f197 = allocs5ab7f197
	x.This = x.convert()

	return ref5ab7f197, allocs5ab7f197
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoneInfo) PassValue() (C.BoneInfo, *cgoAllocMap) {
	if x.ref5ab7f197 != nil {
		return *x.ref5ab7f197, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *BoneInfo) Index(index int32) *BoneInfo {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfBoneInfoValue)))
	ret := NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// allocModelMemory allocates memory for type C.Model in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelValue = unsafe.Sizeof([1]C.Model{})

// unpackSMesh transforms a sliced Go data structure into plain C format.
func unpackSMesh(x []Mesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackSMaterial transforms a sliced Go data structure into plain C format.
func unpackSMaterial(x []Material) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackSBoneInfo transforms a sliced Go data structure into plain C format.
func unpackSBoneInfo(x []BoneInfo) (unpacked *C.BoneInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.BoneInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBoneInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BoneInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BoneInfo)(h.Data)
	return
}

// unpackSTransform transforms a sliced Go data structure into plain C format.
func unpackSTransform(x []Transform) (unpacked *C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Transform)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Model) ref() *C.Model {
	if x == nil {
		return nil
	}
	return x.ref16545ddd
}

// convert struct for mapping C struct unanimous.
func (x *Model) convert() *model {
	if x.ref16545ddd != nil {
		return (*model)(unsafe.Pointer(x.ref16545ddd))
	}
	x.PassRef()
	return (*model)(unsafe.Pointer(x.ref16545ddd))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeModel(x *Model) {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
		// fmt.Printf("Model memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs16545ddd.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Model memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewModel new Go object and Mapping to C object.
func NewModel(gTransform Matrix, gMeshCount int32, gMeshes []Mesh, gMaterialCount int32, gMaterials []Material, gMeshMaterial []int32, gBoneCount int32, gBones []BoneInfo, gBindPose []Transform) Model {
	obj := *new(Model)
	obj.gTransform = gTransform
	obj.gMeshCount = gMeshCount
	obj.gMeshes = gMeshes
	obj.gMaterialCount = gMaterialCount
	obj.gMaterials = gMaterials
	obj.gMeshMaterial = gMeshMaterial
	obj.gBoneCount = gBoneCount
	obj.gBones = gBones
	obj.gBindPose = gBindPose
	obj.PassRef()
	return obj
}

// NewModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelRef(ref unsafe.Pointer) *Model {
	if ref == nil {
		return nil
	}
	obj := new(Model)
	obj.ref16545ddd = (*C.Model)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Model) PassRef() (*C.Model, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16545ddd != nil {
		if x.allocs16545ddd != nil {
			return x.ref16545ddd, x.allocs16545ddd.(*cgoAllocMap)
		} else {
			return x.ref16545ddd, nil
		}
	}
	mem16545ddd := unsafe.Pointer(new(C.Model))
	ref16545ddd := (*C.Model)(mem16545ddd)
	allocs16545ddd := new(cgoAllocMap)
	// allocs16545ddd.Add(mem16545ddd)
	defer func() {
		if len(x.allocs16545ddd.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeModel)
		}
	}()

	var ctransform_allocs *cgoAllocMap
	ref16545ddd.transform, ctransform_allocs = x.gTransform.PassValue()
	allocs16545ddd.Borrow(ctransform_allocs)
	x.gTransform = *new(Matrix)

	var cmeshCount_allocs *cgoAllocMap
	ref16545ddd.meshCount, cmeshCount_allocs = (C.int)(x.gMeshCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshCount_allocs)
	x.gMeshCount = *new(int32)

	var cmeshes_allocs *cgoAllocMap
	ref16545ddd.meshes, cmeshes_allocs = unpackSMesh(x.gMeshes)
	allocs16545ddd.Borrow(cmeshes_allocs)
	x.gMeshes = *new([]Mesh)

	var cmaterialCount_allocs *cgoAllocMap
	ref16545ddd.materialCount, cmaterialCount_allocs = (C.int)(x.gMaterialCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmaterialCount_allocs)
	x.gMaterialCount = *new(int32)

	var cmaterials_allocs *cgoAllocMap
	ref16545ddd.materials, cmaterials_allocs = unpackSMaterial(x.gMaterials)
	allocs16545ddd.Borrow(cmaterials_allocs)
	x.gMaterials = *new([]Material)

	var cmeshMaterial_allocs *cgoAllocMap
	ref16545ddd.meshMaterial, cmeshMaterial_allocs = unpackSInt32(x.gMeshMaterial)
	allocs16545ddd.Borrow(cmeshMaterial_allocs)
	x.gMeshMaterial = *new([]int32)

	var cboneCount_allocs *cgoAllocMap
	ref16545ddd.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref16545ddd.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs16545ddd.Borrow(cbones_allocs)
	x.gBones = *new([]BoneInfo)

	var cbindPose_allocs *cgoAllocMap
	ref16545ddd.bindPose, cbindPose_allocs = unpackSTransform(x.gBindPose)
	allocs16545ddd.Borrow(cbindPose_allocs)
	x.gBindPose = *new([]Transform)

	x.ref16545ddd = ref16545ddd
	x.allocs16545ddd = allocs16545ddd
	x.This = x.convert()

	return ref16545ddd, allocs16545ddd
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Model) PassValue() (C.Model, *cgoAllocMap) {
	if x.ref16545ddd != nil {
		return *x.ref16545ddd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Model) Index(index int32) *Model {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Model)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfModelValue)))
	ret := NewModelRef(unsafe.Pointer(ptr1))
	return ret
}

// Transform returns a reference to C object within a struct
func (s *Model) Transform() *Matrix {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Matrix
	ret = NewMatrixRef(unsafe.Pointer(&s.ref().transform))
	return ret
}

// Meshes returns a reference to C object within a struct
func (s *Model) Meshes(meshesIndex int32) *Mesh {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Mesh
	// c struct pointer offset
	ptr0 := s.ref().meshes
	ptr1 := (*C.Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(meshesIndex)*uintptr(sizeOfMeshValue)))

	ret = NewMeshRef(unsafe.Pointer(ptr1))
	return ret
}

// Materials returns a reference to C object within a struct
func (s *Model) Materials(materialsIndex int32) *Material {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Material
	// c struct pointer offset
	ptr0 := s.ref().materials
	ptr1 := (*C.Material)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(materialsIndex)*uintptr(sizeOfMaterialValue)))

	ret = NewMaterialRef(unsafe.Pointer(ptr1))
	return ret
}

// MeshMaterial returns a reference to C object within a struct
func (s *Model) MeshMaterial(meshMaterialCount int32) []*int32 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, meshMaterialCount)
	ptr0 := s.ref().meshMaterial
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// Bones returns a reference to C object within a struct
func (s *Model) Bones(bonesIndex int32) *BoneInfo {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *BoneInfo
	// c struct pointer offset
	ptr0 := s.ref().bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bonesIndex)*uintptr(sizeOfBoneInfoValue)))

	ret = NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// BindPose returns a reference to C object within a struct
func (s *Model) BindPose(bindPoseIndex int32) *Transform {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Transform
	// c struct pointer offset
	ptr0 := s.ref().bindPose
	ptr1 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bindPoseIndex)*uintptr(sizeOfTransformValue)))

	ret = NewTransformRef(unsafe.Pointer(ptr1))
	return ret
}

// allocModelAnimationMemory allocates memory for type C.ModelAnimation in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelAnimationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelAnimationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelAnimationValue = unsafe.Sizeof([1]C.ModelAnimation{})

// allocPTransformMemory allocates memory for type *C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTransformValue = unsafe.Sizeof([1]*C.Transform{})

// unpackSSTransform transforms a sliced Go data structure into plain C format.
func unpackSSTransform(x [][]Transform) (unpacked **C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTransformMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Transform)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Transform)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Transform)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *ModelAnimation) ref() *C.ModelAnimation {
	if x == nil {
		return nil
	}
	return x.ref26dd6a24
}

// convert struct for mapping C struct unanimous.
func (x *ModelAnimation) convert() *modelAnimation {
	if x.ref26dd6a24 != nil {
		return (*modelAnimation)(unsafe.Pointer(x.ref26dd6a24))
	}
	x.PassRef()
	return (*modelAnimation)(unsafe.Pointer(x.ref26dd6a24))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeModelAnimation(x *ModelAnimation) {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
		// fmt.Printf("ModelAnimation memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs26dd6a24.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.ModelAnimation memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewModelAnimation new Go object and Mapping to C object.
func NewModelAnimation(gBoneCount int32, gBones []BoneInfo, gFrameCount int32, gFramePoses [][]Transform) ModelAnimation {
	obj := *new(ModelAnimation)
	obj.gBoneCount = gBoneCount
	obj.gBones = gBones
	obj.gFrameCount = gFrameCount
	obj.gFramePoses = gFramePoses
	obj.PassRef()
	return obj
}

// NewModelAnimationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelAnimationRef(ref unsafe.Pointer) *ModelAnimation {
	if ref == nil {
		return nil
	}
	obj := new(ModelAnimation)
	obj.ref26dd6a24 = (*C.ModelAnimation)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ModelAnimation) PassRef() (*C.ModelAnimation, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26dd6a24 != nil {
		if x.allocs26dd6a24 != nil {
			return x.ref26dd6a24, x.allocs26dd6a24.(*cgoAllocMap)
		} else {
			return x.ref26dd6a24, nil
		}
	}
	mem26dd6a24 := unsafe.Pointer(new(C.ModelAnimation))
	ref26dd6a24 := (*C.ModelAnimation)(mem26dd6a24)
	allocs26dd6a24 := new(cgoAllocMap)
	// allocs26dd6a24.Add(mem26dd6a24)
	defer func() {
		if len(x.allocs26dd6a24.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeModelAnimation)
		}
	}()

	var cboneCount_allocs *cgoAllocMap
	ref26dd6a24.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref26dd6a24.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs26dd6a24.Borrow(cbones_allocs)
	x.gBones = *new([]BoneInfo)

	var cframeCount_allocs *cgoAllocMap
	ref26dd6a24.frameCount, cframeCount_allocs = (C.int)(x.gFrameCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cframeCount_allocs)
	x.gFrameCount = *new(int32)

	var cframePoses_allocs *cgoAllocMap
	ref26dd6a24.framePoses, cframePoses_allocs = unpackSSTransform(x.gFramePoses)
	allocs26dd6a24.Borrow(cframePoses_allocs)
	x.gFramePoses = *new([][]Transform)

	x.ref26dd6a24 = ref26dd6a24
	x.allocs26dd6a24 = allocs26dd6a24
	x.This = x.convert()

	return ref26dd6a24, allocs26dd6a24
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ModelAnimation) PassValue() (C.ModelAnimation, *cgoAllocMap) {
	if x.ref26dd6a24 != nil {
		return *x.ref26dd6a24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *ModelAnimation) Index(index int32) *ModelAnimation {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.ModelAnimation)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfModelAnimationValue)))
	ret := NewModelAnimationRef(unsafe.Pointer(ptr1))
	return ret
}

// Bones returns a reference to C object within a struct
func (s *ModelAnimation) Bones(bonesIndex int32) *BoneInfo {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *BoneInfo
	// c struct pointer offset
	ptr0 := s.ref().bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bonesIndex)*uintptr(sizeOfBoneInfoValue)))

	ret = NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// FramePoses returns a reference to C object within a struct
func (s *ModelAnimation) FramePoses(framePosesRow int32, framePosesColumn int32) *Transform {
	if s.ref() == nil {
		s.PassRef()
	}

	row, column := framePosesRow, framePosesColumn
	var ret *Transform
	ptr0 := s.ref().framePoses
	ptr1 := (**C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(row)*uintptr(sizeOfPtr)))
	ptr2 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(*ptr1)) + uintptr(column)*uintptr(sizeOfTransformValue)))
	ret = NewTransformRef(unsafe.Pointer(ptr2))

	return ret
}

// allocRayMemory allocates memory for type C.Ray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayValue = unsafe.Sizeof([1]C.Ray{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Ray) ref() *C.Ray {
	if x == nil {
		return nil
	}
	return x.refc546b0b2
}

// convert struct for mapping C struct unanimous.
func (x *Ray) convert() *ray {
	if x.refc546b0b2 != nil {
		return (*ray)(unsafe.Pointer(x.refc546b0b2))
	}
	x.PassRef()
	return (*ray)(unsafe.Pointer(x.refc546b0b2))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRay(x *Ray) {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
		// fmt.Printf("Ray memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc546b0b2.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Ray memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewRay new Go object and Mapping to C object.
func NewRay(gPosition Vector3, gDirection Vector3) Ray {
	obj := *new(Ray)
	obj.gPosition = gPosition
	obj.gDirection = gDirection
	obj.PassRef()
	return obj
}

// NewRayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayRef(ref unsafe.Pointer) *Ray {
	if ref == nil {
		return nil
	}
	obj := new(Ray)
	obj.refc546b0b2 = (*C.Ray)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Ray) PassRef() (*C.Ray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc546b0b2 != nil {
		if x.allocsc546b0b2 != nil {
			return x.refc546b0b2, x.allocsc546b0b2.(*cgoAllocMap)
		} else {
			return x.refc546b0b2, nil
		}
	}
	memc546b0b2 := unsafe.Pointer(new(C.Ray))
	refc546b0b2 := (*C.Ray)(memc546b0b2)
	allocsc546b0b2 := new(cgoAllocMap)
	// allocsc546b0b2.Add(memc546b0b2)
	defer func() {
		if len(x.allocsc546b0b2.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRay)
		}
	}()

	var cposition_allocs *cgoAllocMap
	refc546b0b2.position, cposition_allocs = x.gPosition.PassValue()
	allocsc546b0b2.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var cdirection_allocs *cgoAllocMap
	refc546b0b2.direction, cdirection_allocs = x.gDirection.PassValue()
	allocsc546b0b2.Borrow(cdirection_allocs)
	x.gDirection = *new(Vector3)

	x.refc546b0b2 = refc546b0b2
	x.allocsc546b0b2 = allocsc546b0b2
	x.This = x.convert()

	return refc546b0b2, allocsc546b0b2
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Ray) PassValue() (C.Ray, *cgoAllocMap) {
	if x.refc546b0b2 != nil {
		return *x.refc546b0b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Ray) Index(index int32) *Ray {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Ray)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRayValue)))
	ret := NewRayRef(unsafe.Pointer(ptr1))
	return ret
}

// Position returns a reference to C object within a struct
func (s *Ray) Position() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().position))
	return ret
}

// Direction returns a reference to C object within a struct
func (s *Ray) Direction() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().direction))
	return ret
}

// allocRayHitInfoMemory allocates memory for type C.RayHitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayHitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayHitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayHitInfoValue = unsafe.Sizeof([1]C.RayHitInfo{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayHitInfo) ref() *C.RayHitInfo {
	if x == nil {
		return nil
	}
	return x.refb8de43a9
}

// convert struct for mapping C struct unanimous.
func (x *RayHitInfo) convert() *rayHitInfo {
	if x.refb8de43a9 != nil {
		return (*rayHitInfo)(unsafe.Pointer(x.refb8de43a9))
	}
	x.PassRef()
	return (*rayHitInfo)(unsafe.Pointer(x.refb8de43a9))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRayHitInfo(x *RayHitInfo) {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
		// fmt.Printf("RayHitInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsb8de43a9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RayHitInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewRayHitInfo new Go object and Mapping to C object.
func NewRayHitInfo(gHit bool, gDistance float32, gPosition Vector3, gNormal Vector3) RayHitInfo {
	obj := *new(RayHitInfo)
	obj.gHit = gHit
	obj.gDistance = gDistance
	obj.gPosition = gPosition
	obj.gNormal = gNormal
	obj.PassRef()
	return obj
}

// NewRayHitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayHitInfoRef(ref unsafe.Pointer) *RayHitInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayHitInfo)
	obj.refb8de43a9 = (*C.RayHitInfo)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayHitInfo) PassRef() (*C.RayHitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8de43a9 != nil {
		if x.allocsb8de43a9 != nil {
			return x.refb8de43a9, x.allocsb8de43a9.(*cgoAllocMap)
		} else {
			return x.refb8de43a9, nil
		}
	}
	memb8de43a9 := unsafe.Pointer(new(C.RayHitInfo))
	refb8de43a9 := (*C.RayHitInfo)(memb8de43a9)
	allocsb8de43a9 := new(cgoAllocMap)
	// allocsb8de43a9.Add(memb8de43a9)
	defer func() {
		if len(x.allocsb8de43a9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRayHitInfo)
		}
	}()

	var chit_allocs *cgoAllocMap
	refb8de43a9.hit, chit_allocs = (C._Bool)(x.gHit), cgoAllocsUnknown
	allocsb8de43a9.Borrow(chit_allocs)
	x.gHit = *new(bool)

	var cdistance_allocs *cgoAllocMap
	refb8de43a9.distance, cdistance_allocs = (C.float)(x.gDistance), cgoAllocsUnknown
	allocsb8de43a9.Borrow(cdistance_allocs)
	x.gDistance = *new(float32)

	var cposition_allocs *cgoAllocMap
	refb8de43a9.position, cposition_allocs = x.gPosition.PassValue()
	allocsb8de43a9.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var cnormal_allocs *cgoAllocMap
	refb8de43a9.normal, cnormal_allocs = x.gNormal.PassValue()
	allocsb8de43a9.Borrow(cnormal_allocs)
	x.gNormal = *new(Vector3)

	x.refb8de43a9 = refb8de43a9
	x.allocsb8de43a9 = allocsb8de43a9
	x.This = x.convert()

	return refb8de43a9, allocsb8de43a9
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayHitInfo) PassValue() (C.RayHitInfo, *cgoAllocMap) {
	if x.refb8de43a9 != nil {
		return *x.refb8de43a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *RayHitInfo) Index(index int32) *RayHitInfo {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.RayHitInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRayHitInfoValue)))
	ret := NewRayHitInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// Position returns a reference to C object within a struct
func (s *RayHitInfo) Position() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().position))
	return ret
}

// Normal returns a reference to C object within a struct
func (s *RayHitInfo) Normal() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().normal))
	return ret
}

// allocBoundingBoxMemory allocates memory for type C.BoundingBox in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoundingBoxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoundingBoxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoundingBoxValue = unsafe.Sizeof([1]C.BoundingBox{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoundingBox) ref() *C.BoundingBox {
	if x == nil {
		return nil
	}
	return x.refa54e9d16
}

// convert struct for mapping C struct unanimous.
func (x *BoundingBox) convert() *boundingBox {
	if x.refa54e9d16 != nil {
		return (*boundingBox)(unsafe.Pointer(x.refa54e9d16))
	}
	x.PassRef()
	return (*boundingBox)(unsafe.Pointer(x.refa54e9d16))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeBoundingBox(x *BoundingBox) {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
		// fmt.Printf("BoundingBox memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa54e9d16.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.BoundingBox memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewBoundingBox new Go object and Mapping to C object.
func NewBoundingBox(gMin Vector3, gMax Vector3) BoundingBox {
	obj := *new(BoundingBox)
	obj.gMin = gMin
	obj.gMax = gMax
	obj.PassRef()
	return obj
}

// NewBoundingBoxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoundingBoxRef(ref unsafe.Pointer) *BoundingBox {
	if ref == nil {
		return nil
	}
	obj := new(BoundingBox)
	obj.refa54e9d16 = (*C.BoundingBox)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoundingBox) PassRef() (*C.BoundingBox, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54e9d16 != nil {
		if x.allocsa54e9d16 != nil {
			return x.refa54e9d16, x.allocsa54e9d16.(*cgoAllocMap)
		} else {
			return x.refa54e9d16, nil
		}
	}
	mema54e9d16 := unsafe.Pointer(new(C.BoundingBox))
	refa54e9d16 := (*C.BoundingBox)(mema54e9d16)
	allocsa54e9d16 := new(cgoAllocMap)
	// allocsa54e9d16.Add(mema54e9d16)
	defer func() {
		if len(x.allocsa54e9d16.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeBoundingBox)
		}
	}()

	var cmin_allocs *cgoAllocMap
	refa54e9d16.min, cmin_allocs = x.gMin.PassValue()
	allocsa54e9d16.Borrow(cmin_allocs)
	x.gMin = *new(Vector3)

	var cmax_allocs *cgoAllocMap
	refa54e9d16.max, cmax_allocs = x.gMax.PassValue()
	allocsa54e9d16.Borrow(cmax_allocs)
	x.gMax = *new(Vector3)

	x.refa54e9d16 = refa54e9d16
	x.allocsa54e9d16 = allocsa54e9d16
	x.This = x.convert()

	return refa54e9d16, allocsa54e9d16
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoundingBox) PassValue() (C.BoundingBox, *cgoAllocMap) {
	if x.refa54e9d16 != nil {
		return *x.refa54e9d16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *BoundingBox) Index(index int32) *BoundingBox {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.BoundingBox)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfBoundingBoxValue)))
	ret := NewBoundingBoxRef(unsafe.Pointer(ptr1))
	return ret
}

// Min returns a reference to C object within a struct
func (s *BoundingBox) Min() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().min))
	return ret
}

// Max returns a reference to C object within a struct
func (s *BoundingBox) Max() *Vector3 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.ref().max))
	return ret
}

// allocWaveMemory allocates memory for type C.Wave in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWaveValue = unsafe.Sizeof([1]C.Wave{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Wave) ref() *C.Wave {
	if x == nil {
		return nil
	}
	return x.ref7a3602b7
}

// convert struct for mapping C struct unanimous.
func (x *Wave) convert() *wave {
	if x.ref7a3602b7 != nil {
		return (*wave)(unsafe.Pointer(x.ref7a3602b7))
	}
	x.PassRef()
	return (*wave)(unsafe.Pointer(x.ref7a3602b7))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeWave(x *Wave) {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
		// fmt.Printf("Wave memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7a3602b7.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Wave memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewWave new Go object and Mapping to C object.
func NewWave(gSampleCount uint32, gSampleRate uint32, gSampleSize uint32, gChannels uint32, gData unsafe.Pointer) Wave {
	obj := *new(Wave)
	obj.gSampleCount = gSampleCount
	obj.gSampleRate = gSampleRate
	obj.gSampleSize = gSampleSize
	obj.gChannels = gChannels
	obj.gData = gData
	obj.PassRef()
	return obj
}

// NewWaveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWaveRef(ref unsafe.Pointer) *Wave {
	if ref == nil {
		return nil
	}
	obj := new(Wave)
	obj.ref7a3602b7 = (*C.Wave)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Wave) PassRef() (*C.Wave, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a3602b7 != nil {
		if x.allocs7a3602b7 != nil {
			return x.ref7a3602b7, x.allocs7a3602b7.(*cgoAllocMap)
		} else {
			return x.ref7a3602b7, nil
		}
	}
	mem7a3602b7 := unsafe.Pointer(new(C.Wave))
	ref7a3602b7 := (*C.Wave)(mem7a3602b7)
	allocs7a3602b7 := new(cgoAllocMap)
	// allocs7a3602b7.Add(mem7a3602b7)
	defer func() {
		if len(x.allocs7a3602b7.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeWave)
		}
	}()

	var csampleCount_allocs *cgoAllocMap
	ref7a3602b7.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var csampleRate_allocs *cgoAllocMap
	ref7a3602b7.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref7a3602b7.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref7a3602b7.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	var cdata_allocs *cgoAllocMap
	ref7a3602b7.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	x.ref7a3602b7 = ref7a3602b7
	x.allocs7a3602b7 = allocs7a3602b7
	x.This = x.convert()

	return ref7a3602b7, allocs7a3602b7
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Wave) PassValue() (C.Wave, *cgoAllocMap) {
	if x.ref7a3602b7 != nil {
		return *x.ref7a3602b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Wave) Index(index int32) *Wave {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Wave)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfWaveValue)))
	ret := NewWaveRef(unsafe.Pointer(ptr1))
	return ret
}

// allocAudioStreamMemory allocates memory for type C.AudioStream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAudioStreamValue = unsafe.Sizeof([1]C.AudioStream{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioStream) ref() *C.AudioStream {
	if x == nil {
		return nil
	}
	return x.ref997374a2
}

// convert struct for mapping C struct unanimous.
func (x *AudioStream) convert() *audioStream {
	if x.ref997374a2 != nil {
		return (*audioStream)(unsafe.Pointer(x.ref997374a2))
	}
	x.PassRef()
	return (*audioStream)(unsafe.Pointer(x.ref997374a2))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeAudioStream(x *AudioStream) {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
		// fmt.Printf("AudioStream memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs997374a2.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.AudioStream memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewAudioStream new Go object and Mapping to C object.
func NewAudioStream(gSampleRate uint32, gSampleSize uint32, gChannels uint32) AudioStream {
	obj := *new(AudioStream)
	obj.gSampleRate = gSampleRate
	obj.gSampleSize = gSampleSize
	obj.gChannels = gChannels
	obj.PassRef()
	return obj
}

// NewAudioStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioStreamRef(ref unsafe.Pointer) *AudioStream {
	if ref == nil {
		return nil
	}
	obj := new(AudioStream)
	obj.ref997374a2 = (*C.AudioStream)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioStream) PassRef() (*C.AudioStream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref997374a2 != nil {
		if x.allocs997374a2 != nil {
			return x.ref997374a2, x.allocs997374a2.(*cgoAllocMap)
		} else {
			return x.ref997374a2, nil
		}
	}
	mem997374a2 := unsafe.Pointer(new(C.AudioStream))
	ref997374a2 := (*C.AudioStream)(mem997374a2)
	allocs997374a2 := new(cgoAllocMap)
	// allocs997374a2.Add(mem997374a2)
	defer func() {
		if len(x.allocs997374a2.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeAudioStream)
		}
	}()

	var csampleRate_allocs *cgoAllocMap
	ref997374a2.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref997374a2.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref997374a2.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs997374a2.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	x.ref997374a2 = ref997374a2
	x.allocs997374a2 = allocs997374a2
	x.This = x.convert()

	return ref997374a2, allocs997374a2
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioStream) PassValue() (C.AudioStream, *cgoAllocMap) {
	if x.ref997374a2 != nil {
		return *x.ref997374a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *AudioStream) Index(index int32) *AudioStream {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.AudioStream)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfAudioStreamValue)))
	ret := NewAudioStreamRef(unsafe.Pointer(ptr1))
	return ret
}

// allocSoundMemory allocates memory for type C.Sound in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSoundMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSoundValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSoundValue = unsafe.Sizeof([1]C.Sound{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sound) ref() *C.Sound {
	if x == nil {
		return nil
	}
	return x.ref394fec80
}

// convert struct for mapping C struct unanimous.
func (x *Sound) convert() *sound {
	if x.ref394fec80 != nil {
		return (*sound)(unsafe.Pointer(x.ref394fec80))
	}
	x.PassRef()
	return (*sound)(unsafe.Pointer(x.ref394fec80))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeSound(x *Sound) {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
		// fmt.Printf("Sound memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs394fec80.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Sound memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewSound new Go object and Mapping to C object.
func NewSound(gSampleCount uint32, gStream AudioStream) Sound {
	obj := *new(Sound)
	obj.gSampleCount = gSampleCount
	obj.gStream = gStream
	obj.PassRef()
	return obj
}

// NewSoundRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSoundRef(ref unsafe.Pointer) *Sound {
	if ref == nil {
		return nil
	}
	obj := new(Sound)
	obj.ref394fec80 = (*C.Sound)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sound) PassRef() (*C.Sound, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394fec80 != nil {
		if x.allocs394fec80 != nil {
			return x.ref394fec80, x.allocs394fec80.(*cgoAllocMap)
		} else {
			return x.ref394fec80, nil
		}
	}
	mem394fec80 := unsafe.Pointer(new(C.Sound))
	ref394fec80 := (*C.Sound)(mem394fec80)
	allocs394fec80 := new(cgoAllocMap)
	// allocs394fec80.Add(mem394fec80)
	defer func() {
		if len(x.allocs394fec80.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeSound)
		}
	}()

	var csampleCount_allocs *cgoAllocMap
	ref394fec80.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs394fec80.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	ref394fec80.stream, cstream_allocs = x.gStream.PassValue()
	allocs394fec80.Borrow(cstream_allocs)
	x.gStream = *new(AudioStream)

	x.ref394fec80 = ref394fec80
	x.allocs394fec80 = allocs394fec80
	x.This = x.convert()

	return ref394fec80, allocs394fec80
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sound) PassValue() (C.Sound, *cgoAllocMap) {
	if x.ref394fec80 != nil {
		return *x.ref394fec80, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Sound) Index(index int32) *Sound {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Sound)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfSoundValue)))
	ret := NewSoundRef(unsafe.Pointer(ptr1))
	return ret
}

// Stream returns a reference to C object within a struct
func (s *Sound) Stream() *AudioStream {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *AudioStream
	ret = NewAudioStreamRef(unsafe.Pointer(&s.ref().stream))
	return ret
}

// allocMusicMemory allocates memory for type C.Music in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMusicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMusicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMusicValue = unsafe.Sizeof([1]C.Music{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Music) ref() *C.Music {
	if x == nil {
		return nil
	}
	return x.refc930d4e
}

// convert struct for mapping C struct unanimous.
func (x *Music) convert() *music {
	if x.refc930d4e != nil {
		return (*music)(unsafe.Pointer(x.refc930d4e))
	}
	x.PassRef()
	return (*music)(unsafe.Pointer(x.refc930d4e))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMusic(x *Music) {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
		// fmt.Printf("Music memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc930d4e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Music memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewMusic new Go object and Mapping to C object.
func NewMusic(gCtxType int32, gCtxData unsafe.Pointer, gLooping bool, gSampleCount uint32, gStream AudioStream) Music {
	obj := *new(Music)
	obj.gCtxType = gCtxType
	obj.gCtxData = gCtxData
	obj.gLooping = gLooping
	obj.gSampleCount = gSampleCount
	obj.gStream = gStream
	obj.PassRef()
	return obj
}

// NewMusicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMusicRef(ref unsafe.Pointer) *Music {
	if ref == nil {
		return nil
	}
	obj := new(Music)
	obj.refc930d4e = (*C.Music)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Music) PassRef() (*C.Music, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc930d4e != nil {
		if x.allocsc930d4e != nil {
			return x.refc930d4e, x.allocsc930d4e.(*cgoAllocMap)
		} else {
			return x.refc930d4e, nil
		}
	}
	memc930d4e := unsafe.Pointer(new(C.Music))
	refc930d4e := (*C.Music)(memc930d4e)
	allocsc930d4e := new(cgoAllocMap)
	// allocsc930d4e.Add(memc930d4e)
	defer func() {
		if len(x.allocsc930d4e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMusic)
		}
	}()

	var cctxType_allocs *cgoAllocMap
	refc930d4e.ctxType, cctxType_allocs = (C.int)(x.gCtxType), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxType_allocs)
	x.gCtxType = *new(int32)

	var cctxData_allocs *cgoAllocMap
	refc930d4e.ctxData, cctxData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gCtxData)), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxData_allocs)
	x.gCtxData = *new(unsafe.Pointer)

	var clooping_allocs *cgoAllocMap
	refc930d4e.looping, clooping_allocs = (C._Bool)(x.gLooping), cgoAllocsUnknown
	allocsc930d4e.Borrow(clooping_allocs)
	x.gLooping = *new(bool)

	var csampleCount_allocs *cgoAllocMap
	refc930d4e.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	refc930d4e.stream, cstream_allocs = x.gStream.PassValue()
	allocsc930d4e.Borrow(cstream_allocs)
	x.gStream = *new(AudioStream)

	x.refc930d4e = refc930d4e
	x.allocsc930d4e = allocsc930d4e
	x.This = x.convert()

	return refc930d4e, allocsc930d4e
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Music) PassValue() (C.Music, *cgoAllocMap) {
	if x.refc930d4e != nil {
		return *x.refc930d4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Music) Index(index int32) *Music {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Music)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMusicValue)))
	ret := NewMusicRef(unsafe.Pointer(ptr1))
	return ret
}

// Stream returns a reference to C object within a struct
func (s *Music) Stream() *AudioStream {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *AudioStream
	ret = NewAudioStreamRef(unsafe.Pointer(&s.ref().stream))
	return ret
}

// allocVrDeviceInfoMemory allocates memory for type C.VrDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVrDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVrDeviceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVrDeviceInfoValue = unsafe.Sizeof([1]C.VrDeviceInfo{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *VrDeviceInfo) ref() *C.VrDeviceInfo {
	if x == nil {
		return nil
	}
	return x.ref6e24e41d
}

// convert struct for mapping C struct unanimous.
func (x *VrDeviceInfo) convert() *vrDeviceInfo {
	if x.ref6e24e41d != nil {
		return (*vrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
	}
	x.PassRef()
	return (*vrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVrDeviceInfo(x *VrDeviceInfo) {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
		// fmt.Printf("VrDeviceInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs6e24e41d.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.VrDeviceInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVrDeviceInfo new Go object and Mapping to C object.
func NewVrDeviceInfo(gHResolution int32, gVResolution int32, gHScreenSize float32, gVScreenSize float32, gVScreenCenter float32, gEyeToScreenDistance float32, gLensSeparationDistance float32, gInterpupillaryDistance float32, gLensDistortionValues [4]float32, gChromaAbCorrection [4]float32) VrDeviceInfo {
	obj := *new(VrDeviceInfo)
	obj.gHResolution = gHResolution
	obj.gVResolution = gVResolution
	obj.gHScreenSize = gHScreenSize
	obj.gVScreenSize = gVScreenSize
	obj.gVScreenCenter = gVScreenCenter
	obj.gEyeToScreenDistance = gEyeToScreenDistance
	obj.gLensSeparationDistance = gLensSeparationDistance
	obj.gInterpupillaryDistance = gInterpupillaryDistance
	obj.gLensDistortionValues = gLensDistortionValues
	obj.gChromaAbCorrection = gChromaAbCorrection
	obj.PassRef()
	return obj
}

// NewVrDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVrDeviceInfoRef(ref unsafe.Pointer) *VrDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(VrDeviceInfo)
	obj.ref6e24e41d = (*C.VrDeviceInfo)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VrDeviceInfo) PassRef() (*C.VrDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e24e41d != nil {
		if x.allocs6e24e41d != nil {
			return x.ref6e24e41d, x.allocs6e24e41d.(*cgoAllocMap)
		} else {
			return x.ref6e24e41d, nil
		}
	}
	mem6e24e41d := unsafe.Pointer(new(C.VrDeviceInfo))
	ref6e24e41d := (*C.VrDeviceInfo)(mem6e24e41d)
	allocs6e24e41d := new(cgoAllocMap)
	// allocs6e24e41d.Add(mem6e24e41d)
	defer func() {
		if len(x.allocs6e24e41d.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVrDeviceInfo)
		}
	}()

	var chResolution_allocs *cgoAllocMap
	ref6e24e41d.hResolution, chResolution_allocs = (C.int)(x.gHResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chResolution_allocs)
	x.gHResolution = *new(int32)

	var cvResolution_allocs *cgoAllocMap
	ref6e24e41d.vResolution, cvResolution_allocs = (C.int)(x.gVResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvResolution_allocs)
	x.gVResolution = *new(int32)

	var chScreenSize_allocs *cgoAllocMap
	ref6e24e41d.hScreenSize, chScreenSize_allocs = (C.float)(x.gHScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chScreenSize_allocs)
	x.gHScreenSize = *new(float32)

	var cvScreenSize_allocs *cgoAllocMap
	ref6e24e41d.vScreenSize, cvScreenSize_allocs = (C.float)(x.gVScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenSize_allocs)
	x.gVScreenSize = *new(float32)

	var cvScreenCenter_allocs *cgoAllocMap
	ref6e24e41d.vScreenCenter, cvScreenCenter_allocs = (C.float)(x.gVScreenCenter), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenCenter_allocs)
	x.gVScreenCenter = *new(float32)

	var ceyeToScreenDistance_allocs *cgoAllocMap
	ref6e24e41d.eyeToScreenDistance, ceyeToScreenDistance_allocs = (C.float)(x.gEyeToScreenDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(ceyeToScreenDistance_allocs)
	x.gEyeToScreenDistance = *new(float32)

	var clensSeparationDistance_allocs *cgoAllocMap
	ref6e24e41d.lensSeparationDistance, clensSeparationDistance_allocs = (C.float)(x.gLensSeparationDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensSeparationDistance_allocs)
	x.gLensSeparationDistance = *new(float32)

	var cinterpupillaryDistance_allocs *cgoAllocMap
	ref6e24e41d.interpupillaryDistance, cinterpupillaryDistance_allocs = (C.float)(x.gInterpupillaryDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cinterpupillaryDistance_allocs)
	x.gInterpupillaryDistance = *new(float32)

	var clensDistortionValues_allocs *cgoAllocMap
	ref6e24e41d.lensDistortionValues, clensDistortionValues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gLensDistortionValues)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensDistortionValues_allocs)
	x.gLensDistortionValues = *new([4]float32)

	var cchromaAbCorrection_allocs *cgoAllocMap
	ref6e24e41d.chromaAbCorrection, cchromaAbCorrection_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gChromaAbCorrection)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cchromaAbCorrection_allocs)
	x.gChromaAbCorrection = *new([4]float32)

	x.ref6e24e41d = ref6e24e41d
	x.allocs6e24e41d = allocs6e24e41d
	x.This = x.convert()

	return ref6e24e41d, allocs6e24e41d
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VrDeviceInfo) PassValue() (C.VrDeviceInfo, *cgoAllocMap) {
	if x.ref6e24e41d != nil {
		return *x.ref6e24e41d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *VrDeviceInfo) Index(index int32) *VrDeviceInfo {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.VrDeviceInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVrDeviceInfoValue)))
	ret := NewVrDeviceInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// allocTextMemory allocates memory for type C.Text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextValue = unsafe.Sizeof([1]C.Text{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		var allocs0 *cgoAllocMap
		v0[i0], allocs0 = unpackMemoryPCharString(x[i0])
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackMemoryPCharString represents the data from Go string as *C.char and avoids copying.
func unpackMemoryPCharString(str string) (*C.char, *cgoAllocMap) {
	ptr0 := C.CString(str)
	mem0 := unsafe.Pointer(ptr0)
	allocs0 := new(cgoAllocMap)
	allocs0.Add(mem0)
	return ptr0, allocs0
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Text) ref() *C.Text {
	if x == nil {
		return nil
	}
	return x.ref9bb908f9
}

// convert struct for mapping C struct unanimous.
func (x *Text) convert() *text {
	if x.ref9bb908f9 != nil {
		return (*text)(unsafe.Pointer(x.ref9bb908f9))
	}
	x.PassRef()
	return (*text)(unsafe.Pointer(x.ref9bb908f9))
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeText(x *Text) {
	if x != nil && x.allocs9bb908f9 != nil {
		x.allocs9bb908f9.(*cgoAllocMap).Free()
		x.ref9bb908f9 = nil
		// fmt.Printf("Text memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs9bb908f9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Text memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewText new Go object and Mapping to C object.
func NewText(gText []string) Text {
	obj := *new(Text)
	obj.gText = gText
	obj.PassRef()
	return obj
}

// NewTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextRef(ref unsafe.Pointer) *Text {
	if ref == nil {
		return nil
	}
	obj := new(Text)
	obj.ref9bb908f9 = (*C.Text)(unsafe.Pointer(ref))
	// This
	obj.This = obj.convert()
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Text) PassRef() (*C.Text, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9bb908f9 != nil {
		if x.allocs9bb908f9 != nil {
			return x.ref9bb908f9, x.allocs9bb908f9.(*cgoAllocMap)
		} else {
			return x.ref9bb908f9, nil
		}
	}
	mem9bb908f9 := unsafe.Pointer(new(C.Text))
	ref9bb908f9 := (*C.Text)(mem9bb908f9)
	allocs9bb908f9 := new(cgoAllocMap)
	// allocs9bb908f9.Add(mem9bb908f9)
	defer func() {
		if len(x.allocs9bb908f9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeText)
		}
	}()

	var ctext_allocs *cgoAllocMap
	ref9bb908f9.text, ctext_allocs = unpackSString(x.gText)
	allocs9bb908f9.Borrow(ctext_allocs)
	x.gText = *new([]string)

	x.ref9bb908f9 = ref9bb908f9
	x.allocs9bb908f9 = allocs9bb908f9
	x.This = x.convert()

	return ref9bb908f9, allocs9bb908f9
}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Text) PassValue() (C.Text, *cgoAllocMap) {
	if x.ref9bb908f9 != nil {
		return *x.ref9bb908f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Text) Index(index int32) *Text {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Text)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTextValue)))
	ret := NewTextRef(unsafe.Pointer(ptr1))
	return ret
}

// Text returns a reference to C object within a struct

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
