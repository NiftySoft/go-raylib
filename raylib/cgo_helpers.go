// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 03 Aug 2020 11:53:49 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raylib

/*
#include "../lib/raylib/src/raylib.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("add reference, still exist: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) Ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector2) ResetRef() {
	if x == nil {
		return
	}
	x.ref29ca61a5 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector2) FreeRef() {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		return
	}
	if x != nil && x.ref29ca61a5 != nil && x.allocs29ca61a5 == nil {
		C.free(unsafe.Pointer(x.ref29ca61a5))
		x.ref29ca61a5 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.Y = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector2) Convert() *vector2 {
	if x.ref29ca61a5 != nil {
		return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.PassRef()
	return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector3) Ref() *C.Vector3 {
	if x == nil {
		return nil
	}
	return x.ref5ecd5133
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector3) ResetRef() {
	if x == nil {
		return
	}
	x.ref5ecd5133 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector3) FreeRef() {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		return
	}
	if x != nil && x.ref5ecd5133 != nil && x.allocs5ecd5133 == nil {
		C.free(unsafe.Pointer(x.ref5ecd5133))
		x.ref5ecd5133 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector3(x *Vector3) {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		// fmt.Printf("Vector3 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ecd5133.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector3 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector3Ref(ref unsafe.Pointer) *Vector3 {
	if ref == nil {
		return nil
	}
	obj := new(Vector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector3) PassRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		return x.ref5ecd5133, nil
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.Y = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.Z = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133
	defer func() {
		if len(x.allocs5ecd5133.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector3)
		}
	}()
	return ref5ecd5133, allocs5ecd5133

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector3) PassValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector3) Convert() *vector3 {
	if x.ref5ecd5133 != nil {
		return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.PassRef()
	return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// allocVector4Memory allocates memory for type C.Vector4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector4Value = unsafe.Sizeof([1]C.Vector4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector4) Ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector4) ResetRef() {
	if x == nil {
		return
	}
	x.refc0a9c490 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector4) FreeRef() {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		return
	}
	if x != nil && x.refc0a9c490 != nil && x.allocsc0a9c490 == nil {
		C.free(unsafe.Pointer(x.refc0a9c490))
		x.refc0a9c490 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector4(x *Vector4) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		// fmt.Printf("Vector4 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector4 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector4Ref(ref unsafe.Pointer) *Vector4 {
	if ref == nil {
		return nil
	}
	obj := new(Vector4)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector4) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		return x.refc0a9c490, nil
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.Y = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.Z = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.W = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	defer func() {
		if len(x.allocsc0a9c490.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector4)
		}
	}()
	return refc0a9c490, allocsc0a9c490

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector4) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector4) Convert() *vector4 {
	if x.refc0a9c490 != nil {
		return (*vector4)(unsafe.Pointer(x.refc0a9c490))
	}
	x.PassRef()
	return (*vector4)(unsafe.Pointer(x.refc0a9c490))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Quaternion) Ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Quaternion) ResetRef() {
	if x == nil {
		return
	}
	x.refc0a9c490 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Quaternion) FreeRef() {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		return
	}
	if x != nil && x.refc0a9c490 != nil && x.allocsc0a9c490 == nil {
		C.free(unsafe.Pointer(x.refc0a9c490))
		x.refc0a9c490 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeQuaternion(x *Quaternion) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		// fmt.Printf("Quaternion memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector4 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewQuaternionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQuaternionRef(ref unsafe.Pointer) *Quaternion {
	if ref == nil {
		return nil
	}
	obj := new(Quaternion)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Quaternion) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		return x.refc0a9c490, nil
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.Y = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.Z = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.W), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.W = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	defer func() {
		if len(x.allocsc0a9c490.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeQuaternion)
		}
	}()
	return refc0a9c490, allocsc0a9c490

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Quaternion) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Quaternion) Convert() *quaternion {
	if x.refc0a9c490 != nil {
		return (*quaternion)(unsafe.Pointer(x.refc0a9c490))
	}
	x.PassRef()
	return (*quaternion)(unsafe.Pointer(x.refc0a9c490))
}

// allocMatrixMemory allocates memory for type C.Matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.Matrix{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix) Ref() *C.Matrix {
	if x == nil {
		return nil
	}
	return x.refff9f44f9
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Matrix) ResetRef() {
	if x == nil {
		return
	}
	x.refff9f44f9 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Matrix) FreeRef() {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
		return
	}
	if x != nil && x.refff9f44f9 != nil && x.allocsff9f44f9 == nil {
		C.free(unsafe.Pointer(x.refff9f44f9))
		x.refff9f44f9 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMatrix(x *Matrix) {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
		// fmt.Printf("Matrix memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsff9f44f9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Matrix memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	if ref == nil {
		return nil
	}
	obj := new(Matrix)
	obj.refff9f44f9 = (*C.Matrix)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix) PassRef() (*C.Matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff9f44f9 != nil {
		return x.refff9f44f9, nil
	}
	memff9f44f9 := unsafe.Pointer(new(C.Matrix))
	refff9f44f9 := (*C.Matrix)(memff9f44f9)
	allocsff9f44f9 := new(cgoAllocMap)
	// allocsff9f44f9.Add(memff9f44f9)

	var cm0_allocs *cgoAllocMap
	refff9f44f9.m0, cm0_allocs = (C.float)(x.M0), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm0_allocs)
	x.M0 = *new(float32)

	var cm4_allocs *cgoAllocMap
	refff9f44f9.m4, cm4_allocs = (C.float)(x.M4), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm4_allocs)
	x.M4 = *new(float32)

	var cm8_allocs *cgoAllocMap
	refff9f44f9.m8, cm8_allocs = (C.float)(x.M8), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm8_allocs)
	x.M8 = *new(float32)

	var cm12_allocs *cgoAllocMap
	refff9f44f9.m12, cm12_allocs = (C.float)(x.M12), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm12_allocs)
	x.M12 = *new(float32)

	var cm1_allocs *cgoAllocMap
	refff9f44f9.m1, cm1_allocs = (C.float)(x.M1), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm1_allocs)
	x.M1 = *new(float32)

	var cm5_allocs *cgoAllocMap
	refff9f44f9.m5, cm5_allocs = (C.float)(x.M5), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm5_allocs)
	x.M5 = *new(float32)

	var cm9_allocs *cgoAllocMap
	refff9f44f9.m9, cm9_allocs = (C.float)(x.M9), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm9_allocs)
	x.M9 = *new(float32)

	var cm13_allocs *cgoAllocMap
	refff9f44f9.m13, cm13_allocs = (C.float)(x.M13), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm13_allocs)
	x.M13 = *new(float32)

	var cm2_allocs *cgoAllocMap
	refff9f44f9.m2, cm2_allocs = (C.float)(x.M2), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm2_allocs)
	x.M2 = *new(float32)

	var cm6_allocs *cgoAllocMap
	refff9f44f9.m6, cm6_allocs = (C.float)(x.M6), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm6_allocs)
	x.M6 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refff9f44f9.m10, cm10_allocs = (C.float)(x.M10), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm10_allocs)
	x.M10 = *new(float32)

	var cm14_allocs *cgoAllocMap
	refff9f44f9.m14, cm14_allocs = (C.float)(x.M14), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm14_allocs)
	x.M14 = *new(float32)

	var cm3_allocs *cgoAllocMap
	refff9f44f9.m3, cm3_allocs = (C.float)(x.M3), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm3_allocs)
	x.M3 = *new(float32)

	var cm7_allocs *cgoAllocMap
	refff9f44f9.m7, cm7_allocs = (C.float)(x.M7), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm7_allocs)
	x.M7 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refff9f44f9.m11, cm11_allocs = (C.float)(x.M11), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm11_allocs)
	x.M11 = *new(float32)

	var cm15_allocs *cgoAllocMap
	refff9f44f9.m15, cm15_allocs = (C.float)(x.M15), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm15_allocs)
	x.M15 = *new(float32)

	x.refff9f44f9 = refff9f44f9
	x.allocsff9f44f9 = allocsff9f44f9
	defer func() {
		if len(x.allocsff9f44f9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMatrix)
		}
	}()
	return refff9f44f9, allocsff9f44f9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix) PassValue() (C.Matrix, *cgoAllocMap) {
	if x.refff9f44f9 != nil {
		return *x.refff9f44f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Matrix) Convert() *matrix {
	if x.refff9f44f9 != nil {
		return (*matrix)(unsafe.Pointer(x.refff9f44f9))
	}
	x.PassRef()
	return (*matrix)(unsafe.Pointer(x.refff9f44f9))
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.Color {
	if x == nil {
		return nil
	}
	return x.refa79767ed
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Color) ResetRef() {
	if x == nil {
		return
	}
	x.refa79767ed = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) FreeRef() {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		return
	}
	if x != nil && x.refa79767ed != nil && x.allocsa79767ed == nil {
		C.free(unsafe.Pointer(x.refa79767ed))
		x.refa79767ed = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeColor(x *Color) {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		// fmt.Printf("Color memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa79767ed.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Color memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		return x.refa79767ed, nil
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.R), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.R = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.G), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.G = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.B), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.B = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.A), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.A = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed
	defer func() {
		if len(x.allocsa79767ed.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeColor)
		}
	}()
	return refa79767ed, allocsa79767ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Color) Convert() *color {
	if x.refa79767ed != nil {
		return (*color)(unsafe.Pointer(x.refa79767ed))
	}
	x.PassRef()
	return (*color)(unsafe.Pointer(x.refa79767ed))
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) Ref() *C.Rectangle {
	if x == nil {
		return nil
	}
	return x.refcee8783a
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Rectangle) ResetRef() {
	if x == nil {
		return
	}
	x.refcee8783a = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rectangle) FreeRef() {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		return
	}
	if x != nil && x.refcee8783a != nil && x.allocscee8783a == nil {
		C.free(unsafe.Pointer(x.refcee8783a))
		x.refcee8783a = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRectangle(x *Rectangle) {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		// fmt.Printf("Rectangle memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocscee8783a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Rectangle memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		return x.refcee8783a, nil
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.Y = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.Width = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.Height = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a
	defer func() {
		if len(x.allocscee8783a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRectangle)
		}
	}()
	return refcee8783a, allocscee8783a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Rectangle) Convert() *rectangle {
	if x.refcee8783a != nil {
		return (*rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.PassRef()
	return (*rectangle)(unsafe.Pointer(x.refcee8783a))
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.Image {
	if x == nil {
		return nil
	}
	return x.ref4fc2b5b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Image) ResetRef() {
	if x == nil {
		return
	}
	x.ref4fc2b5b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) FreeRef() {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
		return
	}
	if x != nil && x.ref4fc2b5b != nil && x.allocs4fc2b5b == nil {
		C.free(unsafe.Pointer(x.ref4fc2b5b))
		x.ref4fc2b5b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeImage(x *Image) {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
		// fmt.Printf("Image memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs4fc2b5b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Image memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		return x.ref4fc2b5b, nil
	}
	mem4fc2b5b := unsafe.Pointer(new(C.Image))
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	// allocs4fc2b5b.Add(mem4fc2b5b)

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)
	x.Data = *new(unsafe.Pointer)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)
	x.Width = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)
	x.Height = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)
	x.Mipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)
	x.Format = *new(int32)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b
	defer func() {
		if len(x.allocs4fc2b5b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeImage)
		}
	}()
	return ref4fc2b5b, allocs4fc2b5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Image) Convert() *image {
	if x.ref4fc2b5b != nil {
		return (*image)(unsafe.Pointer(x.ref4fc2b5b))
	}
	x.PassRef()
	return (*image)(unsafe.Pointer(x.ref4fc2b5b))
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture2D) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Texture2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture2D) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture2D(x *Texture2D) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTexture2DRef(ref unsafe.Pointer) *Texture2D {
	if ref == nil {
		return nil
	}
	obj := new(Texture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture2D) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.Width = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.Height = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.Mipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.Format = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture2D)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture2D) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Texture2D) Convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Texture) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture(x *Texture) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureRef(ref unsafe.Pointer) *Texture {
	if ref == nil {
		return nil
	}
	obj := new(Texture)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.Width = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.Height = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.Mipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.Format = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Texture) Convert() *texture {
	if x.ref3c51a40b != nil {
		return (*texture)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture)(unsafe.Pointer(x.ref3c51a40b))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureCubemap) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *TextureCubemap) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextureCubemap) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTextureCubemap(x *TextureCubemap) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("TextureCubemap memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureCubemapRef(ref unsafe.Pointer) *TextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(TextureCubemap)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureCubemap) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.Width = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.Height = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.Mipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.Format = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTextureCubemap)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureCubemap) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *TextureCubemap) Convert() *textureCubemap {
	if x.ref3c51a40b != nil {
		return (*textureCubemap)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*textureCubemap)(unsafe.Pointer(x.ref3c51a40b))
}

// allocRenderTexture2DMemory allocates memory for type C.RenderTexture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderTexture2DValue = unsafe.Sizeof([1]C.RenderTexture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture2D) Ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *RenderTexture2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref2f94e9e3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderTexture2D) FreeRef() {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		return
	}
	if x != nil && x.ref2f94e9e3 != nil && x.allocs2f94e9e3 == nil {
		C.free(unsafe.Pointer(x.ref2f94e9e3))
		x.ref2f94e9e3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRenderTexture2D(x *RenderTexture2D) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		// fmt.Printf("RenderTexture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RenderTexture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRenderTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTexture2DRef(ref unsafe.Pointer) *RenderTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture2D)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture2D) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		return x.ref2f94e9e3, nil
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.Texture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.Texture = *new(Texture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.Depth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.Depth = *new(Texture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.DepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.DepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	defer func() {
		if len(x.allocs2f94e9e3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRenderTexture2D)
		}
	}()
	return ref2f94e9e3, allocs2f94e9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture2D) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *RenderTexture2D) Convert() *renderTexture2D {
	if x.ref2f94e9e3 != nil {
		return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.PassRef()
	return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
}

// GetTexture returns a reference to C object within a struct
func (s *RenderTexture2D) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetDepth returns a reference to C object within a struct
func (s *RenderTexture2D) GetDepth() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().depth))
	return ret
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture) Ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *RenderTexture) ResetRef() {
	if x == nil {
		return
	}
	x.ref2f94e9e3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderTexture) FreeRef() {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		return
	}
	if x != nil && x.ref2f94e9e3 != nil && x.allocs2f94e9e3 == nil {
		C.free(unsafe.Pointer(x.ref2f94e9e3))
		x.ref2f94e9e3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRenderTexture(x *RenderTexture) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		// fmt.Printf("RenderTexture memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RenderTexture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRenderTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTextureRef(ref unsafe.Pointer) *RenderTexture {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		return x.ref2f94e9e3, nil
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.Texture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.Texture = *new(Texture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.Depth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.Depth = *new(Texture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.DepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.DepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	defer func() {
		if len(x.allocs2f94e9e3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRenderTexture)
		}
	}()
	return ref2f94e9e3, allocs2f94e9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *RenderTexture) Convert() *renderTexture {
	if x.ref2f94e9e3 != nil {
		return (*renderTexture)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.PassRef()
	return (*renderTexture)(unsafe.Pointer(x.ref2f94e9e3))
}

// GetTexture returns a reference to C object within a struct
func (s *RenderTexture) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetDepth returns a reference to C object within a struct
func (s *RenderTexture) GetDepth() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().depth))
	return ret
}

// allocNPatchInfoMemory allocates memory for type C.NPatchInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNPatchInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNPatchInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNPatchInfoValue = unsafe.Sizeof([1]C.NPatchInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *NPatchInfo) Ref() *C.NPatchInfo {
	if x == nil {
		return nil
	}
	return x.ref78104a03
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *NPatchInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref78104a03 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *NPatchInfo) FreeRef() {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
		return
	}
	if x != nil && x.ref78104a03 != nil && x.allocs78104a03 == nil {
		C.free(unsafe.Pointer(x.ref78104a03))
		x.ref78104a03 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeNPatchInfo(x *NPatchInfo) {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
		// fmt.Printf("NPatchInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs78104a03.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.NPatchInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewNPatchInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNPatchInfoRef(ref unsafe.Pointer) *NPatchInfo {
	if ref == nil {
		return nil
	}
	obj := new(NPatchInfo)
	obj.ref78104a03 = (*C.NPatchInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NPatchInfo) PassRef() (*C.NPatchInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78104a03 != nil {
		return x.ref78104a03, nil
	}
	mem78104a03 := unsafe.Pointer(new(C.NPatchInfo))
	ref78104a03 := (*C.NPatchInfo)(mem78104a03)
	allocs78104a03 := new(cgoAllocMap)
	// allocs78104a03.Add(mem78104a03)

	var csourceRec_allocs *cgoAllocMap
	ref78104a03.sourceRec, csourceRec_allocs = x.SourceRec.PassValue()
	allocs78104a03.Borrow(csourceRec_allocs)
	x.SourceRec = *new(Rectangle)

	var cleft_allocs *cgoAllocMap
	ref78104a03.left, cleft_allocs = (C.int)(x.Left), cgoAllocsUnknown
	allocs78104a03.Borrow(cleft_allocs)
	x.Left = *new(int32)

	var ctop_allocs *cgoAllocMap
	ref78104a03.top, ctop_allocs = (C.int)(x.Top), cgoAllocsUnknown
	allocs78104a03.Borrow(ctop_allocs)
	x.Top = *new(int32)

	var cright_allocs *cgoAllocMap
	ref78104a03.right, cright_allocs = (C.int)(x.Right), cgoAllocsUnknown
	allocs78104a03.Borrow(cright_allocs)
	x.Right = *new(int32)

	var cbottom_allocs *cgoAllocMap
	ref78104a03.bottom, cbottom_allocs = (C.int)(x.Bottom), cgoAllocsUnknown
	allocs78104a03.Borrow(cbottom_allocs)
	x.Bottom = *new(int32)

	var c_type_allocs *cgoAllocMap
	ref78104a03._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs78104a03.Borrow(c_type_allocs)
	x.Type = *new(int32)

	x.ref78104a03 = ref78104a03
	x.allocs78104a03 = allocs78104a03
	defer func() {
		if len(x.allocs78104a03.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeNPatchInfo)
		}
	}()
	return ref78104a03, allocs78104a03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NPatchInfo) PassValue() (C.NPatchInfo, *cgoAllocMap) {
	if x.ref78104a03 != nil {
		return *x.ref78104a03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *NPatchInfo) Convert() *nPatchInfo {
	if x.ref78104a03 != nil {
		return (*nPatchInfo)(unsafe.Pointer(x.ref78104a03))
	}
	x.PassRef()
	return (*nPatchInfo)(unsafe.Pointer(x.ref78104a03))
}

// GetSourceRec returns a reference to C object within a struct
func (s *NPatchInfo) GetSourceRec() *Rectangle {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	ret = NewRectangleRef(unsafe.Pointer(&s.Ref().sourceRec))
	return ret
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CharInfo) Ref() *C.CharInfo {
	if x == nil {
		return nil
	}
	return x.ref702c36c0
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *CharInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref702c36c0 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CharInfo) FreeRef() {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
		return
	}
	if x != nil && x.ref702c36c0 != nil && x.allocs702c36c0 == nil {
		C.free(unsafe.Pointer(x.ref702c36c0))
		x.ref702c36c0 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCharInfo(x *CharInfo) {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
		// fmt.Printf("CharInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs702c36c0.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.CharInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCharInfoRef(ref unsafe.Pointer) *CharInfo {
	if ref == nil {
		return nil
	}
	obj := new(CharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CharInfo) PassRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		return x.ref702c36c0, nil
	}
	mem702c36c0 := unsafe.Pointer(new(C.CharInfo))
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	// allocs702c36c0.Add(mem702c36c0)

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.Value), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)
	x.Value = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.OffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)
	x.OffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.OffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)
	x.OffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.AdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)
	x.AdvanceX = *new(int32)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.Image.PassValue()
	allocs702c36c0.Borrow(cimage_allocs)
	x.Image = *new(Image)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0
	defer func() {
		if len(x.allocs702c36c0.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCharInfo)
		}
	}()
	return ref702c36c0, allocs702c36c0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CharInfo) PassValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *CharInfo) Convert() *charInfo {
	if x.ref702c36c0 != nil {
		return (*charInfo)(unsafe.Pointer(x.ref702c36c0))
	}
	x.PassRef()
	return (*charInfo)(unsafe.Pointer(x.ref702c36c0))
}

// GetImage returns a reference to C object within a struct
func (s *CharInfo) GetImage() *Image {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Image
	ret = NewImageRef(unsafe.Pointer(&s.Ref().image))
	return ret
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []CharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Font) Ref() *C.Font {
	if x == nil {
		return nil
	}
	return x.ref70a6a7ec
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Font) ResetRef() {
	if x == nil {
		return
	}
	x.ref70a6a7ec = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Font) FreeRef() {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		return
	}
	if x != nil && x.ref70a6a7ec != nil && x.allocs70a6a7ec == nil {
		C.free(unsafe.Pointer(x.ref70a6a7ec))
		x.ref70a6a7ec = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeFont(x *Font) {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		// fmt.Printf("Font memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs70a6a7ec.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Font memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontRef(ref unsafe.Pointer) *Font {
	if ref == nil {
		return nil
	}
	obj := new(Font)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Font) PassRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		return x.ref70a6a7ec, nil
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.BaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.BaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.CharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.CharsCount = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.Texture.PassValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.Texture = *new(Texture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.Recs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.Recs = *new([]Rectangle)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.Chars)
	allocs70a6a7ec.Borrow(cchars_allocs)
	x.Chars = *new([]CharInfo)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec
	defer func() {
		if len(x.allocs70a6a7ec.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeFont)
		}
	}()
	return ref70a6a7ec, allocs70a6a7ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Font) PassValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Font) Convert() *font {
	if x.ref70a6a7ec != nil {
		return (*font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.PassRef()
	return (*font)(unsafe.Pointer(x.ref70a6a7ec))
}

// GetTexture returns a reference to C object within a struct
func (s *Font) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetRecs returns a reference to C object within a struct
func (s *Font) GetRecs(recsIndex int32) *Rectangle {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	// c struct pointer offset
	ptr0 := s.Ref().recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(recsIndex)*uintptr(sizeOfRectangleValue)))

	ret = NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// GetChars returns a reference to C object within a struct
func (s *Font) GetChars(charsIndex int32) *CharInfo {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *CharInfo
	// c struct pointer offset
	ptr0 := s.Ref().chars
	ptr1 := (*C.CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(charsIndex)*uintptr(sizeOfCharInfoValue)))

	ret = NewCharInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// allocCamera3DMemory allocates memory for type C.Camera3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera3DValue = unsafe.Sizeof([1]C.Camera3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera3D) Ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Camera3D) ResetRef() {
	if x == nil {
		return
	}
	x.ref7b09036 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera3D) FreeRef() {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		return
	}
	if x != nil && x.ref7b09036 != nil && x.allocs7b09036 == nil {
		C.free(unsafe.Pointer(x.ref7b09036))
		x.ref7b09036 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera3D(x *Camera3D) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		// fmt.Printf("Camera3D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7b09036.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera3D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera3DRef(ref unsafe.Pointer) *Camera3D {
	if ref == nil {
		return nil
	}
	obj := new(Camera3D)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera3D) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		return x.ref7b09036, nil
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.Position.PassValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.Position = *new(Vector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.Target.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.Target = *new(Vector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.Up.PassValue()
	allocs7b09036.Borrow(cup_allocs)
	x.Up = *new(Vector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.Fovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.Fovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.Type = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	defer func() {
		if len(x.allocs7b09036.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera3D)
		}
	}()
	return ref7b09036, allocs7b09036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera3D) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Camera3D) Convert() *camera3D {
	if x.ref7b09036 != nil {
		return (*camera3D)(unsafe.Pointer(x.ref7b09036))
	}
	x.PassRef()
	return (*camera3D)(unsafe.Pointer(x.ref7b09036))
}

// GetPosition returns a reference to C object within a struct
func (s *Camera3D) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetTarget returns a reference to C object within a struct
func (s *Camera3D) GetTarget() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().target))
	return ret
}

// GetUp returns a reference to C object within a struct
func (s *Camera3D) GetUp() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().up))
	return ret
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera) Ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Camera) ResetRef() {
	if x == nil {
		return
	}
	x.ref7b09036 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera) FreeRef() {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		return
	}
	if x != nil && x.ref7b09036 != nil && x.allocs7b09036 == nil {
		C.free(unsafe.Pointer(x.ref7b09036))
		x.ref7b09036 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera(x *Camera) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		// fmt.Printf("Camera memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7b09036.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera3D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCameraRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCameraRef(ref unsafe.Pointer) *Camera {
	if ref == nil {
		return nil
	}
	obj := new(Camera)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		return x.ref7b09036, nil
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.Position.PassValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.Position = *new(Vector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.Target.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.Target = *new(Vector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.Up.PassValue()
	allocs7b09036.Borrow(cup_allocs)
	x.Up = *new(Vector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.Fovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.Fovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.Type), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.Type = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	defer func() {
		if len(x.allocs7b09036.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera)
		}
	}()
	return ref7b09036, allocs7b09036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Camera) Convert() *camera {
	if x.ref7b09036 != nil {
		return (*camera)(unsafe.Pointer(x.ref7b09036))
	}
	x.PassRef()
	return (*camera)(unsafe.Pointer(x.ref7b09036))
}

// GetPosition returns a reference to C object within a struct
func (s *Camera) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetTarget returns a reference to C object within a struct
func (s *Camera) GetTarget() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().target))
	return ret
}

// GetUp returns a reference to C object within a struct
func (s *Camera) GetUp() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().up))
	return ret
}

// allocCamera2DMemory allocates memory for type C.Camera2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera2DValue = unsafe.Sizeof([1]C.Camera2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera2D) Ref() *C.Camera2D {
	if x == nil {
		return nil
	}
	return x.ref1eaba177
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Camera2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref1eaba177 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera2D) FreeRef() {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
		return
	}
	if x != nil && x.ref1eaba177 != nil && x.allocs1eaba177 == nil {
		C.free(unsafe.Pointer(x.ref1eaba177))
		x.ref1eaba177 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera2D(x *Camera2D) {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
		// fmt.Printf("Camera2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs1eaba177.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera2DRef(ref unsafe.Pointer) *Camera2D {
	if ref == nil {
		return nil
	}
	obj := new(Camera2D)
	obj.ref1eaba177 = (*C.Camera2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera2D) PassRef() (*C.Camera2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eaba177 != nil {
		return x.ref1eaba177, nil
	}
	mem1eaba177 := unsafe.Pointer(new(C.Camera2D))
	ref1eaba177 := (*C.Camera2D)(mem1eaba177)
	allocs1eaba177 := new(cgoAllocMap)
	// allocs1eaba177.Add(mem1eaba177)

	var coffset_allocs *cgoAllocMap
	ref1eaba177.offset, coffset_allocs = x.Offset.PassValue()
	allocs1eaba177.Borrow(coffset_allocs)
	x.Offset = *new(Vector2)

	var ctarget_allocs *cgoAllocMap
	ref1eaba177.target, ctarget_allocs = x.Target.PassValue()
	allocs1eaba177.Borrow(ctarget_allocs)
	x.Target = *new(Vector2)

	var crotation_allocs *cgoAllocMap
	ref1eaba177.rotation, crotation_allocs = (C.float)(x.Rotation), cgoAllocsUnknown
	allocs1eaba177.Borrow(crotation_allocs)
	x.Rotation = *new(float32)

	var czoom_allocs *cgoAllocMap
	ref1eaba177.zoom, czoom_allocs = (C.float)(x.Zoom), cgoAllocsUnknown
	allocs1eaba177.Borrow(czoom_allocs)
	x.Zoom = *new(float32)

	x.ref1eaba177 = ref1eaba177
	x.allocs1eaba177 = allocs1eaba177
	defer func() {
		if len(x.allocs1eaba177.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera2D)
		}
	}()
	return ref1eaba177, allocs1eaba177

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera2D) PassValue() (C.Camera2D, *cgoAllocMap) {
	if x.ref1eaba177 != nil {
		return *x.ref1eaba177, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Camera2D) Convert() *camera2D {
	if x.ref1eaba177 != nil {
		return (*camera2D)(unsafe.Pointer(x.ref1eaba177))
	}
	x.PassRef()
	return (*camera2D)(unsafe.Pointer(x.ref1eaba177))
}

// GetOffset returns a reference to C object within a struct
func (s *Camera2D) GetOffset() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().offset))
	return ret
}

// GetTarget returns a reference to C object within a struct
func (s *Camera2D) GetTarget() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().target))
	return ret
}

// allocMeshMemory allocates memory for type C.Mesh in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMeshMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMeshValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMeshValue = unsafe.Sizeof([1]C.Mesh{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mesh) Ref() *C.Mesh {
	if x == nil {
		return nil
	}
	return x.ref415d9568
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Mesh) ResetRef() {
	if x == nil {
		return
	}
	x.ref415d9568 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Mesh) FreeRef() {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
		return
	}
	if x != nil && x.ref415d9568 != nil && x.allocs415d9568 == nil {
		C.free(unsafe.Pointer(x.ref415d9568))
		x.ref415d9568 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMesh(x *Mesh) {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
		// fmt.Printf("Mesh memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs415d9568.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Mesh memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMeshRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMeshRef(ref unsafe.Pointer) *Mesh {
	if ref == nil {
		return nil
	}
	obj := new(Mesh)
	obj.ref415d9568 = (*C.Mesh)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mesh) PassRef() (*C.Mesh, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref415d9568 != nil {
		return x.ref415d9568, nil
	}
	mem415d9568 := unsafe.Pointer(new(C.Mesh))
	ref415d9568 := (*C.Mesh)(mem415d9568)
	allocs415d9568 := new(cgoAllocMap)
	// allocs415d9568.Add(mem415d9568)

	var cvertexCount_allocs *cgoAllocMap
	ref415d9568.vertexCount, cvertexCount_allocs = (C.int)(x.VertexCount), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertexCount_allocs)
	x.VertexCount = *new(int32)

	var ctriangleCount_allocs *cgoAllocMap
	ref415d9568.triangleCount, ctriangleCount_allocs = (C.int)(x.TriangleCount), cgoAllocsUnknown
	allocs415d9568.Borrow(ctriangleCount_allocs)
	x.TriangleCount = *new(int32)

	var cvertices_allocs *cgoAllocMap
	ref415d9568.vertices, cvertices_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Vertices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertices_allocs)
	x.Vertices = *new([]float32)

	var ctexcoords_allocs *cgoAllocMap
	ref415d9568.texcoords, ctexcoords_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Texcoords)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctexcoords_allocs)
	x.Texcoords = *new([]float32)

	var ctexcoords2_allocs *cgoAllocMap
	ref415d9568.texcoords2, ctexcoords2_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Texcoords2)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctexcoords2_allocs)
	x.Texcoords2 = *new([]float32)

	var cnormals_allocs *cgoAllocMap
	ref415d9568.normals, cnormals_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Normals)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cnormals_allocs)
	x.Normals = *new([]float32)

	var ctangents_allocs *cgoAllocMap
	ref415d9568.tangents, ctangents_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Tangents)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctangents_allocs)
	x.Tangents = *new([]float32)

	var ccolors_allocs *cgoAllocMap
	ref415d9568.colors, ccolors_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Colors)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ccolors_allocs)
	x.Colors = *new([]byte)

	var cindices_allocs *cgoAllocMap
	ref415d9568.indices, cindices_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Indices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cindices_allocs)
	x.Indices = *new([]uint16)

	var canimVertices_allocs *cgoAllocMap
	ref415d9568.animVertices, canimVertices_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.AnimVertices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(canimVertices_allocs)
	x.AnimVertices = *new([]float32)

	var canimNormals_allocs *cgoAllocMap
	ref415d9568.animNormals, canimNormals_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.AnimNormals)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(canimNormals_allocs)
	x.AnimNormals = *new([]float32)

	var cboneIds_allocs *cgoAllocMap
	ref415d9568.boneIds, cboneIds_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.BoneIds)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cboneIds_allocs)
	x.BoneIds = *new([]int32)

	var cboneWeights_allocs *cgoAllocMap
	ref415d9568.boneWeights, cboneWeights_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.BoneWeights)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cboneWeights_allocs)
	x.BoneWeights = *new([]float32)

	var cvaoId_allocs *cgoAllocMap
	ref415d9568.vaoId, cvaoId_allocs = (C.uint)(x.VaoId), cgoAllocsUnknown
	allocs415d9568.Borrow(cvaoId_allocs)
	x.VaoId = *new(uint32)

	var cvboId_allocs *cgoAllocMap
	ref415d9568.vboId, cvboId_allocs = (*C.uint)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.VboId)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cvboId_allocs)
	x.VboId = *new([]uint32)

	x.ref415d9568 = ref415d9568
	x.allocs415d9568 = allocs415d9568
	defer func() {
		if len(x.allocs415d9568.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMesh)
		}
	}()
	return ref415d9568, allocs415d9568

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mesh) PassValue() (C.Mesh, *cgoAllocMap) {
	if x.ref415d9568 != nil {
		return *x.ref415d9568, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Mesh) Convert() *mesh {
	if x.ref415d9568 != nil {
		return (*mesh)(unsafe.Pointer(x.ref415d9568))
	}
	x.PassRef()
	return (*mesh)(unsafe.Pointer(x.ref415d9568))
}

// GetVertices returns a reference to C object within a struct
func (s *Mesh) GetVertices(verticesCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, verticesCount)
	ptr0 := s.Ref().vertices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetTexcoords returns a reference to C object within a struct
func (s *Mesh) GetTexcoords(texcoordsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, texcoordsCount)
	ptr0 := s.Ref().texcoords
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetTexcoords2 returns a reference to C object within a struct
func (s *Mesh) GetTexcoords2(texcoords2Count int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, texcoords2Count)
	ptr0 := s.Ref().texcoords2
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetNormals returns a reference to C object within a struct
func (s *Mesh) GetNormals(normalsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, normalsCount)
	ptr0 := s.Ref().normals
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetTangents returns a reference to C object within a struct
func (s *Mesh) GetTangents(tangentsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, tangentsCount)
	ptr0 := s.Ref().tangents
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetColors returns a reference to C object within a struct
func (s *Mesh) GetColors(colorsCount int32) []*byte {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*byte

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uchar{})
	ret = make([]*byte, colorsCount)
	ptr0 := s.Ref().colors
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*byte)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetIndices returns a reference to C object within a struct
func (s *Mesh) GetIndices(indicesCount int32) []*uint16 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*uint16

	const sizeOfPlainValue = unsafe.Sizeof([1]C.ushort{})
	ret = make([]*uint16, indicesCount)
	ptr0 := s.Ref().indices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.ushort)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*uint16)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetAnimVertices returns a reference to C object within a struct
func (s *Mesh) GetAnimVertices(animVerticesCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, animVerticesCount)
	ptr0 := s.Ref().animVertices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetAnimNormals returns a reference to C object within a struct
func (s *Mesh) GetAnimNormals(animNormalsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, animNormalsCount)
	ptr0 := s.Ref().animNormals
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetBoneIds returns a reference to C object within a struct
func (s *Mesh) GetBoneIds(boneIdsCount int32) []*int32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, boneIdsCount)
	ptr0 := s.Ref().boneIds
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetBoneWeights returns a reference to C object within a struct
func (s *Mesh) GetBoneWeights(boneWeightsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, boneWeightsCount)
	ptr0 := s.Ref().boneWeights
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetVboId returns a reference to C object within a struct
func (s *Mesh) GetVboId(vboIdCount int32) []*uint32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*uint32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uint{})
	ret = make([]*uint32, vboIdCount)
	ptr0 := s.Ref().vboId
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.uint)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*uint32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocShaderMemory allocates memory for type C.Shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderValue = unsafe.Sizeof([1]C.Shader{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Shader) Ref() *C.Shader {
	if x == nil {
		return nil
	}
	return x.reff85f9b1e
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Shader) ResetRef() {
	if x == nil {
		return
	}
	x.reff85f9b1e = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Shader) FreeRef() {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
		return
	}
	if x != nil && x.reff85f9b1e != nil && x.allocsf85f9b1e == nil {
		C.free(unsafe.Pointer(x.reff85f9b1e))
		x.reff85f9b1e = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeShader(x *Shader) {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
		// fmt.Printf("Shader memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsf85f9b1e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Shader memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewShaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderRef(ref unsafe.Pointer) *Shader {
	if ref == nil {
		return nil
	}
	obj := new(Shader)
	obj.reff85f9b1e = (*C.Shader)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Shader) PassRef() (*C.Shader, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff85f9b1e != nil {
		return x.reff85f9b1e, nil
	}
	memf85f9b1e := unsafe.Pointer(new(C.Shader))
	reff85f9b1e := (*C.Shader)(memf85f9b1e)
	allocsf85f9b1e := new(cgoAllocMap)
	// allocsf85f9b1e.Add(memf85f9b1e)

	var cid_allocs *cgoAllocMap
	reff85f9b1e.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var clocs_allocs *cgoAllocMap
	reff85f9b1e.locs, clocs_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Locs)).Data)), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(clocs_allocs)
	x.Locs = *new([]int32)

	x.reff85f9b1e = reff85f9b1e
	x.allocsf85f9b1e = allocsf85f9b1e
	defer func() {
		if len(x.allocsf85f9b1e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeShader)
		}
	}()
	return reff85f9b1e, allocsf85f9b1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Shader) PassValue() (C.Shader, *cgoAllocMap) {
	if x.reff85f9b1e != nil {
		return *x.reff85f9b1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Shader) Convert() *shader {
	if x.reff85f9b1e != nil {
		return (*shader)(unsafe.Pointer(x.reff85f9b1e))
	}
	x.PassRef()
	return (*shader)(unsafe.Pointer(x.reff85f9b1e))
}

// GetLocs returns a reference to C object within a struct
func (s *Shader) GetLocs(locsCount int32) []*int32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, locsCount)
	ptr0 := s.Ref().locs
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocMaterialMapMemory allocates memory for type C.MaterialMap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialMapValue = unsafe.Sizeof([1]C.MaterialMap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MaterialMap) Ref() *C.MaterialMap {
	if x == nil {
		return nil
	}
	return x.refa8350ad3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *MaterialMap) ResetRef() {
	if x == nil {
		return
	}
	x.refa8350ad3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MaterialMap) FreeRef() {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
		return
	}
	if x != nil && x.refa8350ad3 != nil && x.allocsa8350ad3 == nil {
		C.free(unsafe.Pointer(x.refa8350ad3))
		x.refa8350ad3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMaterialMap(x *MaterialMap) {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
		// fmt.Printf("MaterialMap memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa8350ad3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.MaterialMap memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMaterialMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialMapRef(ref unsafe.Pointer) *MaterialMap {
	if ref == nil {
		return nil
	}
	obj := new(MaterialMap)
	obj.refa8350ad3 = (*C.MaterialMap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MaterialMap) PassRef() (*C.MaterialMap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8350ad3 != nil {
		return x.refa8350ad3, nil
	}
	mema8350ad3 := unsafe.Pointer(new(C.MaterialMap))
	refa8350ad3 := (*C.MaterialMap)(mema8350ad3)
	allocsa8350ad3 := new(cgoAllocMap)
	// allocsa8350ad3.Add(mema8350ad3)

	var ctexture_allocs *cgoAllocMap
	refa8350ad3.texture, ctexture_allocs = x.Texture.PassValue()
	allocsa8350ad3.Borrow(ctexture_allocs)
	x.Texture = *new(Texture2D)

	var ccolor_allocs *cgoAllocMap
	refa8350ad3.color, ccolor_allocs = x.Color.PassValue()
	allocsa8350ad3.Borrow(ccolor_allocs)
	x.Color = *new(Color)

	var cvalue_allocs *cgoAllocMap
	refa8350ad3.value, cvalue_allocs = (C.float)(x.Value), cgoAllocsUnknown
	allocsa8350ad3.Borrow(cvalue_allocs)
	x.Value = *new(float32)

	x.refa8350ad3 = refa8350ad3
	x.allocsa8350ad3 = allocsa8350ad3
	defer func() {
		if len(x.allocsa8350ad3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMaterialMap)
		}
	}()
	return refa8350ad3, allocsa8350ad3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MaterialMap) PassValue() (C.MaterialMap, *cgoAllocMap) {
	if x.refa8350ad3 != nil {
		return *x.refa8350ad3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *MaterialMap) Convert() *materialMap {
	if x.refa8350ad3 != nil {
		return (*materialMap)(unsafe.Pointer(x.refa8350ad3))
	}
	x.PassRef()
	return (*materialMap)(unsafe.Pointer(x.refa8350ad3))
}

// GetTexture returns a reference to C object within a struct
func (s *MaterialMap) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetColor returns a reference to C object within a struct
func (s *MaterialMap) GetColor() *Color {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Color
	ret = NewColorRef(unsafe.Pointer(&s.Ref().color))
	return ret
}

// allocMaterialMemory allocates memory for type C.Material in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialValue = unsafe.Sizeof([1]C.Material{})

// unpackSMaterialMap transforms a sliced Go data structure into plain C format.
func unpackSMaterialMap(x []MaterialMap) (unpacked *C.MaterialMap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.MaterialMap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.MaterialMap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.MaterialMap)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Material) Ref() *C.Material {
	if x == nil {
		return nil
	}
	return x.ref85c817c3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Material) ResetRef() {
	if x == nil {
		return
	}
	x.ref85c817c3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Material) FreeRef() {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
		return
	}
	if x != nil && x.ref85c817c3 != nil && x.allocs85c817c3 == nil {
		C.free(unsafe.Pointer(x.ref85c817c3))
		x.ref85c817c3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMaterial(x *Material) {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
		// fmt.Printf("Material memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs85c817c3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Material memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMaterialRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialRef(ref unsafe.Pointer) *Material {
	if ref == nil {
		return nil
	}
	obj := new(Material)
	obj.ref85c817c3 = (*C.Material)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Material) PassRef() (*C.Material, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c817c3 != nil {
		return x.ref85c817c3, nil
	}
	mem85c817c3 := unsafe.Pointer(new(C.Material))
	ref85c817c3 := (*C.Material)(mem85c817c3)
	allocs85c817c3 := new(cgoAllocMap)
	// allocs85c817c3.Add(mem85c817c3)

	var cshader_allocs *cgoAllocMap
	ref85c817c3.shader, cshader_allocs = x.Shader.PassValue()
	allocs85c817c3.Borrow(cshader_allocs)
	x.Shader = *new(Shader)

	var cmaps_allocs *cgoAllocMap
	ref85c817c3.maps, cmaps_allocs = unpackSMaterialMap(x.Maps)
	allocs85c817c3.Borrow(cmaps_allocs)
	x.Maps = *new([]MaterialMap)

	var cparams_allocs *cgoAllocMap
	ref85c817c3.params, cparams_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.Params)).Data)), cgoAllocsUnknown
	allocs85c817c3.Borrow(cparams_allocs)
	x.Params = *new([]float32)

	x.ref85c817c3 = ref85c817c3
	x.allocs85c817c3 = allocs85c817c3
	defer func() {
		if len(x.allocs85c817c3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMaterial)
		}
	}()
	return ref85c817c3, allocs85c817c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Material) PassValue() (C.Material, *cgoAllocMap) {
	if x.ref85c817c3 != nil {
		return *x.ref85c817c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Material) Convert() *material {
	if x.ref85c817c3 != nil {
		return (*material)(unsafe.Pointer(x.ref85c817c3))
	}
	x.PassRef()
	return (*material)(unsafe.Pointer(x.ref85c817c3))
}

// GetShader returns a reference to C object within a struct
func (s *Material) GetShader() *Shader {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Shader
	ret = NewShaderRef(unsafe.Pointer(&s.Ref().shader))
	return ret
}

// GetMaps returns a reference to C object within a struct
func (s *Material) GetMaps(mapsIndex int32) *MaterialMap {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *MaterialMap
	// c struct pointer offset
	ptr0 := s.Ref().maps
	ptr1 := (*C.MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(mapsIndex)*uintptr(sizeOfMaterialMapValue)))

	ret = NewMaterialMapRef(unsafe.Pointer(ptr1))
	return ret
}

// GetParams returns a reference to C object within a struct
func (s *Material) GetParams(paramsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, paramsCount)
	ptr0 := s.Ref().params
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocTransformMemory allocates memory for type C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransformValue = unsafe.Sizeof([1]C.Transform{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Transform) Ref() *C.Transform {
	if x == nil {
		return nil
	}
	return x.reff543030e
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Transform) ResetRef() {
	if x == nil {
		return
	}
	x.reff543030e = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Transform) FreeRef() {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
		return
	}
	if x != nil && x.reff543030e != nil && x.allocsf543030e == nil {
		C.free(unsafe.Pointer(x.reff543030e))
		x.reff543030e = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTransform(x *Transform) {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
		// fmt.Printf("Transform memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsf543030e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Transform memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTransformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransformRef(ref unsafe.Pointer) *Transform {
	if ref == nil {
		return nil
	}
	obj := new(Transform)
	obj.reff543030e = (*C.Transform)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Transform) PassRef() (*C.Transform, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff543030e != nil {
		return x.reff543030e, nil
	}
	memf543030e := unsafe.Pointer(new(C.Transform))
	reff543030e := (*C.Transform)(memf543030e)
	allocsf543030e := new(cgoAllocMap)
	// allocsf543030e.Add(memf543030e)

	var ctranslation_allocs *cgoAllocMap
	reff543030e.translation, ctranslation_allocs = x.Translation.PassValue()
	allocsf543030e.Borrow(ctranslation_allocs)
	x.Translation = *new(Vector3)

	var crotation_allocs *cgoAllocMap
	reff543030e.rotation, crotation_allocs = x.Rotation.PassValue()
	allocsf543030e.Borrow(crotation_allocs)
	x.Rotation = *new(Quaternion)

	var cscale_allocs *cgoAllocMap
	reff543030e.scale, cscale_allocs = x.Scale.PassValue()
	allocsf543030e.Borrow(cscale_allocs)
	x.Scale = *new(Vector3)

	x.reff543030e = reff543030e
	x.allocsf543030e = allocsf543030e
	defer func() {
		if len(x.allocsf543030e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTransform)
		}
	}()
	return reff543030e, allocsf543030e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Transform) PassValue() (C.Transform, *cgoAllocMap) {
	if x.reff543030e != nil {
		return *x.reff543030e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Transform) Convert() *transform {
	if x.reff543030e != nil {
		return (*transform)(unsafe.Pointer(x.reff543030e))
	}
	x.PassRef()
	return (*transform)(unsafe.Pointer(x.reff543030e))
}

// GetTranslation returns a reference to C object within a struct
func (s *Transform) GetTranslation() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().translation))
	return ret
}

// GetRotation returns a reference to C object within a struct
func (s *Transform) GetRotation() *Quaternion {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Quaternion
	ret = NewQuaternionRef(unsafe.Pointer(&s.Ref().rotation))
	return ret
}

// GetScale returns a reference to C object within a struct
func (s *Transform) GetScale() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().scale))
	return ret
}

// allocBoneInfoMemory allocates memory for type C.BoneInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoneInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoneInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoneInfoValue = unsafe.Sizeof([1]C.BoneInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoneInfo) Ref() *C.BoneInfo {
	if x == nil {
		return nil
	}
	return x.ref5ab7f197
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *BoneInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref5ab7f197 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BoneInfo) FreeRef() {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
		return
	}
	if x != nil && x.ref5ab7f197 != nil && x.allocs5ab7f197 == nil {
		C.free(unsafe.Pointer(x.ref5ab7f197))
		x.ref5ab7f197 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeBoneInfo(x *BoneInfo) {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
		// fmt.Printf("BoneInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ab7f197.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.BoneInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewBoneInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoneInfoRef(ref unsafe.Pointer) *BoneInfo {
	if ref == nil {
		return nil
	}
	obj := new(BoneInfo)
	obj.ref5ab7f197 = (*C.BoneInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoneInfo) PassRef() (*C.BoneInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ab7f197 != nil {
		return x.ref5ab7f197, nil
	}
	mem5ab7f197 := unsafe.Pointer(new(C.BoneInfo))
	ref5ab7f197 := (*C.BoneInfo)(mem5ab7f197)
	allocs5ab7f197 := new(cgoAllocMap)
	// allocs5ab7f197.Add(mem5ab7f197)

	var cname_allocs *cgoAllocMap
	ref5ab7f197.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.Name)), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cname_allocs)
	x.Name = *new([32]byte)

	var cparent_allocs *cgoAllocMap
	ref5ab7f197.parent, cparent_allocs = (C.int)(x.Parent), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cparent_allocs)
	x.Parent = *new(int32)

	x.ref5ab7f197 = ref5ab7f197
	x.allocs5ab7f197 = allocs5ab7f197
	defer func() {
		if len(x.allocs5ab7f197.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeBoneInfo)
		}
	}()
	return ref5ab7f197, allocs5ab7f197

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoneInfo) PassValue() (C.BoneInfo, *cgoAllocMap) {
	if x.ref5ab7f197 != nil {
		return *x.ref5ab7f197, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *BoneInfo) Convert() *boneInfo {
	if x.ref5ab7f197 != nil {
		return (*boneInfo)(unsafe.Pointer(x.ref5ab7f197))
	}
	x.PassRef()
	return (*boneInfo)(unsafe.Pointer(x.ref5ab7f197))
}

// allocModelMemory allocates memory for type C.Model in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelValue = unsafe.Sizeof([1]C.Model{})

// unpackSMesh transforms a sliced Go data structure into plain C format.
func unpackSMesh(x []Mesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackSMaterial transforms a sliced Go data structure into plain C format.
func unpackSMaterial(x []Material) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackSBoneInfo transforms a sliced Go data structure into plain C format.
func unpackSBoneInfo(x []BoneInfo) (unpacked *C.BoneInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.BoneInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBoneInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BoneInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BoneInfo)(h.Data)
	return
}

// unpackSTransform transforms a sliced Go data structure into plain C format.
func unpackSTransform(x []Transform) (unpacked *C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Transform)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Model) Ref() *C.Model {
	if x == nil {
		return nil
	}
	return x.ref16545ddd
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Model) ResetRef() {
	if x == nil {
		return
	}
	x.ref16545ddd = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Model) FreeRef() {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
		return
	}
	if x != nil && x.ref16545ddd != nil && x.allocs16545ddd == nil {
		C.free(unsafe.Pointer(x.ref16545ddd))
		x.ref16545ddd = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeModel(x *Model) {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
		// fmt.Printf("Model memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs16545ddd.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Model memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelRef(ref unsafe.Pointer) *Model {
	if ref == nil {
		return nil
	}
	obj := new(Model)
	obj.ref16545ddd = (*C.Model)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Model) PassRef() (*C.Model, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16545ddd != nil {
		return x.ref16545ddd, nil
	}
	mem16545ddd := unsafe.Pointer(new(C.Model))
	ref16545ddd := (*C.Model)(mem16545ddd)
	allocs16545ddd := new(cgoAllocMap)
	// allocs16545ddd.Add(mem16545ddd)

	var ctransform_allocs *cgoAllocMap
	ref16545ddd.transform, ctransform_allocs = x.Transform.PassValue()
	allocs16545ddd.Borrow(ctransform_allocs)
	x.Transform = *new(Matrix)

	var cmeshCount_allocs *cgoAllocMap
	ref16545ddd.meshCount, cmeshCount_allocs = (C.int)(x.MeshCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshCount_allocs)
	x.MeshCount = *new(int32)

	var cmeshes_allocs *cgoAllocMap
	ref16545ddd.meshes, cmeshes_allocs = unpackSMesh(x.Meshes)
	allocs16545ddd.Borrow(cmeshes_allocs)
	x.Meshes = *new([]Mesh)

	var cmaterialCount_allocs *cgoAllocMap
	ref16545ddd.materialCount, cmaterialCount_allocs = (C.int)(x.MaterialCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmaterialCount_allocs)
	x.MaterialCount = *new(int32)

	var cmaterials_allocs *cgoAllocMap
	ref16545ddd.materials, cmaterials_allocs = unpackSMaterial(x.Materials)
	allocs16545ddd.Borrow(cmaterials_allocs)
	x.Materials = *new([]Material)

	var cmeshMaterial_allocs *cgoAllocMap
	ref16545ddd.meshMaterial, cmeshMaterial_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.MeshMaterial)).Data)), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshMaterial_allocs)
	x.MeshMaterial = *new([]int32)

	var cboneCount_allocs *cgoAllocMap
	ref16545ddd.boneCount, cboneCount_allocs = (C.int)(x.BoneCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cboneCount_allocs)
	x.BoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref16545ddd.bones, cbones_allocs = unpackSBoneInfo(x.Bones)
	allocs16545ddd.Borrow(cbones_allocs)
	x.Bones = *new([]BoneInfo)

	var cbindPose_allocs *cgoAllocMap
	ref16545ddd.bindPose, cbindPose_allocs = unpackSTransform(x.BindPose)
	allocs16545ddd.Borrow(cbindPose_allocs)
	x.BindPose = *new([]Transform)

	x.ref16545ddd = ref16545ddd
	x.allocs16545ddd = allocs16545ddd
	defer func() {
		if len(x.allocs16545ddd.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeModel)
		}
	}()
	return ref16545ddd, allocs16545ddd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Model) PassValue() (C.Model, *cgoAllocMap) {
	if x.ref16545ddd != nil {
		return *x.ref16545ddd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Model) Convert() *model {
	if x.ref16545ddd != nil {
		return (*model)(unsafe.Pointer(x.ref16545ddd))
	}
	x.PassRef()
	return (*model)(unsafe.Pointer(x.ref16545ddd))
}

// GetTransform returns a reference to C object within a struct
func (s *Model) GetTransform() *Matrix {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Matrix
	ret = NewMatrixRef(unsafe.Pointer(&s.Ref().transform))
	return ret
}

// GetMeshes returns a reference to C object within a struct
func (s *Model) GetMeshes(meshesIndex int32) *Mesh {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Mesh
	// c struct pointer offset
	ptr0 := s.Ref().meshes
	ptr1 := (*C.Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(meshesIndex)*uintptr(sizeOfMeshValue)))

	ret = NewMeshRef(unsafe.Pointer(ptr1))
	return ret
}

// GetMaterials returns a reference to C object within a struct
func (s *Model) GetMaterials(materialsIndex int32) *Material {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Material
	// c struct pointer offset
	ptr0 := s.Ref().materials
	ptr1 := (*C.Material)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(materialsIndex)*uintptr(sizeOfMaterialValue)))

	ret = NewMaterialRef(unsafe.Pointer(ptr1))
	return ret
}

// GetMeshMaterial returns a reference to C object within a struct
func (s *Model) GetMeshMaterial(meshMaterialCount int32) []*int32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, meshMaterialCount)
	ptr0 := s.Ref().meshMaterial
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetBones returns a reference to C object within a struct
func (s *Model) GetBones(bonesIndex int32) *BoneInfo {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *BoneInfo
	// c struct pointer offset
	ptr0 := s.Ref().bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bonesIndex)*uintptr(sizeOfBoneInfoValue)))

	ret = NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// GetBindPose returns a reference to C object within a struct
func (s *Model) GetBindPose(bindPoseIndex int32) *Transform {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Transform
	// c struct pointer offset
	ptr0 := s.Ref().bindPose
	ptr1 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bindPoseIndex)*uintptr(sizeOfTransformValue)))

	ret = NewTransformRef(unsafe.Pointer(ptr1))
	return ret
}

// allocModelAnimationMemory allocates memory for type C.ModelAnimation in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelAnimationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelAnimationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelAnimationValue = unsafe.Sizeof([1]C.ModelAnimation{})

// allocPTransformMemory allocates memory for type *C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTransformValue = unsafe.Sizeof([1]*C.Transform{})

// unpackSSTransform transforms a sliced Go data structure into plain C format.
func unpackSSTransform(x [][]Transform) (unpacked **C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTransformMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Transform)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Transform)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Transform)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ModelAnimation) Ref() *C.ModelAnimation {
	if x == nil {
		return nil
	}
	return x.ref26dd6a24
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *ModelAnimation) ResetRef() {
	if x == nil {
		return
	}
	x.ref26dd6a24 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ModelAnimation) FreeRef() {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
		return
	}
	if x != nil && x.ref26dd6a24 != nil && x.allocs26dd6a24 == nil {
		C.free(unsafe.Pointer(x.ref26dd6a24))
		x.ref26dd6a24 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeModelAnimation(x *ModelAnimation) {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
		// fmt.Printf("ModelAnimation memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs26dd6a24.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.ModelAnimation memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewModelAnimationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelAnimationRef(ref unsafe.Pointer) *ModelAnimation {
	if ref == nil {
		return nil
	}
	obj := new(ModelAnimation)
	obj.ref26dd6a24 = (*C.ModelAnimation)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ModelAnimation) PassRef() (*C.ModelAnimation, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26dd6a24 != nil {
		return x.ref26dd6a24, nil
	}
	mem26dd6a24 := unsafe.Pointer(new(C.ModelAnimation))
	ref26dd6a24 := (*C.ModelAnimation)(mem26dd6a24)
	allocs26dd6a24 := new(cgoAllocMap)
	// allocs26dd6a24.Add(mem26dd6a24)

	var cboneCount_allocs *cgoAllocMap
	ref26dd6a24.boneCount, cboneCount_allocs = (C.int)(x.BoneCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cboneCount_allocs)
	x.BoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref26dd6a24.bones, cbones_allocs = unpackSBoneInfo(x.Bones)
	allocs26dd6a24.Borrow(cbones_allocs)
	x.Bones = *new([]BoneInfo)

	var cframeCount_allocs *cgoAllocMap
	ref26dd6a24.frameCount, cframeCount_allocs = (C.int)(x.FrameCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cframeCount_allocs)
	x.FrameCount = *new(int32)

	var cframePoses_allocs *cgoAllocMap
	ref26dd6a24.framePoses, cframePoses_allocs = unpackSSTransform(x.FramePoses)
	allocs26dd6a24.Borrow(cframePoses_allocs)
	x.FramePoses = *new([][]Transform)

	x.ref26dd6a24 = ref26dd6a24
	x.allocs26dd6a24 = allocs26dd6a24
	defer func() {
		if len(x.allocs26dd6a24.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeModelAnimation)
		}
	}()
	return ref26dd6a24, allocs26dd6a24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ModelAnimation) PassValue() (C.ModelAnimation, *cgoAllocMap) {
	if x.ref26dd6a24 != nil {
		return *x.ref26dd6a24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *ModelAnimation) Convert() *modelAnimation {
	if x.ref26dd6a24 != nil {
		return (*modelAnimation)(unsafe.Pointer(x.ref26dd6a24))
	}
	x.PassRef()
	return (*modelAnimation)(unsafe.Pointer(x.ref26dd6a24))
}

// GetBones returns a reference to C object within a struct
func (s *ModelAnimation) GetBones(bonesIndex int32) *BoneInfo {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *BoneInfo
	// c struct pointer offset
	ptr0 := s.Ref().bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bonesIndex)*uintptr(sizeOfBoneInfoValue)))

	ret = NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// GetFramePoses returns a reference to C object within a struct
func (s *ModelAnimation) GetFramePoses(framePosesRow int32, framePosesColumn int32) *Transform {
	if s.Ref() == nil {
		s.PassRef()
	}

	row, column := framePosesRow, framePosesColumn
	var ret *Transform
	ptr0 := s.Ref().framePoses
	ptr1 := (**C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(row)*uintptr(sizeOfPtr)))
	ptr2 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(*ptr1)) + uintptr(column)*uintptr(sizeOfTransformValue)))
	ret = NewTransformRef(unsafe.Pointer(ptr2))

	return ret
}

// allocRayMemory allocates memory for type C.Ray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayValue = unsafe.Sizeof([1]C.Ray{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Ray) Ref() *C.Ray {
	if x == nil {
		return nil
	}
	return x.refc546b0b2
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Ray) ResetRef() {
	if x == nil {
		return
	}
	x.refc546b0b2 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Ray) FreeRef() {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
		return
	}
	if x != nil && x.refc546b0b2 != nil && x.allocsc546b0b2 == nil {
		C.free(unsafe.Pointer(x.refc546b0b2))
		x.refc546b0b2 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRay(x *Ray) {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
		// fmt.Printf("Ray memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc546b0b2.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Ray memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayRef(ref unsafe.Pointer) *Ray {
	if ref == nil {
		return nil
	}
	obj := new(Ray)
	obj.refc546b0b2 = (*C.Ray)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Ray) PassRef() (*C.Ray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc546b0b2 != nil {
		return x.refc546b0b2, nil
	}
	memc546b0b2 := unsafe.Pointer(new(C.Ray))
	refc546b0b2 := (*C.Ray)(memc546b0b2)
	allocsc546b0b2 := new(cgoAllocMap)
	// allocsc546b0b2.Add(memc546b0b2)

	var cposition_allocs *cgoAllocMap
	refc546b0b2.position, cposition_allocs = x.Position.PassValue()
	allocsc546b0b2.Borrow(cposition_allocs)
	x.Position = *new(Vector3)

	var cdirection_allocs *cgoAllocMap
	refc546b0b2.direction, cdirection_allocs = x.Direction.PassValue()
	allocsc546b0b2.Borrow(cdirection_allocs)
	x.Direction = *new(Vector3)

	x.refc546b0b2 = refc546b0b2
	x.allocsc546b0b2 = allocsc546b0b2
	defer func() {
		if len(x.allocsc546b0b2.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRay)
		}
	}()
	return refc546b0b2, allocsc546b0b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Ray) PassValue() (C.Ray, *cgoAllocMap) {
	if x.refc546b0b2 != nil {
		return *x.refc546b0b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Ray) Convert() *ray {
	if x.refc546b0b2 != nil {
		return (*ray)(unsafe.Pointer(x.refc546b0b2))
	}
	x.PassRef()
	return (*ray)(unsafe.Pointer(x.refc546b0b2))
}

// GetPosition returns a reference to C object within a struct
func (s *Ray) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetDirection returns a reference to C object within a struct
func (s *Ray) GetDirection() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().direction))
	return ret
}

// allocRayHitInfoMemory allocates memory for type C.RayHitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayHitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayHitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayHitInfoValue = unsafe.Sizeof([1]C.RayHitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayHitInfo) Ref() *C.RayHitInfo {
	if x == nil {
		return nil
	}
	return x.refb8de43a9
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *RayHitInfo) ResetRef() {
	if x == nil {
		return
	}
	x.refb8de43a9 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayHitInfo) FreeRef() {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
		return
	}
	if x != nil && x.refb8de43a9 != nil && x.allocsb8de43a9 == nil {
		C.free(unsafe.Pointer(x.refb8de43a9))
		x.refb8de43a9 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRayHitInfo(x *RayHitInfo) {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
		// fmt.Printf("RayHitInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsb8de43a9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RayHitInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRayHitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayHitInfoRef(ref unsafe.Pointer) *RayHitInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayHitInfo)
	obj.refb8de43a9 = (*C.RayHitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayHitInfo) PassRef() (*C.RayHitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8de43a9 != nil {
		return x.refb8de43a9, nil
	}
	memb8de43a9 := unsafe.Pointer(new(C.RayHitInfo))
	refb8de43a9 := (*C.RayHitInfo)(memb8de43a9)
	allocsb8de43a9 := new(cgoAllocMap)
	// allocsb8de43a9.Add(memb8de43a9)

	var chit_allocs *cgoAllocMap
	refb8de43a9.hit, chit_allocs = (C._Bool)(x.Hit), cgoAllocsUnknown
	allocsb8de43a9.Borrow(chit_allocs)
	x.Hit = *new(bool)

	var cdistance_allocs *cgoAllocMap
	refb8de43a9.distance, cdistance_allocs = (C.float)(x.Distance), cgoAllocsUnknown
	allocsb8de43a9.Borrow(cdistance_allocs)
	x.Distance = *new(float32)

	var cposition_allocs *cgoAllocMap
	refb8de43a9.position, cposition_allocs = x.Position.PassValue()
	allocsb8de43a9.Borrow(cposition_allocs)
	x.Position = *new(Vector3)

	var cnormal_allocs *cgoAllocMap
	refb8de43a9.normal, cnormal_allocs = x.Normal.PassValue()
	allocsb8de43a9.Borrow(cnormal_allocs)
	x.Normal = *new(Vector3)

	x.refb8de43a9 = refb8de43a9
	x.allocsb8de43a9 = allocsb8de43a9
	defer func() {
		if len(x.allocsb8de43a9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRayHitInfo)
		}
	}()
	return refb8de43a9, allocsb8de43a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayHitInfo) PassValue() (C.RayHitInfo, *cgoAllocMap) {
	if x.refb8de43a9 != nil {
		return *x.refb8de43a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *RayHitInfo) Convert() *rayHitInfo {
	if x.refb8de43a9 != nil {
		return (*rayHitInfo)(unsafe.Pointer(x.refb8de43a9))
	}
	x.PassRef()
	return (*rayHitInfo)(unsafe.Pointer(x.refb8de43a9))
}

// GetPosition returns a reference to C object within a struct
func (s *RayHitInfo) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetNormal returns a reference to C object within a struct
func (s *RayHitInfo) GetNormal() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().normal))
	return ret
}

// allocBoundingBoxMemory allocates memory for type C.BoundingBox in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoundingBoxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoundingBoxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoundingBoxValue = unsafe.Sizeof([1]C.BoundingBox{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoundingBox) Ref() *C.BoundingBox {
	if x == nil {
		return nil
	}
	return x.refa54e9d16
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *BoundingBox) ResetRef() {
	if x == nil {
		return
	}
	x.refa54e9d16 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BoundingBox) FreeRef() {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
		return
	}
	if x != nil && x.refa54e9d16 != nil && x.allocsa54e9d16 == nil {
		C.free(unsafe.Pointer(x.refa54e9d16))
		x.refa54e9d16 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeBoundingBox(x *BoundingBox) {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
		// fmt.Printf("BoundingBox memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa54e9d16.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.BoundingBox memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewBoundingBoxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoundingBoxRef(ref unsafe.Pointer) *BoundingBox {
	if ref == nil {
		return nil
	}
	obj := new(BoundingBox)
	obj.refa54e9d16 = (*C.BoundingBox)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoundingBox) PassRef() (*C.BoundingBox, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54e9d16 != nil {
		return x.refa54e9d16, nil
	}
	mema54e9d16 := unsafe.Pointer(new(C.BoundingBox))
	refa54e9d16 := (*C.BoundingBox)(mema54e9d16)
	allocsa54e9d16 := new(cgoAllocMap)
	// allocsa54e9d16.Add(mema54e9d16)

	var cmin_allocs *cgoAllocMap
	refa54e9d16.min, cmin_allocs = x.Min.PassValue()
	allocsa54e9d16.Borrow(cmin_allocs)
	x.Min = *new(Vector3)

	var cmax_allocs *cgoAllocMap
	refa54e9d16.max, cmax_allocs = x.Max.PassValue()
	allocsa54e9d16.Borrow(cmax_allocs)
	x.Max = *new(Vector3)

	x.refa54e9d16 = refa54e9d16
	x.allocsa54e9d16 = allocsa54e9d16
	defer func() {
		if len(x.allocsa54e9d16.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeBoundingBox)
		}
	}()
	return refa54e9d16, allocsa54e9d16

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoundingBox) PassValue() (C.BoundingBox, *cgoAllocMap) {
	if x.refa54e9d16 != nil {
		return *x.refa54e9d16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *BoundingBox) Convert() *boundingBox {
	if x.refa54e9d16 != nil {
		return (*boundingBox)(unsafe.Pointer(x.refa54e9d16))
	}
	x.PassRef()
	return (*boundingBox)(unsafe.Pointer(x.refa54e9d16))
}

// GetMin returns a reference to C object within a struct
func (s *BoundingBox) GetMin() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().min))
	return ret
}

// GetMax returns a reference to C object within a struct
func (s *BoundingBox) GetMax() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().max))
	return ret
}

// allocWaveMemory allocates memory for type C.Wave in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWaveValue = unsafe.Sizeof([1]C.Wave{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Wave) Ref() *C.Wave {
	if x == nil {
		return nil
	}
	return x.ref7a3602b7
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Wave) ResetRef() {
	if x == nil {
		return
	}
	x.ref7a3602b7 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Wave) FreeRef() {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
		return
	}
	if x != nil && x.ref7a3602b7 != nil && x.allocs7a3602b7 == nil {
		C.free(unsafe.Pointer(x.ref7a3602b7))
		x.ref7a3602b7 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeWave(x *Wave) {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
		// fmt.Printf("Wave memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7a3602b7.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Wave memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewWaveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWaveRef(ref unsafe.Pointer) *Wave {
	if ref == nil {
		return nil
	}
	obj := new(Wave)
	obj.ref7a3602b7 = (*C.Wave)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Wave) PassRef() (*C.Wave, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a3602b7 != nil {
		return x.ref7a3602b7, nil
	}
	mem7a3602b7 := unsafe.Pointer(new(C.Wave))
	ref7a3602b7 := (*C.Wave)(mem7a3602b7)
	allocs7a3602b7 := new(cgoAllocMap)
	// allocs7a3602b7.Add(mem7a3602b7)

	var csampleCount_allocs *cgoAllocMap
	ref7a3602b7.sampleCount, csampleCount_allocs = (C.uint)(x.SampleCount), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleCount_allocs)
	x.SampleCount = *new(uint32)

	var csampleRate_allocs *cgoAllocMap
	ref7a3602b7.sampleRate, csampleRate_allocs = (C.uint)(x.SampleRate), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleRate_allocs)
	x.SampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref7a3602b7.sampleSize, csampleSize_allocs = (C.uint)(x.SampleSize), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleSize_allocs)
	x.SampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref7a3602b7.channels, cchannels_allocs = (C.uint)(x.Channels), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cchannels_allocs)
	x.Channels = *new(uint32)

	var cdata_allocs *cgoAllocMap
	ref7a3602b7.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.Data)), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cdata_allocs)
	x.Data = *new(unsafe.Pointer)

	x.ref7a3602b7 = ref7a3602b7
	x.allocs7a3602b7 = allocs7a3602b7
	defer func() {
		if len(x.allocs7a3602b7.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeWave)
		}
	}()
	return ref7a3602b7, allocs7a3602b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Wave) PassValue() (C.Wave, *cgoAllocMap) {
	if x.ref7a3602b7 != nil {
		return *x.ref7a3602b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Wave) Convert() *wave {
	if x.ref7a3602b7 != nil {
		return (*wave)(unsafe.Pointer(x.ref7a3602b7))
	}
	x.PassRef()
	return (*wave)(unsafe.Pointer(x.ref7a3602b7))
}

// allocAudioStreamMemory allocates memory for type C.AudioStream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAudioStreamValue = unsafe.Sizeof([1]C.AudioStream{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioStream) Ref() *C.AudioStream {
	if x == nil {
		return nil
	}
	return x.ref997374a2
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *AudioStream) ResetRef() {
	if x == nil {
		return
	}
	x.ref997374a2 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioStream) FreeRef() {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
		return
	}
	if x != nil && x.ref997374a2 != nil && x.allocs997374a2 == nil {
		C.free(unsafe.Pointer(x.ref997374a2))
		x.ref997374a2 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeAudioStream(x *AudioStream) {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
		// fmt.Printf("AudioStream memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs997374a2.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.AudioStream memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewAudioStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioStreamRef(ref unsafe.Pointer) *AudioStream {
	if ref == nil {
		return nil
	}
	obj := new(AudioStream)
	obj.ref997374a2 = (*C.AudioStream)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioStream) PassRef() (*C.AudioStream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref997374a2 != nil {
		return x.ref997374a2, nil
	}
	mem997374a2 := unsafe.Pointer(new(C.AudioStream))
	ref997374a2 := (*C.AudioStream)(mem997374a2)
	allocs997374a2 := new(cgoAllocMap)
	// allocs997374a2.Add(mem997374a2)

	var csampleRate_allocs *cgoAllocMap
	ref997374a2.sampleRate, csampleRate_allocs = (C.uint)(x.SampleRate), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleRate_allocs)
	x.SampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref997374a2.sampleSize, csampleSize_allocs = (C.uint)(x.SampleSize), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleSize_allocs)
	x.SampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref997374a2.channels, cchannels_allocs = (C.uint)(x.Channels), cgoAllocsUnknown
	allocs997374a2.Borrow(cchannels_allocs)
	x.Channels = *new(uint32)

	x.ref997374a2 = ref997374a2
	x.allocs997374a2 = allocs997374a2
	defer func() {
		if len(x.allocs997374a2.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeAudioStream)
		}
	}()
	return ref997374a2, allocs997374a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioStream) PassValue() (C.AudioStream, *cgoAllocMap) {
	if x.ref997374a2 != nil {
		return *x.ref997374a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *AudioStream) Convert() *audioStream {
	if x.ref997374a2 != nil {
		return (*audioStream)(unsafe.Pointer(x.ref997374a2))
	}
	x.PassRef()
	return (*audioStream)(unsafe.Pointer(x.ref997374a2))
}

// allocSoundMemory allocates memory for type C.Sound in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSoundMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSoundValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSoundValue = unsafe.Sizeof([1]C.Sound{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sound) Ref() *C.Sound {
	if x == nil {
		return nil
	}
	return x.ref394fec80
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Sound) ResetRef() {
	if x == nil {
		return
	}
	x.ref394fec80 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Sound) FreeRef() {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
		return
	}
	if x != nil && x.ref394fec80 != nil && x.allocs394fec80 == nil {
		C.free(unsafe.Pointer(x.ref394fec80))
		x.ref394fec80 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeSound(x *Sound) {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
		// fmt.Printf("Sound memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs394fec80.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Sound memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewSoundRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSoundRef(ref unsafe.Pointer) *Sound {
	if ref == nil {
		return nil
	}
	obj := new(Sound)
	obj.ref394fec80 = (*C.Sound)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sound) PassRef() (*C.Sound, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394fec80 != nil {
		return x.ref394fec80, nil
	}
	mem394fec80 := unsafe.Pointer(new(C.Sound))
	ref394fec80 := (*C.Sound)(mem394fec80)
	allocs394fec80 := new(cgoAllocMap)
	// allocs394fec80.Add(mem394fec80)

	var csampleCount_allocs *cgoAllocMap
	ref394fec80.sampleCount, csampleCount_allocs = (C.uint)(x.SampleCount), cgoAllocsUnknown
	allocs394fec80.Borrow(csampleCount_allocs)
	x.SampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	ref394fec80.stream, cstream_allocs = x.Stream.PassValue()
	allocs394fec80.Borrow(cstream_allocs)
	x.Stream = *new(AudioStream)

	x.ref394fec80 = ref394fec80
	x.allocs394fec80 = allocs394fec80
	defer func() {
		if len(x.allocs394fec80.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeSound)
		}
	}()
	return ref394fec80, allocs394fec80

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sound) PassValue() (C.Sound, *cgoAllocMap) {
	if x.ref394fec80 != nil {
		return *x.ref394fec80, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Sound) Convert() *sound {
	if x.ref394fec80 != nil {
		return (*sound)(unsafe.Pointer(x.ref394fec80))
	}
	x.PassRef()
	return (*sound)(unsafe.Pointer(x.ref394fec80))
}

// GetStream returns a reference to C object within a struct
func (s *Sound) GetStream() *AudioStream {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *AudioStream
	ret = NewAudioStreamRef(unsafe.Pointer(&s.Ref().stream))
	return ret
}

// allocMusicMemory allocates memory for type C.Music in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMusicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMusicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMusicValue = unsafe.Sizeof([1]C.Music{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Music) Ref() *C.Music {
	if x == nil {
		return nil
	}
	return x.refc930d4e
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Music) ResetRef() {
	if x == nil {
		return
	}
	x.refc930d4e = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Music) FreeRef() {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
		return
	}
	if x != nil && x.refc930d4e != nil && x.allocsc930d4e == nil {
		C.free(unsafe.Pointer(x.refc930d4e))
		x.refc930d4e = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMusic(x *Music) {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
		// fmt.Printf("Music memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc930d4e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Music memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMusicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMusicRef(ref unsafe.Pointer) *Music {
	if ref == nil {
		return nil
	}
	obj := new(Music)
	obj.refc930d4e = (*C.Music)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Music) PassRef() (*C.Music, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc930d4e != nil {
		return x.refc930d4e, nil
	}
	memc930d4e := unsafe.Pointer(new(C.Music))
	refc930d4e := (*C.Music)(memc930d4e)
	allocsc930d4e := new(cgoAllocMap)
	// allocsc930d4e.Add(memc930d4e)

	var cctxType_allocs *cgoAllocMap
	refc930d4e.ctxType, cctxType_allocs = (C.int)(x.CtxType), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxType_allocs)
	x.CtxType = *new(int32)

	var cctxData_allocs *cgoAllocMap
	refc930d4e.ctxData, cctxData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.CtxData)), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxData_allocs)
	x.CtxData = *new(unsafe.Pointer)

	var clooping_allocs *cgoAllocMap
	refc930d4e.looping, clooping_allocs = (C._Bool)(x.Looping), cgoAllocsUnknown
	allocsc930d4e.Borrow(clooping_allocs)
	x.Looping = *new(bool)

	var csampleCount_allocs *cgoAllocMap
	refc930d4e.sampleCount, csampleCount_allocs = (C.uint)(x.SampleCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(csampleCount_allocs)
	x.SampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	refc930d4e.stream, cstream_allocs = x.Stream.PassValue()
	allocsc930d4e.Borrow(cstream_allocs)
	x.Stream = *new(AudioStream)

	x.refc930d4e = refc930d4e
	x.allocsc930d4e = allocsc930d4e
	defer func() {
		if len(x.allocsc930d4e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMusic)
		}
	}()
	return refc930d4e, allocsc930d4e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Music) PassValue() (C.Music, *cgoAllocMap) {
	if x.refc930d4e != nil {
		return *x.refc930d4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Music) Convert() *music {
	if x.refc930d4e != nil {
		return (*music)(unsafe.Pointer(x.refc930d4e))
	}
	x.PassRef()
	return (*music)(unsafe.Pointer(x.refc930d4e))
}

// GetStream returns a reference to C object within a struct
func (s *Music) GetStream() *AudioStream {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *AudioStream
	ret = NewAudioStreamRef(unsafe.Pointer(&s.Ref().stream))
	return ret
}

// allocVrDeviceInfoMemory allocates memory for type C.VrDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVrDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVrDeviceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVrDeviceInfoValue = unsafe.Sizeof([1]C.VrDeviceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VrDeviceInfo) Ref() *C.VrDeviceInfo {
	if x == nil {
		return nil
	}
	return x.ref6e24e41d
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *VrDeviceInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref6e24e41d = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VrDeviceInfo) FreeRef() {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
		return
	}
	if x != nil && x.ref6e24e41d != nil && x.allocs6e24e41d == nil {
		C.free(unsafe.Pointer(x.ref6e24e41d))
		x.ref6e24e41d = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVrDeviceInfo(x *VrDeviceInfo) {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
		// fmt.Printf("VrDeviceInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs6e24e41d.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.VrDeviceInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVrDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVrDeviceInfoRef(ref unsafe.Pointer) *VrDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(VrDeviceInfo)
	obj.ref6e24e41d = (*C.VrDeviceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VrDeviceInfo) PassRef() (*C.VrDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e24e41d != nil {
		return x.ref6e24e41d, nil
	}
	mem6e24e41d := unsafe.Pointer(new(C.VrDeviceInfo))
	ref6e24e41d := (*C.VrDeviceInfo)(mem6e24e41d)
	allocs6e24e41d := new(cgoAllocMap)
	// allocs6e24e41d.Add(mem6e24e41d)

	var chResolution_allocs *cgoAllocMap
	ref6e24e41d.hResolution, chResolution_allocs = (C.int)(x.HResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chResolution_allocs)
	x.HResolution = *new(int32)

	var cvResolution_allocs *cgoAllocMap
	ref6e24e41d.vResolution, cvResolution_allocs = (C.int)(x.VResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvResolution_allocs)
	x.VResolution = *new(int32)

	var chScreenSize_allocs *cgoAllocMap
	ref6e24e41d.hScreenSize, chScreenSize_allocs = (C.float)(x.HScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chScreenSize_allocs)
	x.HScreenSize = *new(float32)

	var cvScreenSize_allocs *cgoAllocMap
	ref6e24e41d.vScreenSize, cvScreenSize_allocs = (C.float)(x.VScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenSize_allocs)
	x.VScreenSize = *new(float32)

	var cvScreenCenter_allocs *cgoAllocMap
	ref6e24e41d.vScreenCenter, cvScreenCenter_allocs = (C.float)(x.VScreenCenter), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenCenter_allocs)
	x.VScreenCenter = *new(float32)

	var ceyeToScreenDistance_allocs *cgoAllocMap
	ref6e24e41d.eyeToScreenDistance, ceyeToScreenDistance_allocs = (C.float)(x.EyeToScreenDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(ceyeToScreenDistance_allocs)
	x.EyeToScreenDistance = *new(float32)

	var clensSeparationDistance_allocs *cgoAllocMap
	ref6e24e41d.lensSeparationDistance, clensSeparationDistance_allocs = (C.float)(x.LensSeparationDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensSeparationDistance_allocs)
	x.LensSeparationDistance = *new(float32)

	var cinterpupillaryDistance_allocs *cgoAllocMap
	ref6e24e41d.interpupillaryDistance, cinterpupillaryDistance_allocs = (C.float)(x.InterpupillaryDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cinterpupillaryDistance_allocs)
	x.InterpupillaryDistance = *new(float32)

	var clensDistortionValues_allocs *cgoAllocMap
	ref6e24e41d.lensDistortionValues, clensDistortionValues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.LensDistortionValues)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensDistortionValues_allocs)
	x.LensDistortionValues = *new([4]float32)

	var cchromaAbCorrection_allocs *cgoAllocMap
	ref6e24e41d.chromaAbCorrection, cchromaAbCorrection_allocs = *(*[4]C.float)(unsafe.Pointer(&x.ChromaAbCorrection)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cchromaAbCorrection_allocs)
	x.ChromaAbCorrection = *new([4]float32)

	x.ref6e24e41d = ref6e24e41d
	x.allocs6e24e41d = allocs6e24e41d
	defer func() {
		if len(x.allocs6e24e41d.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVrDeviceInfo)
		}
	}()
	return ref6e24e41d, allocs6e24e41d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VrDeviceInfo) PassValue() (C.VrDeviceInfo, *cgoAllocMap) {
	if x.ref6e24e41d != nil {
		return *x.ref6e24e41d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *VrDeviceInfo) Convert() *vrDeviceInfo {
	if x.ref6e24e41d != nil {
		return (*vrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
	}
	x.PassRef()
	return (*vrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// allocPRectangleMemory allocates memory for type *C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPRectangleValue = unsafe.Sizeof([1]*C.Rectangle{})

// unpackArgSSRectangle transforms a sliced Go data structure into plain C format.
func unpackArgSSRectangle(x [][]Rectangle) (unpacked **C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocRectangleMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Rectangle)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Rectangle)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Rectangle)(h.Data)
	return
}

// packSSRectangle reads sliced Go data structure out from plain C format.
func packSSRectangle(v [][]Rectangle, ptr0 **C.Rectangle) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.Rectangle)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfRectangleValue]C.Rectangle)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewRectangleRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// packSModelAnimation reads sliced Go data structure out from plain C format.
func packSModelAnimation(v []ModelAnimation, ptr0 *C.ModelAnimation) {
	// c struct pointer offset
	for i0 := range v {
		ptr1 := (*C.ModelAnimation)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfModelAnimationValue)))
		v[i0] = *NewModelAnimationRef(unsafe.Pointer(ptr1))
	}
}
