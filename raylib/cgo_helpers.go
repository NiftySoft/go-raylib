// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Fri, 07 Aug 2020 20:59:32 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raylib

/*
#include "../lib/raylib/src/raylib.h"
#include "../lib/raylib/src/raymath.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("add reference, still exist: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) Ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector2) ResetRef() {
	if x == nil {
		return
	}
	x.ref29ca61a5 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector2) FreeRef() {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		return
	}
	if x != nil && x.ref29ca61a5 != nil && x.allocs29ca61a5 == nil {
		C.free(unsafe.Pointer(x.ref29ca61a5))
		x.ref29ca61a5 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(gX float32, gY float32) Vector2 {
	obj := *new(Vector2)
	obj.gX = gX
	obj.gY = gY
	return obj
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector2) Convert() *vector2 {
	if x.ref29ca61a5 != nil {
		return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.PassRef()
	return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector3) Ref() *C.Vector3 {
	if x == nil {
		return nil
	}
	return x.ref5ecd5133
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector3) ResetRef() {
	if x == nil {
		return
	}
	x.ref5ecd5133 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector3) FreeRef() {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		return
	}
	if x != nil && x.ref5ecd5133 != nil && x.allocs5ecd5133 == nil {
		C.free(unsafe.Pointer(x.ref5ecd5133))
		x.ref5ecd5133 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector3(x *Vector3) {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		// fmt.Printf("Vector3 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ecd5133.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector3 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector3 new Go object and Mapping to C object.
func NewVector3(gX float32, gY float32, gZ float32) Vector3 {
	obj := *new(Vector3)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	return obj
}

// NewVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector3Ref(ref unsafe.Pointer) *Vector3 {
	if ref == nil {
		return nil
	}
	obj := new(Vector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector3) PassRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		return x.ref5ecd5133, nil
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.gZ = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133
	defer func() {
		if len(x.allocs5ecd5133.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector3)
		}
	}()
	return ref5ecd5133, allocs5ecd5133

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector3) PassValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector3) Convert() *vector3 {
	if x.ref5ecd5133 != nil {
		return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.PassRef()
	return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// allocVector4Memory allocates memory for type C.Vector4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector4Value = unsafe.Sizeof([1]C.Vector4{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector4) Ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector4) ResetRef() {
	if x == nil {
		return
	}
	x.refc0a9c490 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector4) FreeRef() {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		return
	}
	if x != nil && x.refc0a9c490 != nil && x.allocsc0a9c490 == nil {
		C.free(unsafe.Pointer(x.refc0a9c490))
		x.refc0a9c490 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector4(x *Vector4) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		// fmt.Printf("Vector4 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector4 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector4 new Go object and Mapping to C object.
func NewVector4(gX float32, gY float32, gZ float32, gW float32) Vector4 {
	obj := *new(Vector4)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	obj.gW = gW
	return obj
}

// NewVector4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector4Ref(ref unsafe.Pointer) *Vector4 {
	if ref == nil {
		return nil
	}
	obj := new(Vector4)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector4) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		return x.refc0a9c490, nil
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	defer func() {
		if len(x.allocsc0a9c490.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector4)
		}
	}()
	return refc0a9c490, allocsc0a9c490

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector4) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector4) Convert() *vector4 {
	if x.refc0a9c490 != nil {
		return (*vector4)(unsafe.Pointer(x.refc0a9c490))
	}
	x.PassRef()
	return (*vector4)(unsafe.Pointer(x.refc0a9c490))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Quaternion) Ref() *C.Vector4 {
	if x == nil {
		return nil
	}
	return x.refc0a9c490
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Quaternion) ResetRef() {
	if x == nil {
		return
	}
	x.refc0a9c490 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Quaternion) FreeRef() {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		return
	}
	if x != nil && x.refc0a9c490 != nil && x.allocsc0a9c490 == nil {
		C.free(unsafe.Pointer(x.refc0a9c490))
		x.refc0a9c490 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeQuaternion(x *Quaternion) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		// fmt.Printf("Quaternion memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector4 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewQuaternion new Go object and Mapping to C object.
func NewQuaternion(gX float32, gY float32, gZ float32, gW float32) Quaternion {
	obj := *new(Quaternion)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	obj.gW = gW
	return obj
}

// NewQuaternionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewQuaternionRef(ref unsafe.Pointer) *Quaternion {
	if ref == nil {
		return nil
	}
	obj := new(Quaternion)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Quaternion) PassRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		return x.refc0a9c490, nil
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490
	defer func() {
		if len(x.allocsc0a9c490.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeQuaternion)
		}
	}()
	return refc0a9c490, allocsc0a9c490

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Quaternion) PassValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Quaternion) Convert() *quaternion {
	if x.refc0a9c490 != nil {
		return (*quaternion)(unsafe.Pointer(x.refc0a9c490))
	}
	x.PassRef()
	return (*quaternion)(unsafe.Pointer(x.refc0a9c490))
}

// allocMatrixMemory allocates memory for type C.Matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.Matrix{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix) Ref() *C.Matrix {
	if x == nil {
		return nil
	}
	return x.refff9f44f9
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Matrix) ResetRef() {
	if x == nil {
		return
	}
	x.refff9f44f9 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Matrix) FreeRef() {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
		return
	}
	if x != nil && x.refff9f44f9 != nil && x.allocsff9f44f9 == nil {
		C.free(unsafe.Pointer(x.refff9f44f9))
		x.refff9f44f9 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMatrix(x *Matrix) {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
		// fmt.Printf("Matrix memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsff9f44f9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Matrix memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMatrix new Go object and Mapping to C object.
func NewMatrix(gM0 float32, gM4 float32, gM8 float32, gM12 float32, gM1 float32, gM5 float32, gM9 float32, gM13 float32, gM2 float32, gM6 float32, gM10 float32, gM14 float32, gM3 float32, gM7 float32, gM11 float32, gM15 float32) Matrix {
	obj := *new(Matrix)
	obj.gM0 = gM0
	obj.gM4 = gM4
	obj.gM8 = gM8
	obj.gM12 = gM12
	obj.gM1 = gM1
	obj.gM5 = gM5
	obj.gM9 = gM9
	obj.gM13 = gM13
	obj.gM2 = gM2
	obj.gM6 = gM6
	obj.gM10 = gM10
	obj.gM14 = gM14
	obj.gM3 = gM3
	obj.gM7 = gM7
	obj.gM11 = gM11
	obj.gM15 = gM15
	return obj
}

// NewMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrixRef(ref unsafe.Pointer) *Matrix {
	if ref == nil {
		return nil
	}
	obj := new(Matrix)
	obj.refff9f44f9 = (*C.Matrix)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix) PassRef() (*C.Matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff9f44f9 != nil {
		return x.refff9f44f9, nil
	}
	memff9f44f9 := unsafe.Pointer(new(C.Matrix))
	refff9f44f9 := (*C.Matrix)(memff9f44f9)
	allocsff9f44f9 := new(cgoAllocMap)
	// allocsff9f44f9.Add(memff9f44f9)

	var cm0_allocs *cgoAllocMap
	refff9f44f9.m0, cm0_allocs = (C.float)(x.gM0), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm0_allocs)
	x.gM0 = *new(float32)

	var cm4_allocs *cgoAllocMap
	refff9f44f9.m4, cm4_allocs = (C.float)(x.gM4), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm4_allocs)
	x.gM4 = *new(float32)

	var cm8_allocs *cgoAllocMap
	refff9f44f9.m8, cm8_allocs = (C.float)(x.gM8), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm8_allocs)
	x.gM8 = *new(float32)

	var cm12_allocs *cgoAllocMap
	refff9f44f9.m12, cm12_allocs = (C.float)(x.gM12), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm12_allocs)
	x.gM12 = *new(float32)

	var cm1_allocs *cgoAllocMap
	refff9f44f9.m1, cm1_allocs = (C.float)(x.gM1), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm1_allocs)
	x.gM1 = *new(float32)

	var cm5_allocs *cgoAllocMap
	refff9f44f9.m5, cm5_allocs = (C.float)(x.gM5), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm5_allocs)
	x.gM5 = *new(float32)

	var cm9_allocs *cgoAllocMap
	refff9f44f9.m9, cm9_allocs = (C.float)(x.gM9), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm9_allocs)
	x.gM9 = *new(float32)

	var cm13_allocs *cgoAllocMap
	refff9f44f9.m13, cm13_allocs = (C.float)(x.gM13), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm13_allocs)
	x.gM13 = *new(float32)

	var cm2_allocs *cgoAllocMap
	refff9f44f9.m2, cm2_allocs = (C.float)(x.gM2), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm2_allocs)
	x.gM2 = *new(float32)

	var cm6_allocs *cgoAllocMap
	refff9f44f9.m6, cm6_allocs = (C.float)(x.gM6), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm6_allocs)
	x.gM6 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refff9f44f9.m10, cm10_allocs = (C.float)(x.gM10), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm10_allocs)
	x.gM10 = *new(float32)

	var cm14_allocs *cgoAllocMap
	refff9f44f9.m14, cm14_allocs = (C.float)(x.gM14), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm14_allocs)
	x.gM14 = *new(float32)

	var cm3_allocs *cgoAllocMap
	refff9f44f9.m3, cm3_allocs = (C.float)(x.gM3), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm3_allocs)
	x.gM3 = *new(float32)

	var cm7_allocs *cgoAllocMap
	refff9f44f9.m7, cm7_allocs = (C.float)(x.gM7), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm7_allocs)
	x.gM7 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refff9f44f9.m11, cm11_allocs = (C.float)(x.gM11), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm11_allocs)
	x.gM11 = *new(float32)

	var cm15_allocs *cgoAllocMap
	refff9f44f9.m15, cm15_allocs = (C.float)(x.gM15), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm15_allocs)
	x.gM15 = *new(float32)

	x.refff9f44f9 = refff9f44f9
	x.allocsff9f44f9 = allocsff9f44f9
	defer func() {
		if len(x.allocsff9f44f9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMatrix)
		}
	}()
	return refff9f44f9, allocsff9f44f9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix) PassValue() (C.Matrix, *cgoAllocMap) {
	if x.refff9f44f9 != nil {
		return *x.refff9f44f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Matrix) Convert() *matrix {
	if x.refff9f44f9 != nil {
		return (*matrix)(unsafe.Pointer(x.refff9f44f9))
	}
	x.PassRef()
	return (*matrix)(unsafe.Pointer(x.refff9f44f9))
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.Color {
	if x == nil {
		return nil
	}
	return x.refa79767ed
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Color) ResetRef() {
	if x == nil {
		return
	}
	x.refa79767ed = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) FreeRef() {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		return
	}
	if x != nil && x.refa79767ed != nil && x.allocsa79767ed == nil {
		C.free(unsafe.Pointer(x.refa79767ed))
		x.refa79767ed = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeColor(x *Color) {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		// fmt.Printf("Color memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa79767ed.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Color memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewColor new Go object and Mapping to C object.
func NewColor(gR byte, gG byte, gB byte, gA byte) Color {
	obj := *new(Color)
	obj.gR = gR
	obj.gG = gG
	obj.gB = gB
	obj.gA = gA
	return obj
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		return x.refa79767ed, nil
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.gR), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.gR = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.gG), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.gG = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.gB), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.gB = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.gA), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.gA = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed
	defer func() {
		if len(x.allocsa79767ed.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeColor)
		}
	}()
	return refa79767ed, allocsa79767ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Color) Convert() *color {
	if x.refa79767ed != nil {
		return (*color)(unsafe.Pointer(x.refa79767ed))
	}
	x.PassRef()
	return (*color)(unsafe.Pointer(x.refa79767ed))
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) Ref() *C.Rectangle {
	if x == nil {
		return nil
	}
	return x.refcee8783a
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Rectangle) ResetRef() {
	if x == nil {
		return
	}
	x.refcee8783a = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rectangle) FreeRef() {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		return
	}
	if x != nil && x.refcee8783a != nil && x.allocscee8783a == nil {
		C.free(unsafe.Pointer(x.refcee8783a))
		x.refcee8783a = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRectangle(x *Rectangle) {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		// fmt.Printf("Rectangle memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocscee8783a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Rectangle memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRectangle new Go object and Mapping to C object.
func NewRectangle(gX float32, gY float32, gWidth float32, gHeight float32) Rectangle {
	obj := *new(Rectangle)
	obj.gX = gX
	obj.gY = gY
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	return obj
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		return x.refcee8783a, nil
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.gWidth), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.gWidth = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.gHeight), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.gHeight = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a
	defer func() {
		if len(x.allocscee8783a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRectangle)
		}
	}()
	return refcee8783a, allocscee8783a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Rectangle) Convert() *rectangle {
	if x.refcee8783a != nil {
		return (*rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.PassRef()
	return (*rectangle)(unsafe.Pointer(x.refcee8783a))
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Image) Ref() *C.Image {
	if x == nil {
		return nil
	}
	return x.ref4fc2b5b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Image) ResetRef() {
	if x == nil {
		return
	}
	x.ref4fc2b5b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Image) FreeRef() {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
		return
	}
	if x != nil && x.ref4fc2b5b != nil && x.allocs4fc2b5b == nil {
		C.free(unsafe.Pointer(x.ref4fc2b5b))
		x.ref4fc2b5b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeImage(x *Image) {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
		// fmt.Printf("Image memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs4fc2b5b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Image memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewImage new Go object and Mapping to C object.
func NewImage(gData unsafe.Pointer, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Image {
	obj := *new(Image)
	obj.gData = gData
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	return obj
}

// NewImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewImageRef(ref unsafe.Pointer) *Image {
	if ref == nil {
		return nil
	}
	obj := new(Image)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Image) PassRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		return x.ref4fc2b5b, nil
	}
	mem4fc2b5b := unsafe.Pointer(new(C.Image))
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	// allocs4fc2b5b.Add(mem4fc2b5b)

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b
	defer func() {
		if len(x.allocs4fc2b5b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeImage)
		}
	}()
	return ref4fc2b5b, allocs4fc2b5b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Image) PassValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Image) Convert() *image {
	if x.ref4fc2b5b != nil {
		return (*image)(unsafe.Pointer(x.ref4fc2b5b))
	}
	x.PassRef()
	return (*image)(unsafe.Pointer(x.ref4fc2b5b))
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture2D) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Texture2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture2D) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture2D(x *Texture2D) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture2D new Go object and Mapping to C object.
func NewTexture2D(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Texture2D {
	obj := *new(Texture2D)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	return obj
}

// NewTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTexture2DRef(ref unsafe.Pointer) *Texture2D {
	if ref == nil {
		return nil
	}
	obj := new(Texture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture2D) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture2D)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture2D) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Texture2D) Convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Texture) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture(x *Texture) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture new Go object and Mapping to C object.
func NewTexture(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Texture {
	obj := *new(Texture)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	return obj
}

// NewTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureRef(ref unsafe.Pointer) *Texture {
	if ref == nil {
		return nil
	}
	obj := new(Texture)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Texture) Convert() *texture {
	if x.ref3c51a40b != nil {
		return (*texture)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture)(unsafe.Pointer(x.ref3c51a40b))
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *TextureCubemap) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *TextureCubemap) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *TextureCubemap) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTextureCubemap(x *TextureCubemap) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("TextureCubemap memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTextureCubemap new Go object and Mapping to C object.
func NewTextureCubemap(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) TextureCubemap {
	obj := *new(TextureCubemap)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	return obj
}

// NewTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextureCubemapRef(ref unsafe.Pointer) *TextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(TextureCubemap)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *TextureCubemap) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTextureCubemap)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x TextureCubemap) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *TextureCubemap) Convert() *textureCubemap {
	if x.ref3c51a40b != nil {
		return (*textureCubemap)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*textureCubemap)(unsafe.Pointer(x.ref3c51a40b))
}

// allocRenderTexture2DMemory allocates memory for type C.RenderTexture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderTexture2DValue = unsafe.Sizeof([1]C.RenderTexture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture2D) Ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *RenderTexture2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref2f94e9e3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderTexture2D) FreeRef() {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		return
	}
	if x != nil && x.ref2f94e9e3 != nil && x.allocs2f94e9e3 == nil {
		C.free(unsafe.Pointer(x.ref2f94e9e3))
		x.ref2f94e9e3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRenderTexture2D(x *RenderTexture2D) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		// fmt.Printf("RenderTexture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RenderTexture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRenderTexture2D new Go object and Mapping to C object.
func NewRenderTexture2D(gId uint32, gTexture Texture2D, gDepth Texture2D, gDepthTexture bool) RenderTexture2D {
	obj := *new(RenderTexture2D)
	obj.gId = gId
	obj.gTexture = gTexture
	obj.gDepth = gDepth
	obj.gDepthTexture = gDepthTexture
	return obj
}

// NewRenderTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTexture2DRef(ref unsafe.Pointer) *RenderTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture2D)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture2D) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		return x.ref2f94e9e3, nil
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.gDepth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.gDepth = *new(Texture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.gDepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.gDepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	defer func() {
		if len(x.allocs2f94e9e3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRenderTexture2D)
		}
	}()
	return ref2f94e9e3, allocs2f94e9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture2D) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *RenderTexture2D) Convert() *renderTexture2D {
	if x.ref2f94e9e3 != nil {
		return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.PassRef()
	return (*renderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
}

// GetTexture returns a reference to C object within a struct
func (s *RenderTexture2D) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetDepth returns a reference to C object within a struct
func (s *RenderTexture2D) GetDepth() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().depth))
	return ret
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RenderTexture) Ref() *C.RenderTexture2D {
	if x == nil {
		return nil
	}
	return x.ref2f94e9e3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *RenderTexture) ResetRef() {
	if x == nil {
		return
	}
	x.ref2f94e9e3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RenderTexture) FreeRef() {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		return
	}
	if x != nil && x.ref2f94e9e3 != nil && x.allocs2f94e9e3 == nil {
		C.free(unsafe.Pointer(x.ref2f94e9e3))
		x.ref2f94e9e3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRenderTexture(x *RenderTexture) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		// fmt.Printf("RenderTexture memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RenderTexture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRenderTexture new Go object and Mapping to C object.
func NewRenderTexture(gId uint32, gTexture Texture2D, gDepth Texture2D, gDepthTexture bool) RenderTexture {
	obj := *new(RenderTexture)
	obj.gId = gId
	obj.gTexture = gTexture
	obj.gDepth = gDepth
	obj.gDepthTexture = gDepthTexture
	return obj
}

// NewRenderTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRenderTextureRef(ref unsafe.Pointer) *RenderTexture {
	if ref == nil {
		return nil
	}
	obj := new(RenderTexture)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RenderTexture) PassRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		return x.ref2f94e9e3, nil
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.gDepth.PassValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.gDepth = *new(Texture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.gDepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.gDepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3
	defer func() {
		if len(x.allocs2f94e9e3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRenderTexture)
		}
	}()
	return ref2f94e9e3, allocs2f94e9e3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RenderTexture) PassValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *RenderTexture) Convert() *renderTexture {
	if x.ref2f94e9e3 != nil {
		return (*renderTexture)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.PassRef()
	return (*renderTexture)(unsafe.Pointer(x.ref2f94e9e3))
}

// GetTexture returns a reference to C object within a struct
func (s *RenderTexture) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetDepth returns a reference to C object within a struct
func (s *RenderTexture) GetDepth() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().depth))
	return ret
}

// allocNPatchInfoMemory allocates memory for type C.NPatchInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNPatchInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNPatchInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNPatchInfoValue = unsafe.Sizeof([1]C.NPatchInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *NPatchInfo) Ref() *C.NPatchInfo {
	if x == nil {
		return nil
	}
	return x.ref78104a03
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *NPatchInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref78104a03 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *NPatchInfo) FreeRef() {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
		return
	}
	if x != nil && x.ref78104a03 != nil && x.allocs78104a03 == nil {
		C.free(unsafe.Pointer(x.ref78104a03))
		x.ref78104a03 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeNPatchInfo(x *NPatchInfo) {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
		// fmt.Printf("NPatchInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs78104a03.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.NPatchInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewNPatchInfo new Go object and Mapping to C object.
func NewNPatchInfo(gSourceRec Rectangle, gLeft int32, gTop int32, gRight int32, gBottom int32, gType int32) NPatchInfo {
	obj := *new(NPatchInfo)
	obj.gSourceRec = gSourceRec
	obj.gLeft = gLeft
	obj.gTop = gTop
	obj.gRight = gRight
	obj.gBottom = gBottom
	obj.gType = gType
	return obj
}

// NewNPatchInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewNPatchInfoRef(ref unsafe.Pointer) *NPatchInfo {
	if ref == nil {
		return nil
	}
	obj := new(NPatchInfo)
	obj.ref78104a03 = (*C.NPatchInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *NPatchInfo) PassRef() (*C.NPatchInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78104a03 != nil {
		return x.ref78104a03, nil
	}
	mem78104a03 := unsafe.Pointer(new(C.NPatchInfo))
	ref78104a03 := (*C.NPatchInfo)(mem78104a03)
	allocs78104a03 := new(cgoAllocMap)
	// allocs78104a03.Add(mem78104a03)

	var csourceRec_allocs *cgoAllocMap
	ref78104a03.sourceRec, csourceRec_allocs = x.gSourceRec.PassValue()
	allocs78104a03.Borrow(csourceRec_allocs)
	x.gSourceRec = *new(Rectangle)

	var cleft_allocs *cgoAllocMap
	ref78104a03.left, cleft_allocs = (C.int)(x.gLeft), cgoAllocsUnknown
	allocs78104a03.Borrow(cleft_allocs)
	x.gLeft = *new(int32)

	var ctop_allocs *cgoAllocMap
	ref78104a03.top, ctop_allocs = (C.int)(x.gTop), cgoAllocsUnknown
	allocs78104a03.Borrow(ctop_allocs)
	x.gTop = *new(int32)

	var cright_allocs *cgoAllocMap
	ref78104a03.right, cright_allocs = (C.int)(x.gRight), cgoAllocsUnknown
	allocs78104a03.Borrow(cright_allocs)
	x.gRight = *new(int32)

	var cbottom_allocs *cgoAllocMap
	ref78104a03.bottom, cbottom_allocs = (C.int)(x.gBottom), cgoAllocsUnknown
	allocs78104a03.Borrow(cbottom_allocs)
	x.gBottom = *new(int32)

	var c_type_allocs *cgoAllocMap
	ref78104a03._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs78104a03.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref78104a03 = ref78104a03
	x.allocs78104a03 = allocs78104a03
	defer func() {
		if len(x.allocs78104a03.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeNPatchInfo)
		}
	}()
	return ref78104a03, allocs78104a03

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x NPatchInfo) PassValue() (C.NPatchInfo, *cgoAllocMap) {
	if x.ref78104a03 != nil {
		return *x.ref78104a03, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *NPatchInfo) Convert() *nPatchInfo {
	if x.ref78104a03 != nil {
		return (*nPatchInfo)(unsafe.Pointer(x.ref78104a03))
	}
	x.PassRef()
	return (*nPatchInfo)(unsafe.Pointer(x.ref78104a03))
}

// GetSourceRec returns a reference to C object within a struct
func (s *NPatchInfo) GetSourceRec() *Rectangle {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	ret = NewRectangleRef(unsafe.Pointer(&s.Ref().sourceRec))
	return ret
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *CharInfo) Ref() *C.CharInfo {
	if x == nil {
		return nil
	}
	return x.ref702c36c0
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *CharInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref702c36c0 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *CharInfo) FreeRef() {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
		return
	}
	if x != nil && x.ref702c36c0 != nil && x.allocs702c36c0 == nil {
		C.free(unsafe.Pointer(x.ref702c36c0))
		x.ref702c36c0 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCharInfo(x *CharInfo) {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
		// fmt.Printf("CharInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs702c36c0.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.CharInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCharInfo new Go object and Mapping to C object.
func NewCharInfo(gValue int32, gOffsetX int32, gOffsetY int32, gAdvanceX int32, gImage Image) CharInfo {
	obj := *new(CharInfo)
	obj.gValue = gValue
	obj.gOffsetX = gOffsetX
	obj.gOffsetY = gOffsetY
	obj.gAdvanceX = gAdvanceX
	obj.gImage = gImage
	return obj
}

// NewCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCharInfoRef(ref unsafe.Pointer) *CharInfo {
	if ref == nil {
		return nil
	}
	obj := new(CharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *CharInfo) PassRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		return x.ref702c36c0, nil
	}
	mem702c36c0 := unsafe.Pointer(new(C.CharInfo))
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	// allocs702c36c0.Add(mem702c36c0)

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.gValue), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)
	x.gValue = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.gOffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)
	x.gOffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.gOffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)
	x.gOffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.gAdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)
	x.gAdvanceX = *new(int32)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.gImage.PassValue()
	allocs702c36c0.Borrow(cimage_allocs)
	x.gImage = *new(Image)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0
	defer func() {
		if len(x.allocs702c36c0.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCharInfo)
		}
	}()
	return ref702c36c0, allocs702c36c0

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x CharInfo) PassValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *CharInfo) Convert() *charInfo {
	if x.ref702c36c0 != nil {
		return (*charInfo)(unsafe.Pointer(x.ref702c36c0))
	}
	x.PassRef()
	return (*charInfo)(unsafe.Pointer(x.ref702c36c0))
}

// GetImage returns a reference to C object within a struct
func (s *CharInfo) GetImage() *Image {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Image
	ret = NewImageRef(unsafe.Pointer(&s.Ref().image))
	return ret
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []CharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Font) Ref() *C.Font {
	if x == nil {
		return nil
	}
	return x.ref70a6a7ec
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Font) ResetRef() {
	if x == nil {
		return
	}
	x.ref70a6a7ec = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Font) FreeRef() {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		return
	}
	if x != nil && x.ref70a6a7ec != nil && x.allocs70a6a7ec == nil {
		C.free(unsafe.Pointer(x.ref70a6a7ec))
		x.ref70a6a7ec = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeFont(x *Font) {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		// fmt.Printf("Font memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs70a6a7ec.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Font memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewFont new Go object and Mapping to C object.
func NewFont(gBaseSize int32, gCharsCount int32, gTexture Texture2D, gRecs []Rectangle, gChars []CharInfo) Font {
	obj := *new(Font)
	obj.gBaseSize = gBaseSize
	obj.gCharsCount = gCharsCount
	obj.gTexture = gTexture
	obj.gRecs = gRecs
	obj.gChars = gChars
	return obj
}

// NewFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontRef(ref unsafe.Pointer) *Font {
	if ref == nil {
		return nil
	}
	obj := new(Font)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Font) PassRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		return x.ref70a6a7ec, nil
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.gBaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.gBaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.gCharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.gCharsCount = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.gRecs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.gRecs = *new([]Rectangle)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.gChars)
	allocs70a6a7ec.Borrow(cchars_allocs)
	x.gChars = *new([]CharInfo)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec
	defer func() {
		if len(x.allocs70a6a7ec.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeFont)
		}
	}()
	return ref70a6a7ec, allocs70a6a7ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Font) PassValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Font) Convert() *font {
	if x.ref70a6a7ec != nil {
		return (*font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.PassRef()
	return (*font)(unsafe.Pointer(x.ref70a6a7ec))
}

// GetTexture returns a reference to C object within a struct
func (s *Font) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetRecs returns a reference to C object within a struct
func (s *Font) GetRecs(recsIndex int32) *Rectangle {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	// c struct pointer offset
	ptr0 := s.Ref().recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(recsIndex)*uintptr(sizeOfRectangleValue)))

	ret = NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// GetChars returns a reference to C object within a struct
func (s *Font) GetChars(charsIndex int32) *CharInfo {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *CharInfo
	// c struct pointer offset
	ptr0 := s.Ref().chars
	ptr1 := (*C.CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(charsIndex)*uintptr(sizeOfCharInfoValue)))

	ret = NewCharInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// allocCamera3DMemory allocates memory for type C.Camera3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera3DValue = unsafe.Sizeof([1]C.Camera3D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera3D) Ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Camera3D) ResetRef() {
	if x == nil {
		return
	}
	x.ref7b09036 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera3D) FreeRef() {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		return
	}
	if x != nil && x.ref7b09036 != nil && x.allocs7b09036 == nil {
		C.free(unsafe.Pointer(x.ref7b09036))
		x.ref7b09036 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera3D(x *Camera3D) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		// fmt.Printf("Camera3D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7b09036.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera3D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera3D new Go object and Mapping to C object.
func NewCamera3D(gPosition Vector3, gTarget Vector3, gUp Vector3, gFovy float32, gType int32) Camera3D {
	obj := *new(Camera3D)
	obj.gPosition = gPosition
	obj.gTarget = gTarget
	obj.gUp = gUp
	obj.gFovy = gFovy
	obj.gType = gType
	return obj
}

// NewCamera3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera3DRef(ref unsafe.Pointer) *Camera3D {
	if ref == nil {
		return nil
	}
	obj := new(Camera3D)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera3D) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		return x.ref7b09036, nil
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.PassValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(Vector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.PassValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(Vector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	defer func() {
		if len(x.allocs7b09036.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera3D)
		}
	}()
	return ref7b09036, allocs7b09036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera3D) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Camera3D) Convert() *camera3D {
	if x.ref7b09036 != nil {
		return (*camera3D)(unsafe.Pointer(x.ref7b09036))
	}
	x.PassRef()
	return (*camera3D)(unsafe.Pointer(x.ref7b09036))
}

// GetPosition returns a reference to C object within a struct
func (s *Camera3D) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetTarget returns a reference to C object within a struct
func (s *Camera3D) GetTarget() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().target))
	return ret
}

// GetUp returns a reference to C object within a struct
func (s *Camera3D) GetUp() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().up))
	return ret
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera) Ref() *C.Camera3D {
	if x == nil {
		return nil
	}
	return x.ref7b09036
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Camera) ResetRef() {
	if x == nil {
		return
	}
	x.ref7b09036 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera) FreeRef() {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		return
	}
	if x != nil && x.ref7b09036 != nil && x.allocs7b09036 == nil {
		C.free(unsafe.Pointer(x.ref7b09036))
		x.ref7b09036 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera(x *Camera) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		// fmt.Printf("Camera memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7b09036.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera3D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera new Go object and Mapping to C object.
func NewCamera(gPosition Vector3, gTarget Vector3, gUp Vector3, gFovy float32, gType int32) Camera {
	obj := *new(Camera)
	obj.gPosition = gPosition
	obj.gTarget = gTarget
	obj.gUp = gUp
	obj.gFovy = gFovy
	obj.gType = gType
	return obj
}

// NewCameraRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCameraRef(ref unsafe.Pointer) *Camera {
	if ref == nil {
		return nil
	}
	obj := new(Camera)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera) PassRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		return x.ref7b09036, nil
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.PassValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.PassValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(Vector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.PassValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(Vector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036
	defer func() {
		if len(x.allocs7b09036.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera)
		}
	}()
	return ref7b09036, allocs7b09036

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera) PassValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Camera) Convert() *camera {
	if x.ref7b09036 != nil {
		return (*camera)(unsafe.Pointer(x.ref7b09036))
	}
	x.PassRef()
	return (*camera)(unsafe.Pointer(x.ref7b09036))
}

// GetPosition returns a reference to C object within a struct
func (s *Camera) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetTarget returns a reference to C object within a struct
func (s *Camera) GetTarget() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().target))
	return ret
}

// GetUp returns a reference to C object within a struct
func (s *Camera) GetUp() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().up))
	return ret
}

// allocCamera2DMemory allocates memory for type C.Camera2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera2DValue = unsafe.Sizeof([1]C.Camera2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Camera2D) Ref() *C.Camera2D {
	if x == nil {
		return nil
	}
	return x.ref1eaba177
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Camera2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref1eaba177 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Camera2D) FreeRef() {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
		return
	}
	if x != nil && x.ref1eaba177 != nil && x.allocs1eaba177 == nil {
		C.free(unsafe.Pointer(x.ref1eaba177))
		x.ref1eaba177 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeCamera2D(x *Camera2D) {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
		// fmt.Printf("Camera2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs1eaba177.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Camera2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewCamera2D new Go object and Mapping to C object.
func NewCamera2D(gOffset Vector2, gTarget Vector2, gRotation float32, gZoom float32) Camera2D {
	obj := *new(Camera2D)
	obj.gOffset = gOffset
	obj.gTarget = gTarget
	obj.gRotation = gRotation
	obj.gZoom = gZoom
	return obj
}

// NewCamera2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewCamera2DRef(ref unsafe.Pointer) *Camera2D {
	if ref == nil {
		return nil
	}
	obj := new(Camera2D)
	obj.ref1eaba177 = (*C.Camera2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Camera2D) PassRef() (*C.Camera2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eaba177 != nil {
		return x.ref1eaba177, nil
	}
	mem1eaba177 := unsafe.Pointer(new(C.Camera2D))
	ref1eaba177 := (*C.Camera2D)(mem1eaba177)
	allocs1eaba177 := new(cgoAllocMap)
	// allocs1eaba177.Add(mem1eaba177)

	var coffset_allocs *cgoAllocMap
	ref1eaba177.offset, coffset_allocs = x.gOffset.PassValue()
	allocs1eaba177.Borrow(coffset_allocs)
	x.gOffset = *new(Vector2)

	var ctarget_allocs *cgoAllocMap
	ref1eaba177.target, ctarget_allocs = x.gTarget.PassValue()
	allocs1eaba177.Borrow(ctarget_allocs)
	x.gTarget = *new(Vector2)

	var crotation_allocs *cgoAllocMap
	ref1eaba177.rotation, crotation_allocs = (C.float)(x.gRotation), cgoAllocsUnknown
	allocs1eaba177.Borrow(crotation_allocs)
	x.gRotation = *new(float32)

	var czoom_allocs *cgoAllocMap
	ref1eaba177.zoom, czoom_allocs = (C.float)(x.gZoom), cgoAllocsUnknown
	allocs1eaba177.Borrow(czoom_allocs)
	x.gZoom = *new(float32)

	x.ref1eaba177 = ref1eaba177
	x.allocs1eaba177 = allocs1eaba177
	defer func() {
		if len(x.allocs1eaba177.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeCamera2D)
		}
	}()
	return ref1eaba177, allocs1eaba177

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Camera2D) PassValue() (C.Camera2D, *cgoAllocMap) {
	if x.ref1eaba177 != nil {
		return *x.ref1eaba177, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Camera2D) Convert() *camera2D {
	if x.ref1eaba177 != nil {
		return (*camera2D)(unsafe.Pointer(x.ref1eaba177))
	}
	x.PassRef()
	return (*camera2D)(unsafe.Pointer(x.ref1eaba177))
}

// GetOffset returns a reference to C object within a struct
func (s *Camera2D) GetOffset() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().offset))
	return ret
}

// GetTarget returns a reference to C object within a struct
func (s *Camera2D) GetTarget() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().target))
	return ret
}

// allocMeshMemory allocates memory for type C.Mesh in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMeshMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMeshValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMeshValue = unsafe.Sizeof([1]C.Mesh{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Mesh) Ref() *C.Mesh {
	if x == nil {
		return nil
	}
	return x.ref415d9568
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Mesh) ResetRef() {
	if x == nil {
		return
	}
	x.ref415d9568 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Mesh) FreeRef() {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
		return
	}
	if x != nil && x.ref415d9568 != nil && x.allocs415d9568 == nil {
		C.free(unsafe.Pointer(x.ref415d9568))
		x.ref415d9568 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMesh(x *Mesh) {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
		// fmt.Printf("Mesh memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs415d9568.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Mesh memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMesh new Go object and Mapping to C object.
func NewMesh(gVertexCount int32, gTriangleCount int32, gVertices []float32, gTexcoords []float32, gTexcoords2 []float32, gNormals []float32, gTangents []float32, gColors []byte, gIndices []uint16, gAnimVertices []float32, gAnimNormals []float32, gBoneIds []int32, gBoneWeights []float32, gVaoId uint32, gVboId []uint32) Mesh {
	obj := *new(Mesh)
	obj.gVertexCount = gVertexCount
	obj.gTriangleCount = gTriangleCount
	obj.gVertices = gVertices
	obj.gTexcoords = gTexcoords
	obj.gTexcoords2 = gTexcoords2
	obj.gNormals = gNormals
	obj.gTangents = gTangents
	obj.gColors = gColors
	obj.gIndices = gIndices
	obj.gAnimVertices = gAnimVertices
	obj.gAnimNormals = gAnimNormals
	obj.gBoneIds = gBoneIds
	obj.gBoneWeights = gBoneWeights
	obj.gVaoId = gVaoId
	obj.gVboId = gVboId
	return obj
}

// NewMeshRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMeshRef(ref unsafe.Pointer) *Mesh {
	if ref == nil {
		return nil
	}
	obj := new(Mesh)
	obj.ref415d9568 = (*C.Mesh)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Mesh) PassRef() (*C.Mesh, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref415d9568 != nil {
		return x.ref415d9568, nil
	}
	mem415d9568 := unsafe.Pointer(new(C.Mesh))
	ref415d9568 := (*C.Mesh)(mem415d9568)
	allocs415d9568 := new(cgoAllocMap)
	// allocs415d9568.Add(mem415d9568)

	var cvertexCount_allocs *cgoAllocMap
	ref415d9568.vertexCount, cvertexCount_allocs = (C.int)(x.gVertexCount), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertexCount_allocs)
	x.gVertexCount = *new(int32)

	var ctriangleCount_allocs *cgoAllocMap
	ref415d9568.triangleCount, ctriangleCount_allocs = (C.int)(x.gTriangleCount), cgoAllocsUnknown
	allocs415d9568.Borrow(ctriangleCount_allocs)
	x.gTriangleCount = *new(int32)

	var cvertices_allocs *cgoAllocMap
	ref415d9568.vertices, cvertices_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gVertices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertices_allocs)
	x.gVertices = *new([]float32)

	var ctexcoords_allocs *cgoAllocMap
	ref415d9568.texcoords, ctexcoords_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gTexcoords)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctexcoords_allocs)
	x.gTexcoords = *new([]float32)

	var ctexcoords2_allocs *cgoAllocMap
	ref415d9568.texcoords2, ctexcoords2_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gTexcoords2)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctexcoords2_allocs)
	x.gTexcoords2 = *new([]float32)

	var cnormals_allocs *cgoAllocMap
	ref415d9568.normals, cnormals_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gNormals)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cnormals_allocs)
	x.gNormals = *new([]float32)

	var ctangents_allocs *cgoAllocMap
	ref415d9568.tangents, ctangents_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gTangents)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ctangents_allocs)
	x.gTangents = *new([]float32)

	var ccolors_allocs *cgoAllocMap
	ref415d9568.colors, ccolors_allocs = (*C.uchar)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gColors)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(ccolors_allocs)
	x.gColors = *new([]byte)

	var cindices_allocs *cgoAllocMap
	ref415d9568.indices, cindices_allocs = (*C.ushort)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gIndices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cindices_allocs)
	x.gIndices = *new([]uint16)

	var canimVertices_allocs *cgoAllocMap
	ref415d9568.animVertices, canimVertices_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gAnimVertices)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(canimVertices_allocs)
	x.gAnimVertices = *new([]float32)

	var canimNormals_allocs *cgoAllocMap
	ref415d9568.animNormals, canimNormals_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gAnimNormals)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(canimNormals_allocs)
	x.gAnimNormals = *new([]float32)

	var cboneIds_allocs *cgoAllocMap
	ref415d9568.boneIds, cboneIds_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gBoneIds)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cboneIds_allocs)
	x.gBoneIds = *new([]int32)

	var cboneWeights_allocs *cgoAllocMap
	ref415d9568.boneWeights, cboneWeights_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gBoneWeights)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cboneWeights_allocs)
	x.gBoneWeights = *new([]float32)

	var cvaoId_allocs *cgoAllocMap
	ref415d9568.vaoId, cvaoId_allocs = (C.uint)(x.gVaoId), cgoAllocsUnknown
	allocs415d9568.Borrow(cvaoId_allocs)
	x.gVaoId = *new(uint32)

	var cvboId_allocs *cgoAllocMap
	ref415d9568.vboId, cvboId_allocs = (*C.uint)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gVboId)).Data)), cgoAllocsUnknown
	allocs415d9568.Borrow(cvboId_allocs)
	x.gVboId = *new([]uint32)

	x.ref415d9568 = ref415d9568
	x.allocs415d9568 = allocs415d9568
	defer func() {
		if len(x.allocs415d9568.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMesh)
		}
	}()
	return ref415d9568, allocs415d9568

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Mesh) PassValue() (C.Mesh, *cgoAllocMap) {
	if x.ref415d9568 != nil {
		return *x.ref415d9568, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Mesh) Convert() *mesh {
	if x.ref415d9568 != nil {
		return (*mesh)(unsafe.Pointer(x.ref415d9568))
	}
	x.PassRef()
	return (*mesh)(unsafe.Pointer(x.ref415d9568))
}

// GetVertices returns a reference to C object within a struct
func (s *Mesh) GetVertices(verticesCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, verticesCount)
	ptr0 := s.Ref().vertices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetTexcoords returns a reference to C object within a struct
func (s *Mesh) GetTexcoords(texcoordsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, texcoordsCount)
	ptr0 := s.Ref().texcoords
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetTexcoords2 returns a reference to C object within a struct
func (s *Mesh) GetTexcoords2(texcoords2Count int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, texcoords2Count)
	ptr0 := s.Ref().texcoords2
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetNormals returns a reference to C object within a struct
func (s *Mesh) GetNormals(normalsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, normalsCount)
	ptr0 := s.Ref().normals
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetTangents returns a reference to C object within a struct
func (s *Mesh) GetTangents(tangentsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, tangentsCount)
	ptr0 := s.Ref().tangents
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetColors returns a reference to C object within a struct
func (s *Mesh) GetColors(colorsCount int32) []*byte {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*byte

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uchar{})
	ret = make([]*byte, colorsCount)
	ptr0 := s.Ref().colors
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.uchar)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*byte)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetIndices returns a reference to C object within a struct
func (s *Mesh) GetIndices(indicesCount int32) []*uint16 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*uint16

	const sizeOfPlainValue = unsafe.Sizeof([1]C.ushort{})
	ret = make([]*uint16, indicesCount)
	ptr0 := s.Ref().indices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.ushort)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*uint16)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetAnimVertices returns a reference to C object within a struct
func (s *Mesh) GetAnimVertices(animVerticesCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, animVerticesCount)
	ptr0 := s.Ref().animVertices
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetAnimNormals returns a reference to C object within a struct
func (s *Mesh) GetAnimNormals(animNormalsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, animNormalsCount)
	ptr0 := s.Ref().animNormals
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetBoneIds returns a reference to C object within a struct
func (s *Mesh) GetBoneIds(boneIdsCount int32) []*int32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, boneIdsCount)
	ptr0 := s.Ref().boneIds
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetBoneWeights returns a reference to C object within a struct
func (s *Mesh) GetBoneWeights(boneWeightsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, boneWeightsCount)
	ptr0 := s.Ref().boneWeights
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetVboId returns a reference to C object within a struct
func (s *Mesh) GetVboId(vboIdCount int32) []*uint32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*uint32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.uint{})
	ret = make([]*uint32, vboIdCount)
	ptr0 := s.Ref().vboId
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.uint)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*uint32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocShaderMemory allocates memory for type C.Shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderValue = unsafe.Sizeof([1]C.Shader{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Shader) Ref() *C.Shader {
	if x == nil {
		return nil
	}
	return x.reff85f9b1e
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Shader) ResetRef() {
	if x == nil {
		return
	}
	x.reff85f9b1e = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Shader) FreeRef() {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
		return
	}
	if x != nil && x.reff85f9b1e != nil && x.allocsf85f9b1e == nil {
		C.free(unsafe.Pointer(x.reff85f9b1e))
		x.reff85f9b1e = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeShader(x *Shader) {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
		// fmt.Printf("Shader memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsf85f9b1e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Shader memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewShader new Go object and Mapping to C object.
func NewShader(gId uint32, gLocs []int32) Shader {
	obj := *new(Shader)
	obj.gId = gId
	obj.gLocs = gLocs
	return obj
}

// NewShaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewShaderRef(ref unsafe.Pointer) *Shader {
	if ref == nil {
		return nil
	}
	obj := new(Shader)
	obj.reff85f9b1e = (*C.Shader)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Shader) PassRef() (*C.Shader, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff85f9b1e != nil {
		return x.reff85f9b1e, nil
	}
	memf85f9b1e := unsafe.Pointer(new(C.Shader))
	reff85f9b1e := (*C.Shader)(memf85f9b1e)
	allocsf85f9b1e := new(cgoAllocMap)
	// allocsf85f9b1e.Add(memf85f9b1e)

	var cid_allocs *cgoAllocMap
	reff85f9b1e.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var clocs_allocs *cgoAllocMap
	reff85f9b1e.locs, clocs_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gLocs)).Data)), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(clocs_allocs)
	x.gLocs = *new([]int32)

	x.reff85f9b1e = reff85f9b1e
	x.allocsf85f9b1e = allocsf85f9b1e
	defer func() {
		if len(x.allocsf85f9b1e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeShader)
		}
	}()
	return reff85f9b1e, allocsf85f9b1e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Shader) PassValue() (C.Shader, *cgoAllocMap) {
	if x.reff85f9b1e != nil {
		return *x.reff85f9b1e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Shader) Convert() *shader {
	if x.reff85f9b1e != nil {
		return (*shader)(unsafe.Pointer(x.reff85f9b1e))
	}
	x.PassRef()
	return (*shader)(unsafe.Pointer(x.reff85f9b1e))
}

// GetLocs returns a reference to C object within a struct
func (s *Shader) GetLocs(locsCount int32) []*int32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, locsCount)
	ptr0 := s.Ref().locs
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocMaterialMapMemory allocates memory for type C.MaterialMap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialMapValue = unsafe.Sizeof([1]C.MaterialMap{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *MaterialMap) Ref() *C.MaterialMap {
	if x == nil {
		return nil
	}
	return x.refa8350ad3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *MaterialMap) ResetRef() {
	if x == nil {
		return
	}
	x.refa8350ad3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *MaterialMap) FreeRef() {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
		return
	}
	if x != nil && x.refa8350ad3 != nil && x.allocsa8350ad3 == nil {
		C.free(unsafe.Pointer(x.refa8350ad3))
		x.refa8350ad3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMaterialMap(x *MaterialMap) {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
		// fmt.Printf("MaterialMap memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa8350ad3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.MaterialMap memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMaterialMap new Go object and Mapping to C object.
func NewMaterialMap(gTexture Texture2D, gColor Color, gValue float32) MaterialMap {
	obj := *new(MaterialMap)
	obj.gTexture = gTexture
	obj.gColor = gColor
	obj.gValue = gValue
	return obj
}

// NewMaterialMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialMapRef(ref unsafe.Pointer) *MaterialMap {
	if ref == nil {
		return nil
	}
	obj := new(MaterialMap)
	obj.refa8350ad3 = (*C.MaterialMap)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *MaterialMap) PassRef() (*C.MaterialMap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8350ad3 != nil {
		return x.refa8350ad3, nil
	}
	mema8350ad3 := unsafe.Pointer(new(C.MaterialMap))
	refa8350ad3 := (*C.MaterialMap)(mema8350ad3)
	allocsa8350ad3 := new(cgoAllocMap)
	// allocsa8350ad3.Add(mema8350ad3)

	var ctexture_allocs *cgoAllocMap
	refa8350ad3.texture, ctexture_allocs = x.gTexture.PassValue()
	allocsa8350ad3.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var ccolor_allocs *cgoAllocMap
	refa8350ad3.color, ccolor_allocs = x.gColor.PassValue()
	allocsa8350ad3.Borrow(ccolor_allocs)
	x.gColor = *new(Color)

	var cvalue_allocs *cgoAllocMap
	refa8350ad3.value, cvalue_allocs = (C.float)(x.gValue), cgoAllocsUnknown
	allocsa8350ad3.Borrow(cvalue_allocs)
	x.gValue = *new(float32)

	x.refa8350ad3 = refa8350ad3
	x.allocsa8350ad3 = allocsa8350ad3
	defer func() {
		if len(x.allocsa8350ad3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMaterialMap)
		}
	}()
	return refa8350ad3, allocsa8350ad3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x MaterialMap) PassValue() (C.MaterialMap, *cgoAllocMap) {
	if x.refa8350ad3 != nil {
		return *x.refa8350ad3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *MaterialMap) Convert() *materialMap {
	if x.refa8350ad3 != nil {
		return (*materialMap)(unsafe.Pointer(x.refa8350ad3))
	}
	x.PassRef()
	return (*materialMap)(unsafe.Pointer(x.refa8350ad3))
}

// GetTexture returns a reference to C object within a struct
func (s *MaterialMap) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetColor returns a reference to C object within a struct
func (s *MaterialMap) GetColor() *Color {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Color
	ret = NewColorRef(unsafe.Pointer(&s.Ref().color))
	return ret
}

// allocMaterialMemory allocates memory for type C.Material in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialValue = unsafe.Sizeof([1]C.Material{})

// unpackSMaterialMap transforms a sliced Go data structure into plain C format.
func unpackSMaterialMap(x []MaterialMap) (unpacked *C.MaterialMap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.MaterialMap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.MaterialMap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.MaterialMap)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Material) Ref() *C.Material {
	if x == nil {
		return nil
	}
	return x.ref85c817c3
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Material) ResetRef() {
	if x == nil {
		return
	}
	x.ref85c817c3 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Material) FreeRef() {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
		return
	}
	if x != nil && x.ref85c817c3 != nil && x.allocs85c817c3 == nil {
		C.free(unsafe.Pointer(x.ref85c817c3))
		x.ref85c817c3 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMaterial(x *Material) {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
		// fmt.Printf("Material memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs85c817c3.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Material memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMaterial new Go object and Mapping to C object.
func NewMaterial(gShader Shader, gMaps []MaterialMap, gParams []float32) Material {
	obj := *new(Material)
	obj.gShader = gShader
	obj.gMaps = gMaps
	obj.gParams = gParams
	return obj
}

// NewMaterialRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMaterialRef(ref unsafe.Pointer) *Material {
	if ref == nil {
		return nil
	}
	obj := new(Material)
	obj.ref85c817c3 = (*C.Material)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Material) PassRef() (*C.Material, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c817c3 != nil {
		return x.ref85c817c3, nil
	}
	mem85c817c3 := unsafe.Pointer(new(C.Material))
	ref85c817c3 := (*C.Material)(mem85c817c3)
	allocs85c817c3 := new(cgoAllocMap)
	// allocs85c817c3.Add(mem85c817c3)

	var cshader_allocs *cgoAllocMap
	ref85c817c3.shader, cshader_allocs = x.gShader.PassValue()
	allocs85c817c3.Borrow(cshader_allocs)
	x.gShader = *new(Shader)

	var cmaps_allocs *cgoAllocMap
	ref85c817c3.maps, cmaps_allocs = unpackSMaterialMap(x.gMaps)
	allocs85c817c3.Borrow(cmaps_allocs)
	x.gMaps = *new([]MaterialMap)

	var cparams_allocs *cgoAllocMap
	ref85c817c3.params, cparams_allocs = (*C.float)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gParams)).Data)), cgoAllocsUnknown
	allocs85c817c3.Borrow(cparams_allocs)
	x.gParams = *new([]float32)

	x.ref85c817c3 = ref85c817c3
	x.allocs85c817c3 = allocs85c817c3
	defer func() {
		if len(x.allocs85c817c3.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMaterial)
		}
	}()
	return ref85c817c3, allocs85c817c3

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Material) PassValue() (C.Material, *cgoAllocMap) {
	if x.ref85c817c3 != nil {
		return *x.ref85c817c3, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Material) Convert() *material {
	if x.ref85c817c3 != nil {
		return (*material)(unsafe.Pointer(x.ref85c817c3))
	}
	x.PassRef()
	return (*material)(unsafe.Pointer(x.ref85c817c3))
}

// GetShader returns a reference to C object within a struct
func (s *Material) GetShader() *Shader {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Shader
	ret = NewShaderRef(unsafe.Pointer(&s.Ref().shader))
	return ret
}

// GetMaps returns a reference to C object within a struct
func (s *Material) GetMaps(mapsIndex int32) *MaterialMap {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *MaterialMap
	// c struct pointer offset
	ptr0 := s.Ref().maps
	ptr1 := (*C.MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(mapsIndex)*uintptr(sizeOfMaterialMapValue)))

	ret = NewMaterialMapRef(unsafe.Pointer(ptr1))
	return ret
}

// GetParams returns a reference to C object within a struct
func (s *Material) GetParams(paramsCount int32) []*float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*float32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.float{})
	ret = make([]*float32, paramsCount)
	ptr0 := s.Ref().params
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.float)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*float32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// allocTransformMemory allocates memory for type C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransformValue = unsafe.Sizeof([1]C.Transform{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Transform) Ref() *C.Transform {
	if x == nil {
		return nil
	}
	return x.reff543030e
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Transform) ResetRef() {
	if x == nil {
		return
	}
	x.reff543030e = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Transform) FreeRef() {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
		return
	}
	if x != nil && x.reff543030e != nil && x.allocsf543030e == nil {
		C.free(unsafe.Pointer(x.reff543030e))
		x.reff543030e = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTransform(x *Transform) {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
		// fmt.Printf("Transform memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsf543030e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Transform memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTransform new Go object and Mapping to C object.
func NewTransform(gTranslation Vector3, gRotation Quaternion, gScale Vector3) Transform {
	obj := *new(Transform)
	obj.gTranslation = gTranslation
	obj.gRotation = gRotation
	obj.gScale = gScale
	return obj
}

// NewTransformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTransformRef(ref unsafe.Pointer) *Transform {
	if ref == nil {
		return nil
	}
	obj := new(Transform)
	obj.reff543030e = (*C.Transform)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Transform) PassRef() (*C.Transform, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff543030e != nil {
		return x.reff543030e, nil
	}
	memf543030e := unsafe.Pointer(new(C.Transform))
	reff543030e := (*C.Transform)(memf543030e)
	allocsf543030e := new(cgoAllocMap)
	// allocsf543030e.Add(memf543030e)

	var ctranslation_allocs *cgoAllocMap
	reff543030e.translation, ctranslation_allocs = x.gTranslation.PassValue()
	allocsf543030e.Borrow(ctranslation_allocs)
	x.gTranslation = *new(Vector3)

	var crotation_allocs *cgoAllocMap
	reff543030e.rotation, crotation_allocs = x.gRotation.PassValue()
	allocsf543030e.Borrow(crotation_allocs)
	x.gRotation = *new(Quaternion)

	var cscale_allocs *cgoAllocMap
	reff543030e.scale, cscale_allocs = x.gScale.PassValue()
	allocsf543030e.Borrow(cscale_allocs)
	x.gScale = *new(Vector3)

	x.reff543030e = reff543030e
	x.allocsf543030e = allocsf543030e
	defer func() {
		if len(x.allocsf543030e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTransform)
		}
	}()
	return reff543030e, allocsf543030e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Transform) PassValue() (C.Transform, *cgoAllocMap) {
	if x.reff543030e != nil {
		return *x.reff543030e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Transform) Convert() *transform {
	if x.reff543030e != nil {
		return (*transform)(unsafe.Pointer(x.reff543030e))
	}
	x.PassRef()
	return (*transform)(unsafe.Pointer(x.reff543030e))
}

// GetTranslation returns a reference to C object within a struct
func (s *Transform) GetTranslation() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().translation))
	return ret
}

// GetRotation returns a reference to C object within a struct
func (s *Transform) GetRotation() *Quaternion {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Quaternion
	ret = NewQuaternionRef(unsafe.Pointer(&s.Ref().rotation))
	return ret
}

// GetScale returns a reference to C object within a struct
func (s *Transform) GetScale() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().scale))
	return ret
}

// allocBoneInfoMemory allocates memory for type C.BoneInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoneInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoneInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoneInfoValue = unsafe.Sizeof([1]C.BoneInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoneInfo) Ref() *C.BoneInfo {
	if x == nil {
		return nil
	}
	return x.ref5ab7f197
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *BoneInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref5ab7f197 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BoneInfo) FreeRef() {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
		return
	}
	if x != nil && x.ref5ab7f197 != nil && x.allocs5ab7f197 == nil {
		C.free(unsafe.Pointer(x.ref5ab7f197))
		x.ref5ab7f197 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeBoneInfo(x *BoneInfo) {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
		// fmt.Printf("BoneInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ab7f197.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.BoneInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewBoneInfo new Go object and Mapping to C object.
func NewBoneInfo(gName [32]byte, gParent int32) BoneInfo {
	obj := *new(BoneInfo)
	obj.gName = gName
	obj.gParent = gParent
	return obj
}

// NewBoneInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoneInfoRef(ref unsafe.Pointer) *BoneInfo {
	if ref == nil {
		return nil
	}
	obj := new(BoneInfo)
	obj.ref5ab7f197 = (*C.BoneInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoneInfo) PassRef() (*C.BoneInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ab7f197 != nil {
		return x.ref5ab7f197, nil
	}
	mem5ab7f197 := unsafe.Pointer(new(C.BoneInfo))
	ref5ab7f197 := (*C.BoneInfo)(mem5ab7f197)
	allocs5ab7f197 := new(cgoAllocMap)
	// allocs5ab7f197.Add(mem5ab7f197)

	var cname_allocs *cgoAllocMap
	ref5ab7f197.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.gName)), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cname_allocs)
	x.gName = *new([32]byte)

	var cparent_allocs *cgoAllocMap
	ref5ab7f197.parent, cparent_allocs = (C.int)(x.gParent), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cparent_allocs)
	x.gParent = *new(int32)

	x.ref5ab7f197 = ref5ab7f197
	x.allocs5ab7f197 = allocs5ab7f197
	defer func() {
		if len(x.allocs5ab7f197.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeBoneInfo)
		}
	}()
	return ref5ab7f197, allocs5ab7f197

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoneInfo) PassValue() (C.BoneInfo, *cgoAllocMap) {
	if x.ref5ab7f197 != nil {
		return *x.ref5ab7f197, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *BoneInfo) Convert() *boneInfo {
	if x.ref5ab7f197 != nil {
		return (*boneInfo)(unsafe.Pointer(x.ref5ab7f197))
	}
	x.PassRef()
	return (*boneInfo)(unsafe.Pointer(x.ref5ab7f197))
}

// allocModelMemory allocates memory for type C.Model in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelValue = unsafe.Sizeof([1]C.Model{})

// unpackSMesh transforms a sliced Go data structure into plain C format.
func unpackSMesh(x []Mesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackSMaterial transforms a sliced Go data structure into plain C format.
func unpackSMaterial(x []Material) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackSBoneInfo transforms a sliced Go data structure into plain C format.
func unpackSBoneInfo(x []BoneInfo) (unpacked *C.BoneInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.BoneInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBoneInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BoneInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BoneInfo)(h.Data)
	return
}

// unpackSTransform transforms a sliced Go data structure into plain C format.
func unpackSTransform(x []Transform) (unpacked *C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Transform)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Model) Ref() *C.Model {
	if x == nil {
		return nil
	}
	return x.ref16545ddd
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Model) ResetRef() {
	if x == nil {
		return
	}
	x.ref16545ddd = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Model) FreeRef() {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
		return
	}
	if x != nil && x.ref16545ddd != nil && x.allocs16545ddd == nil {
		C.free(unsafe.Pointer(x.ref16545ddd))
		x.ref16545ddd = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeModel(x *Model) {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
		// fmt.Printf("Model memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs16545ddd.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Model memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewModel new Go object and Mapping to C object.
func NewModel(gTransform Matrix, gMeshCount int32, gMeshes []Mesh, gMaterialCount int32, gMaterials []Material, gMeshMaterial []int32, gBoneCount int32, gBones []BoneInfo, gBindPose []Transform) Model {
	obj := *new(Model)
	obj.gTransform = gTransform
	obj.gMeshCount = gMeshCount
	obj.gMeshes = gMeshes
	obj.gMaterialCount = gMaterialCount
	obj.gMaterials = gMaterials
	obj.gMeshMaterial = gMeshMaterial
	obj.gBoneCount = gBoneCount
	obj.gBones = gBones
	obj.gBindPose = gBindPose
	return obj
}

// NewModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelRef(ref unsafe.Pointer) *Model {
	if ref == nil {
		return nil
	}
	obj := new(Model)
	obj.ref16545ddd = (*C.Model)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Model) PassRef() (*C.Model, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16545ddd != nil {
		return x.ref16545ddd, nil
	}
	mem16545ddd := unsafe.Pointer(new(C.Model))
	ref16545ddd := (*C.Model)(mem16545ddd)
	allocs16545ddd := new(cgoAllocMap)
	// allocs16545ddd.Add(mem16545ddd)

	var ctransform_allocs *cgoAllocMap
	ref16545ddd.transform, ctransform_allocs = x.gTransform.PassValue()
	allocs16545ddd.Borrow(ctransform_allocs)
	x.gTransform = *new(Matrix)

	var cmeshCount_allocs *cgoAllocMap
	ref16545ddd.meshCount, cmeshCount_allocs = (C.int)(x.gMeshCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshCount_allocs)
	x.gMeshCount = *new(int32)

	var cmeshes_allocs *cgoAllocMap
	ref16545ddd.meshes, cmeshes_allocs = unpackSMesh(x.gMeshes)
	allocs16545ddd.Borrow(cmeshes_allocs)
	x.gMeshes = *new([]Mesh)

	var cmaterialCount_allocs *cgoAllocMap
	ref16545ddd.materialCount, cmaterialCount_allocs = (C.int)(x.gMaterialCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmaterialCount_allocs)
	x.gMaterialCount = *new(int32)

	var cmaterials_allocs *cgoAllocMap
	ref16545ddd.materials, cmaterials_allocs = unpackSMaterial(x.gMaterials)
	allocs16545ddd.Borrow(cmaterials_allocs)
	x.gMaterials = *new([]Material)

	var cmeshMaterial_allocs *cgoAllocMap
	ref16545ddd.meshMaterial, cmeshMaterial_allocs = (*C.int)(unsafe.Pointer((*sliceHeader)(unsafe.Pointer(&x.gMeshMaterial)).Data)), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshMaterial_allocs)
	x.gMeshMaterial = *new([]int32)

	var cboneCount_allocs *cgoAllocMap
	ref16545ddd.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref16545ddd.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs16545ddd.Borrow(cbones_allocs)
	x.gBones = *new([]BoneInfo)

	var cbindPose_allocs *cgoAllocMap
	ref16545ddd.bindPose, cbindPose_allocs = unpackSTransform(x.gBindPose)
	allocs16545ddd.Borrow(cbindPose_allocs)
	x.gBindPose = *new([]Transform)

	x.ref16545ddd = ref16545ddd
	x.allocs16545ddd = allocs16545ddd
	defer func() {
		if len(x.allocs16545ddd.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeModel)
		}
	}()
	return ref16545ddd, allocs16545ddd

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Model) PassValue() (C.Model, *cgoAllocMap) {
	if x.ref16545ddd != nil {
		return *x.ref16545ddd, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Model) Convert() *model {
	if x.ref16545ddd != nil {
		return (*model)(unsafe.Pointer(x.ref16545ddd))
	}
	x.PassRef()
	return (*model)(unsafe.Pointer(x.ref16545ddd))
}

// GetTransform returns a reference to C object within a struct
func (s *Model) GetTransform() *Matrix {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Matrix
	ret = NewMatrixRef(unsafe.Pointer(&s.Ref().transform))
	return ret
}

// GetMeshes returns a reference to C object within a struct
func (s *Model) GetMeshes(meshesIndex int32) *Mesh {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Mesh
	// c struct pointer offset
	ptr0 := s.Ref().meshes
	ptr1 := (*C.Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(meshesIndex)*uintptr(sizeOfMeshValue)))

	ret = NewMeshRef(unsafe.Pointer(ptr1))
	return ret
}

// GetMaterials returns a reference to C object within a struct
func (s *Model) GetMaterials(materialsIndex int32) *Material {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Material
	// c struct pointer offset
	ptr0 := s.Ref().materials
	ptr1 := (*C.Material)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(materialsIndex)*uintptr(sizeOfMaterialValue)))

	ret = NewMaterialRef(unsafe.Pointer(ptr1))
	return ret
}

// GetMeshMaterial returns a reference to C object within a struct
func (s *Model) GetMeshMaterial(meshMaterialCount int32) []*int32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []*int32

	const sizeOfPlainValue = unsafe.Sizeof([1]C.int{})
	ret = make([]*int32, meshMaterialCount)
	ptr0 := s.Ref().meshMaterial
	// c struct pointer offset
	for i0 := range ret {
		ptr1 := (*C.int)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfPlainValue)))
		ret[i0] = (*int32)(unsafe.Pointer(ptr1))
	}
	return ret
}

// GetBones returns a reference to C object within a struct
func (s *Model) GetBones(bonesIndex int32) *BoneInfo {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *BoneInfo
	// c struct pointer offset
	ptr0 := s.Ref().bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bonesIndex)*uintptr(sizeOfBoneInfoValue)))

	ret = NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// GetBindPose returns a reference to C object within a struct
func (s *Model) GetBindPose(bindPoseIndex int32) *Transform {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Transform
	// c struct pointer offset
	ptr0 := s.Ref().bindPose
	ptr1 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bindPoseIndex)*uintptr(sizeOfTransformValue)))

	ret = NewTransformRef(unsafe.Pointer(ptr1))
	return ret
}

// allocModelAnimationMemory allocates memory for type C.ModelAnimation in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelAnimationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelAnimationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelAnimationValue = unsafe.Sizeof([1]C.ModelAnimation{})

// allocPTransformMemory allocates memory for type *C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTransformValue = unsafe.Sizeof([1]*C.Transform{})

// unpackSSTransform transforms a sliced Go data structure into plain C format.
func unpackSSTransform(x [][]Transform) (unpacked **C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTransformMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Transform)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Transform)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Transform)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *ModelAnimation) Ref() *C.ModelAnimation {
	if x == nil {
		return nil
	}
	return x.ref26dd6a24
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *ModelAnimation) ResetRef() {
	if x == nil {
		return
	}
	x.ref26dd6a24 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *ModelAnimation) FreeRef() {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
		return
	}
	if x != nil && x.ref26dd6a24 != nil && x.allocs26dd6a24 == nil {
		C.free(unsafe.Pointer(x.ref26dd6a24))
		x.ref26dd6a24 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeModelAnimation(x *ModelAnimation) {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
		// fmt.Printf("ModelAnimation memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs26dd6a24.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.ModelAnimation memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewModelAnimation new Go object and Mapping to C object.
func NewModelAnimation(gBoneCount int32, gBones []BoneInfo, gFrameCount int32, gFramePoses [][]Transform) ModelAnimation {
	obj := *new(ModelAnimation)
	obj.gBoneCount = gBoneCount
	obj.gBones = gBones
	obj.gFrameCount = gFrameCount
	obj.gFramePoses = gFramePoses
	return obj
}

// NewModelAnimationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewModelAnimationRef(ref unsafe.Pointer) *ModelAnimation {
	if ref == nil {
		return nil
	}
	obj := new(ModelAnimation)
	obj.ref26dd6a24 = (*C.ModelAnimation)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *ModelAnimation) PassRef() (*C.ModelAnimation, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26dd6a24 != nil {
		return x.ref26dd6a24, nil
	}
	mem26dd6a24 := unsafe.Pointer(new(C.ModelAnimation))
	ref26dd6a24 := (*C.ModelAnimation)(mem26dd6a24)
	allocs26dd6a24 := new(cgoAllocMap)
	// allocs26dd6a24.Add(mem26dd6a24)

	var cboneCount_allocs *cgoAllocMap
	ref26dd6a24.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref26dd6a24.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs26dd6a24.Borrow(cbones_allocs)
	x.gBones = *new([]BoneInfo)

	var cframeCount_allocs *cgoAllocMap
	ref26dd6a24.frameCount, cframeCount_allocs = (C.int)(x.gFrameCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cframeCount_allocs)
	x.gFrameCount = *new(int32)

	var cframePoses_allocs *cgoAllocMap
	ref26dd6a24.framePoses, cframePoses_allocs = unpackSSTransform(x.gFramePoses)
	allocs26dd6a24.Borrow(cframePoses_allocs)
	x.gFramePoses = *new([][]Transform)

	x.ref26dd6a24 = ref26dd6a24
	x.allocs26dd6a24 = allocs26dd6a24
	defer func() {
		if len(x.allocs26dd6a24.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeModelAnimation)
		}
	}()
	return ref26dd6a24, allocs26dd6a24

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x ModelAnimation) PassValue() (C.ModelAnimation, *cgoAllocMap) {
	if x.ref26dd6a24 != nil {
		return *x.ref26dd6a24, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *ModelAnimation) Convert() *modelAnimation {
	if x.ref26dd6a24 != nil {
		return (*modelAnimation)(unsafe.Pointer(x.ref26dd6a24))
	}
	x.PassRef()
	return (*modelAnimation)(unsafe.Pointer(x.ref26dd6a24))
}

// GetBones returns a reference to C object within a struct
func (s *ModelAnimation) GetBones(bonesIndex int32) *BoneInfo {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *BoneInfo
	// c struct pointer offset
	ptr0 := s.Ref().bones
	ptr1 := (*C.BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bonesIndex)*uintptr(sizeOfBoneInfoValue)))

	ret = NewBoneInfoRef(unsafe.Pointer(ptr1))
	return ret
}

// GetFramePoses returns a reference to C object within a struct
func (s *ModelAnimation) GetFramePoses(framePosesRow int32, framePosesColumn int32) *Transform {
	if s.Ref() == nil {
		s.PassRef()
	}

	row, column := framePosesRow, framePosesColumn
	var ret *Transform
	ptr0 := s.Ref().framePoses
	ptr1 := (**C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(row)*uintptr(sizeOfPtr)))
	ptr2 := (*C.Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(*ptr1)) + uintptr(column)*uintptr(sizeOfTransformValue)))
	ret = NewTransformRef(unsafe.Pointer(ptr2))

	return ret
}

// allocRayMemory allocates memory for type C.Ray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayValue = unsafe.Sizeof([1]C.Ray{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Ray) Ref() *C.Ray {
	if x == nil {
		return nil
	}
	return x.refc546b0b2
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Ray) ResetRef() {
	if x == nil {
		return
	}
	x.refc546b0b2 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Ray) FreeRef() {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
		return
	}
	if x != nil && x.refc546b0b2 != nil && x.allocsc546b0b2 == nil {
		C.free(unsafe.Pointer(x.refc546b0b2))
		x.refc546b0b2 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRay(x *Ray) {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
		// fmt.Printf("Ray memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc546b0b2.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Ray memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRay new Go object and Mapping to C object.
func NewRay(gPosition Vector3, gDirection Vector3) Ray {
	obj := *new(Ray)
	obj.gPosition = gPosition
	obj.gDirection = gDirection
	return obj
}

// NewRayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayRef(ref unsafe.Pointer) *Ray {
	if ref == nil {
		return nil
	}
	obj := new(Ray)
	obj.refc546b0b2 = (*C.Ray)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Ray) PassRef() (*C.Ray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc546b0b2 != nil {
		return x.refc546b0b2, nil
	}
	memc546b0b2 := unsafe.Pointer(new(C.Ray))
	refc546b0b2 := (*C.Ray)(memc546b0b2)
	allocsc546b0b2 := new(cgoAllocMap)
	// allocsc546b0b2.Add(memc546b0b2)

	var cposition_allocs *cgoAllocMap
	refc546b0b2.position, cposition_allocs = x.gPosition.PassValue()
	allocsc546b0b2.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var cdirection_allocs *cgoAllocMap
	refc546b0b2.direction, cdirection_allocs = x.gDirection.PassValue()
	allocsc546b0b2.Borrow(cdirection_allocs)
	x.gDirection = *new(Vector3)

	x.refc546b0b2 = refc546b0b2
	x.allocsc546b0b2 = allocsc546b0b2
	defer func() {
		if len(x.allocsc546b0b2.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRay)
		}
	}()
	return refc546b0b2, allocsc546b0b2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Ray) PassValue() (C.Ray, *cgoAllocMap) {
	if x.refc546b0b2 != nil {
		return *x.refc546b0b2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Ray) Convert() *ray {
	if x.refc546b0b2 != nil {
		return (*ray)(unsafe.Pointer(x.refc546b0b2))
	}
	x.PassRef()
	return (*ray)(unsafe.Pointer(x.refc546b0b2))
}

// GetPosition returns a reference to C object within a struct
func (s *Ray) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetDirection returns a reference to C object within a struct
func (s *Ray) GetDirection() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().direction))
	return ret
}

// allocRayHitInfoMemory allocates memory for type C.RayHitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayHitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayHitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayHitInfoValue = unsafe.Sizeof([1]C.RayHitInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *RayHitInfo) Ref() *C.RayHitInfo {
	if x == nil {
		return nil
	}
	return x.refb8de43a9
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *RayHitInfo) ResetRef() {
	if x == nil {
		return
	}
	x.refb8de43a9 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *RayHitInfo) FreeRef() {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
		return
	}
	if x != nil && x.refb8de43a9 != nil && x.allocsb8de43a9 == nil {
		C.free(unsafe.Pointer(x.refb8de43a9))
		x.refb8de43a9 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRayHitInfo(x *RayHitInfo) {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
		// fmt.Printf("RayHitInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsb8de43a9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.RayHitInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRayHitInfo new Go object and Mapping to C object.
func NewRayHitInfo(gHit bool, gDistance float32, gPosition Vector3, gNormal Vector3) RayHitInfo {
	obj := *new(RayHitInfo)
	obj.gHit = gHit
	obj.gDistance = gDistance
	obj.gPosition = gPosition
	obj.gNormal = gNormal
	return obj
}

// NewRayHitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRayHitInfoRef(ref unsafe.Pointer) *RayHitInfo {
	if ref == nil {
		return nil
	}
	obj := new(RayHitInfo)
	obj.refb8de43a9 = (*C.RayHitInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *RayHitInfo) PassRef() (*C.RayHitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8de43a9 != nil {
		return x.refb8de43a9, nil
	}
	memb8de43a9 := unsafe.Pointer(new(C.RayHitInfo))
	refb8de43a9 := (*C.RayHitInfo)(memb8de43a9)
	allocsb8de43a9 := new(cgoAllocMap)
	// allocsb8de43a9.Add(memb8de43a9)

	var chit_allocs *cgoAllocMap
	refb8de43a9.hit, chit_allocs = (C._Bool)(x.gHit), cgoAllocsUnknown
	allocsb8de43a9.Borrow(chit_allocs)
	x.gHit = *new(bool)

	var cdistance_allocs *cgoAllocMap
	refb8de43a9.distance, cdistance_allocs = (C.float)(x.gDistance), cgoAllocsUnknown
	allocsb8de43a9.Borrow(cdistance_allocs)
	x.gDistance = *new(float32)

	var cposition_allocs *cgoAllocMap
	refb8de43a9.position, cposition_allocs = x.gPosition.PassValue()
	allocsb8de43a9.Borrow(cposition_allocs)
	x.gPosition = *new(Vector3)

	var cnormal_allocs *cgoAllocMap
	refb8de43a9.normal, cnormal_allocs = x.gNormal.PassValue()
	allocsb8de43a9.Borrow(cnormal_allocs)
	x.gNormal = *new(Vector3)

	x.refb8de43a9 = refb8de43a9
	x.allocsb8de43a9 = allocsb8de43a9
	defer func() {
		if len(x.allocsb8de43a9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRayHitInfo)
		}
	}()
	return refb8de43a9, allocsb8de43a9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x RayHitInfo) PassValue() (C.RayHitInfo, *cgoAllocMap) {
	if x.refb8de43a9 != nil {
		return *x.refb8de43a9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *RayHitInfo) Convert() *rayHitInfo {
	if x.refb8de43a9 != nil {
		return (*rayHitInfo)(unsafe.Pointer(x.refb8de43a9))
	}
	x.PassRef()
	return (*rayHitInfo)(unsafe.Pointer(x.refb8de43a9))
}

// GetPosition returns a reference to C object within a struct
func (s *RayHitInfo) GetPosition() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// GetNormal returns a reference to C object within a struct
func (s *RayHitInfo) GetNormal() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().normal))
	return ret
}

// allocBoundingBoxMemory allocates memory for type C.BoundingBox in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoundingBoxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoundingBoxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoundingBoxValue = unsafe.Sizeof([1]C.BoundingBox{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *BoundingBox) Ref() *C.BoundingBox {
	if x == nil {
		return nil
	}
	return x.refa54e9d16
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *BoundingBox) ResetRef() {
	if x == nil {
		return
	}
	x.refa54e9d16 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *BoundingBox) FreeRef() {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
		return
	}
	if x != nil && x.refa54e9d16 != nil && x.allocsa54e9d16 == nil {
		C.free(unsafe.Pointer(x.refa54e9d16))
		x.refa54e9d16 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeBoundingBox(x *BoundingBox) {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
		// fmt.Printf("BoundingBox memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa54e9d16.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.BoundingBox memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewBoundingBox new Go object and Mapping to C object.
func NewBoundingBox(gMin Vector3, gMax Vector3) BoundingBox {
	obj := *new(BoundingBox)
	obj.gMin = gMin
	obj.gMax = gMax
	return obj
}

// NewBoundingBoxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewBoundingBoxRef(ref unsafe.Pointer) *BoundingBox {
	if ref == nil {
		return nil
	}
	obj := new(BoundingBox)
	obj.refa54e9d16 = (*C.BoundingBox)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *BoundingBox) PassRef() (*C.BoundingBox, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54e9d16 != nil {
		return x.refa54e9d16, nil
	}
	mema54e9d16 := unsafe.Pointer(new(C.BoundingBox))
	refa54e9d16 := (*C.BoundingBox)(mema54e9d16)
	allocsa54e9d16 := new(cgoAllocMap)
	// allocsa54e9d16.Add(mema54e9d16)

	var cmin_allocs *cgoAllocMap
	refa54e9d16.min, cmin_allocs = x.gMin.PassValue()
	allocsa54e9d16.Borrow(cmin_allocs)
	x.gMin = *new(Vector3)

	var cmax_allocs *cgoAllocMap
	refa54e9d16.max, cmax_allocs = x.gMax.PassValue()
	allocsa54e9d16.Borrow(cmax_allocs)
	x.gMax = *new(Vector3)

	x.refa54e9d16 = refa54e9d16
	x.allocsa54e9d16 = allocsa54e9d16
	defer func() {
		if len(x.allocsa54e9d16.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeBoundingBox)
		}
	}()
	return refa54e9d16, allocsa54e9d16

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x BoundingBox) PassValue() (C.BoundingBox, *cgoAllocMap) {
	if x.refa54e9d16 != nil {
		return *x.refa54e9d16, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *BoundingBox) Convert() *boundingBox {
	if x.refa54e9d16 != nil {
		return (*boundingBox)(unsafe.Pointer(x.refa54e9d16))
	}
	x.PassRef()
	return (*boundingBox)(unsafe.Pointer(x.refa54e9d16))
}

// GetMin returns a reference to C object within a struct
func (s *BoundingBox) GetMin() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().min))
	return ret
}

// GetMax returns a reference to C object within a struct
func (s *BoundingBox) GetMax() *Vector3 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector3
	ret = NewVector3Ref(unsafe.Pointer(&s.Ref().max))
	return ret
}

// allocWaveMemory allocates memory for type C.Wave in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWaveValue = unsafe.Sizeof([1]C.Wave{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Wave) Ref() *C.Wave {
	if x == nil {
		return nil
	}
	return x.ref7a3602b7
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Wave) ResetRef() {
	if x == nil {
		return
	}
	x.ref7a3602b7 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Wave) FreeRef() {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
		return
	}
	if x != nil && x.ref7a3602b7 != nil && x.allocs7a3602b7 == nil {
		C.free(unsafe.Pointer(x.ref7a3602b7))
		x.ref7a3602b7 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeWave(x *Wave) {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
		// fmt.Printf("Wave memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs7a3602b7.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Wave memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewWave new Go object and Mapping to C object.
func NewWave(gSampleCount uint32, gSampleRate uint32, gSampleSize uint32, gChannels uint32, gData unsafe.Pointer) Wave {
	obj := *new(Wave)
	obj.gSampleCount = gSampleCount
	obj.gSampleRate = gSampleRate
	obj.gSampleSize = gSampleSize
	obj.gChannels = gChannels
	obj.gData = gData
	return obj
}

// NewWaveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewWaveRef(ref unsafe.Pointer) *Wave {
	if ref == nil {
		return nil
	}
	obj := new(Wave)
	obj.ref7a3602b7 = (*C.Wave)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Wave) PassRef() (*C.Wave, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a3602b7 != nil {
		return x.ref7a3602b7, nil
	}
	mem7a3602b7 := unsafe.Pointer(new(C.Wave))
	ref7a3602b7 := (*C.Wave)(mem7a3602b7)
	allocs7a3602b7 := new(cgoAllocMap)
	// allocs7a3602b7.Add(mem7a3602b7)

	var csampleCount_allocs *cgoAllocMap
	ref7a3602b7.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var csampleRate_allocs *cgoAllocMap
	ref7a3602b7.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref7a3602b7.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref7a3602b7.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	var cdata_allocs *cgoAllocMap
	ref7a3602b7.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	x.ref7a3602b7 = ref7a3602b7
	x.allocs7a3602b7 = allocs7a3602b7
	defer func() {
		if len(x.allocs7a3602b7.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeWave)
		}
	}()
	return ref7a3602b7, allocs7a3602b7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Wave) PassValue() (C.Wave, *cgoAllocMap) {
	if x.ref7a3602b7 != nil {
		return *x.ref7a3602b7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Wave) Convert() *wave {
	if x.ref7a3602b7 != nil {
		return (*wave)(unsafe.Pointer(x.ref7a3602b7))
	}
	x.PassRef()
	return (*wave)(unsafe.Pointer(x.ref7a3602b7))
}

// allocAudioStreamMemory allocates memory for type C.AudioStream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAudioStreamValue = unsafe.Sizeof([1]C.AudioStream{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *AudioStream) Ref() *C.AudioStream {
	if x == nil {
		return nil
	}
	return x.ref997374a2
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *AudioStream) ResetRef() {
	if x == nil {
		return
	}
	x.ref997374a2 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *AudioStream) FreeRef() {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
		return
	}
	if x != nil && x.ref997374a2 != nil && x.allocs997374a2 == nil {
		C.free(unsafe.Pointer(x.ref997374a2))
		x.ref997374a2 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeAudioStream(x *AudioStream) {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
		// fmt.Printf("AudioStream memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs997374a2.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.AudioStream memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewAudioStream new Go object and Mapping to C object.
func NewAudioStream(gSampleRate uint32, gSampleSize uint32, gChannels uint32) AudioStream {
	obj := *new(AudioStream)
	obj.gSampleRate = gSampleRate
	obj.gSampleSize = gSampleSize
	obj.gChannels = gChannels
	return obj
}

// NewAudioStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewAudioStreamRef(ref unsafe.Pointer) *AudioStream {
	if ref == nil {
		return nil
	}
	obj := new(AudioStream)
	obj.ref997374a2 = (*C.AudioStream)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *AudioStream) PassRef() (*C.AudioStream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref997374a2 != nil {
		return x.ref997374a2, nil
	}
	mem997374a2 := unsafe.Pointer(new(C.AudioStream))
	ref997374a2 := (*C.AudioStream)(mem997374a2)
	allocs997374a2 := new(cgoAllocMap)
	// allocs997374a2.Add(mem997374a2)

	var csampleRate_allocs *cgoAllocMap
	ref997374a2.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref997374a2.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref997374a2.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs997374a2.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	x.ref997374a2 = ref997374a2
	x.allocs997374a2 = allocs997374a2
	defer func() {
		if len(x.allocs997374a2.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeAudioStream)
		}
	}()
	return ref997374a2, allocs997374a2

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x AudioStream) PassValue() (C.AudioStream, *cgoAllocMap) {
	if x.ref997374a2 != nil {
		return *x.ref997374a2, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *AudioStream) Convert() *audioStream {
	if x.ref997374a2 != nil {
		return (*audioStream)(unsafe.Pointer(x.ref997374a2))
	}
	x.PassRef()
	return (*audioStream)(unsafe.Pointer(x.ref997374a2))
}

// allocSoundMemory allocates memory for type C.Sound in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSoundMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSoundValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSoundValue = unsafe.Sizeof([1]C.Sound{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Sound) Ref() *C.Sound {
	if x == nil {
		return nil
	}
	return x.ref394fec80
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Sound) ResetRef() {
	if x == nil {
		return
	}
	x.ref394fec80 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Sound) FreeRef() {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
		return
	}
	if x != nil && x.ref394fec80 != nil && x.allocs394fec80 == nil {
		C.free(unsafe.Pointer(x.ref394fec80))
		x.ref394fec80 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeSound(x *Sound) {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
		// fmt.Printf("Sound memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs394fec80.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Sound memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewSound new Go object and Mapping to C object.
func NewSound(gSampleCount uint32, gStream AudioStream) Sound {
	obj := *new(Sound)
	obj.gSampleCount = gSampleCount
	obj.gStream = gStream
	return obj
}

// NewSoundRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewSoundRef(ref unsafe.Pointer) *Sound {
	if ref == nil {
		return nil
	}
	obj := new(Sound)
	obj.ref394fec80 = (*C.Sound)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Sound) PassRef() (*C.Sound, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394fec80 != nil {
		return x.ref394fec80, nil
	}
	mem394fec80 := unsafe.Pointer(new(C.Sound))
	ref394fec80 := (*C.Sound)(mem394fec80)
	allocs394fec80 := new(cgoAllocMap)
	// allocs394fec80.Add(mem394fec80)

	var csampleCount_allocs *cgoAllocMap
	ref394fec80.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs394fec80.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	ref394fec80.stream, cstream_allocs = x.gStream.PassValue()
	allocs394fec80.Borrow(cstream_allocs)
	x.gStream = *new(AudioStream)

	x.ref394fec80 = ref394fec80
	x.allocs394fec80 = allocs394fec80
	defer func() {
		if len(x.allocs394fec80.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeSound)
		}
	}()
	return ref394fec80, allocs394fec80

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Sound) PassValue() (C.Sound, *cgoAllocMap) {
	if x.ref394fec80 != nil {
		return *x.ref394fec80, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Sound) Convert() *sound {
	if x.ref394fec80 != nil {
		return (*sound)(unsafe.Pointer(x.ref394fec80))
	}
	x.PassRef()
	return (*sound)(unsafe.Pointer(x.ref394fec80))
}

// GetStream returns a reference to C object within a struct
func (s *Sound) GetStream() *AudioStream {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *AudioStream
	ret = NewAudioStreamRef(unsafe.Pointer(&s.Ref().stream))
	return ret
}

// allocMusicMemory allocates memory for type C.Music in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMusicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMusicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMusicValue = unsafe.Sizeof([1]C.Music{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Music) Ref() *C.Music {
	if x == nil {
		return nil
	}
	return x.refc930d4e
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Music) ResetRef() {
	if x == nil {
		return
	}
	x.refc930d4e = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Music) FreeRef() {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
		return
	}
	if x != nil && x.refc930d4e != nil && x.allocsc930d4e == nil {
		C.free(unsafe.Pointer(x.refc930d4e))
		x.refc930d4e = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMusic(x *Music) {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
		// fmt.Printf("Music memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsc930d4e.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Music memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMusic new Go object and Mapping to C object.
func NewMusic(gCtxType int32, gCtxData unsafe.Pointer, gLooping bool, gSampleCount uint32, gStream AudioStream) Music {
	obj := *new(Music)
	obj.gCtxType = gCtxType
	obj.gCtxData = gCtxData
	obj.gLooping = gLooping
	obj.gSampleCount = gSampleCount
	obj.gStream = gStream
	return obj
}

// NewMusicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMusicRef(ref unsafe.Pointer) *Music {
	if ref == nil {
		return nil
	}
	obj := new(Music)
	obj.refc930d4e = (*C.Music)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Music) PassRef() (*C.Music, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc930d4e != nil {
		return x.refc930d4e, nil
	}
	memc930d4e := unsafe.Pointer(new(C.Music))
	refc930d4e := (*C.Music)(memc930d4e)
	allocsc930d4e := new(cgoAllocMap)
	// allocsc930d4e.Add(memc930d4e)

	var cctxType_allocs *cgoAllocMap
	refc930d4e.ctxType, cctxType_allocs = (C.int)(x.gCtxType), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxType_allocs)
	x.gCtxType = *new(int32)

	var cctxData_allocs *cgoAllocMap
	refc930d4e.ctxData, cctxData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gCtxData)), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxData_allocs)
	x.gCtxData = *new(unsafe.Pointer)

	var clooping_allocs *cgoAllocMap
	refc930d4e.looping, clooping_allocs = (C._Bool)(x.gLooping), cgoAllocsUnknown
	allocsc930d4e.Borrow(clooping_allocs)
	x.gLooping = *new(bool)

	var csampleCount_allocs *cgoAllocMap
	refc930d4e.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	refc930d4e.stream, cstream_allocs = x.gStream.PassValue()
	allocsc930d4e.Borrow(cstream_allocs)
	x.gStream = *new(AudioStream)

	x.refc930d4e = refc930d4e
	x.allocsc930d4e = allocsc930d4e
	defer func() {
		if len(x.allocsc930d4e.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMusic)
		}
	}()
	return refc930d4e, allocsc930d4e

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Music) PassValue() (C.Music, *cgoAllocMap) {
	if x.refc930d4e != nil {
		return *x.refc930d4e, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Music) Convert() *music {
	if x.refc930d4e != nil {
		return (*music)(unsafe.Pointer(x.refc930d4e))
	}
	x.PassRef()
	return (*music)(unsafe.Pointer(x.refc930d4e))
}

// GetStream returns a reference to C object within a struct
func (s *Music) GetStream() *AudioStream {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *AudioStream
	ret = NewAudioStreamRef(unsafe.Pointer(&s.Ref().stream))
	return ret
}

// allocVrDeviceInfoMemory allocates memory for type C.VrDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVrDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVrDeviceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVrDeviceInfoValue = unsafe.Sizeof([1]C.VrDeviceInfo{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *VrDeviceInfo) Ref() *C.VrDeviceInfo {
	if x == nil {
		return nil
	}
	return x.ref6e24e41d
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *VrDeviceInfo) ResetRef() {
	if x == nil {
		return
	}
	x.ref6e24e41d = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *VrDeviceInfo) FreeRef() {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
		return
	}
	if x != nil && x.ref6e24e41d != nil && x.allocs6e24e41d == nil {
		C.free(unsafe.Pointer(x.ref6e24e41d))
		x.ref6e24e41d = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVrDeviceInfo(x *VrDeviceInfo) {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
		// fmt.Printf("VrDeviceInfo memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs6e24e41d.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.VrDeviceInfo memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVrDeviceInfo new Go object and Mapping to C object.
func NewVrDeviceInfo(gHResolution int32, gVResolution int32, gHScreenSize float32, gVScreenSize float32, gVScreenCenter float32, gEyeToScreenDistance float32, gLensSeparationDistance float32, gInterpupillaryDistance float32, gLensDistortionValues [4]float32, gChromaAbCorrection [4]float32) VrDeviceInfo {
	obj := *new(VrDeviceInfo)
	obj.gHResolution = gHResolution
	obj.gVResolution = gVResolution
	obj.gHScreenSize = gHScreenSize
	obj.gVScreenSize = gVScreenSize
	obj.gVScreenCenter = gVScreenCenter
	obj.gEyeToScreenDistance = gEyeToScreenDistance
	obj.gLensSeparationDistance = gLensSeparationDistance
	obj.gInterpupillaryDistance = gInterpupillaryDistance
	obj.gLensDistortionValues = gLensDistortionValues
	obj.gChromaAbCorrection = gChromaAbCorrection
	return obj
}

// NewVrDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVrDeviceInfoRef(ref unsafe.Pointer) *VrDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(VrDeviceInfo)
	obj.ref6e24e41d = (*C.VrDeviceInfo)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *VrDeviceInfo) PassRef() (*C.VrDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e24e41d != nil {
		return x.ref6e24e41d, nil
	}
	mem6e24e41d := unsafe.Pointer(new(C.VrDeviceInfo))
	ref6e24e41d := (*C.VrDeviceInfo)(mem6e24e41d)
	allocs6e24e41d := new(cgoAllocMap)
	// allocs6e24e41d.Add(mem6e24e41d)

	var chResolution_allocs *cgoAllocMap
	ref6e24e41d.hResolution, chResolution_allocs = (C.int)(x.gHResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chResolution_allocs)
	x.gHResolution = *new(int32)

	var cvResolution_allocs *cgoAllocMap
	ref6e24e41d.vResolution, cvResolution_allocs = (C.int)(x.gVResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvResolution_allocs)
	x.gVResolution = *new(int32)

	var chScreenSize_allocs *cgoAllocMap
	ref6e24e41d.hScreenSize, chScreenSize_allocs = (C.float)(x.gHScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chScreenSize_allocs)
	x.gHScreenSize = *new(float32)

	var cvScreenSize_allocs *cgoAllocMap
	ref6e24e41d.vScreenSize, cvScreenSize_allocs = (C.float)(x.gVScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenSize_allocs)
	x.gVScreenSize = *new(float32)

	var cvScreenCenter_allocs *cgoAllocMap
	ref6e24e41d.vScreenCenter, cvScreenCenter_allocs = (C.float)(x.gVScreenCenter), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenCenter_allocs)
	x.gVScreenCenter = *new(float32)

	var ceyeToScreenDistance_allocs *cgoAllocMap
	ref6e24e41d.eyeToScreenDistance, ceyeToScreenDistance_allocs = (C.float)(x.gEyeToScreenDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(ceyeToScreenDistance_allocs)
	x.gEyeToScreenDistance = *new(float32)

	var clensSeparationDistance_allocs *cgoAllocMap
	ref6e24e41d.lensSeparationDistance, clensSeparationDistance_allocs = (C.float)(x.gLensSeparationDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensSeparationDistance_allocs)
	x.gLensSeparationDistance = *new(float32)

	var cinterpupillaryDistance_allocs *cgoAllocMap
	ref6e24e41d.interpupillaryDistance, cinterpupillaryDistance_allocs = (C.float)(x.gInterpupillaryDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cinterpupillaryDistance_allocs)
	x.gInterpupillaryDistance = *new(float32)

	var clensDistortionValues_allocs *cgoAllocMap
	ref6e24e41d.lensDistortionValues, clensDistortionValues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gLensDistortionValues)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensDistortionValues_allocs)
	x.gLensDistortionValues = *new([4]float32)

	var cchromaAbCorrection_allocs *cgoAllocMap
	ref6e24e41d.chromaAbCorrection, cchromaAbCorrection_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gChromaAbCorrection)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cchromaAbCorrection_allocs)
	x.gChromaAbCorrection = *new([4]float32)

	x.ref6e24e41d = ref6e24e41d
	x.allocs6e24e41d = allocs6e24e41d
	defer func() {
		if len(x.allocs6e24e41d.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVrDeviceInfo)
		}
	}()
	return ref6e24e41d, allocs6e24e41d

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x VrDeviceInfo) PassValue() (C.VrDeviceInfo, *cgoAllocMap) {
	if x.ref6e24e41d != nil {
		return *x.ref6e24e41d, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *VrDeviceInfo) Convert() *vrDeviceInfo {
	if x.ref6e24e41d != nil {
		return (*vrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
	}
	x.PassRef()
	return (*vrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}

// packSSByte reads sliced Go data structure out from plain C format.
func packSSByte(v [][]byte, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		hxfc4425b := (*sliceHeader)(unsafe.Pointer(&v[i0]))
		hxfc4425b.Data = unsafe.Pointer(ptr1)
		hxfc4425b.Cap = 0x7fffffff
		// hxfc4425b.Len = ?
	}
}

// allocPRectangleMemory allocates memory for type *C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPRectangleValue = unsafe.Sizeof([1]*C.Rectangle{})

// unpackArgSSRectangle transforms a sliced Go data structure into plain C format.
func unpackArgSSRectangle(x [][]Rectangle) (unpacked **C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocRectangleMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Rectangle)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].PassValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Rectangle)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Rectangle)(h.Data)
	return
}

// packSSRectangle reads sliced Go data structure out from plain C format.
func packSSRectangle(v [][]Rectangle, ptr0 **C.Rectangle) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.Rectangle)(unsafe.Pointer(ptr0)))[i0]
		for i1 := range v[i0] {
			ptr2 := (*(*[m / sizeOfRectangleValue]C.Rectangle)(unsafe.Pointer(ptr1)))[i1]
			v[i0][i1] = *NewRectangleRef(unsafe.Pointer(&ptr2))
		}
	}
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// packSModelAnimation reads sliced Go data structure out from plain C format.
func packSModelAnimation(v []ModelAnimation, ptr0 *C.ModelAnimation) {
	// c struct pointer offset
	for i0 := range v {
		ptr1 := (*C.ModelAnimation)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfModelAnimationValue)))
		v[i0] = *NewModelAnimationRef(unsafe.Pointer(ptr1))
	}
}
