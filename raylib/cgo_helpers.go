// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 09 Sep 2020 15:11:07 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raylib

/*
#include "../lib/raylib/src/raylib.h"
#include "../lib/raylib/src/raymath.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)
var allocReferenceCount int

func init() {
	allocReferenceCount = 0
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	defer a.mux.Unlock()

	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	allocReferenceCount++
	fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory alloc\n", ptr)
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	defer a.mux.RUnlock()

	isEmpty := len(a.m) == 0
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}

	b.mux.Lock()
	defer b.mux.Unlock()
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)

		allocReferenceCount--
		fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory free\n", ptr)
	}
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearVector2Memory(x *gVector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		return
	}
}

// newVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector2Ref(ref unsafe.Pointer) *gVector2 {
	if ref == nil {
		return nil
	}
	obj := new(gVector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector2) passRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		if x.allocs29ca61a5 != nil {
			return x.ref29ca61a5, x.allocs29ca61a5.(*cgoAllocMap)
		} else {
			return x.ref29ca61a5, nil
		}
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5

	return ref29ca61a5, allocs29ca61a5
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector2) passValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gVector2) gc() {
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearVector2Memory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gVector2) convert() *Vector2 {
	if x.ref29ca61a5 != nil {
		return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.passRef()
	return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(vX float32, vY float32) Vector2 {
	obj := *new(gVector2)
	obj.gX = vX
	obj.gY = vY
	ret := obj.convert()
	return *(*Vector2)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Vector2) Index(index int32) *Vector2 {
	ptr1 := (*Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	return ptr1
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearVector3Memory(x *gVector3) {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		return
	}
}

// newVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector3Ref(ref unsafe.Pointer) *gVector3 {
	if ref == nil {
		return nil
	}
	obj := new(gVector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector3) passRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		if x.allocs5ecd5133 != nil {
			return x.ref5ecd5133, x.allocs5ecd5133.(*cgoAllocMap)
		} else {
			return x.ref5ecd5133, nil
		}
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.gZ = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133

	return ref5ecd5133, allocs5ecd5133
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector3) passValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gVector3) gc() {
	a := x.allocs5ecd5133.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearVector3Memory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gVector3) convert() *Vector3 {
	if x.ref5ecd5133 != nil {
		return (*Vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.passRef()
	return (*Vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// NewVector3 new Go object and Mapping to C object.
func NewVector3(vX float32, vY float32, vZ float32) Vector3 {
	obj := *new(gVector3)
	obj.gX = vX
	obj.gY = vY
	obj.gZ = vZ
	ret := obj.convert()
	return *(*Vector3)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Vector3) Index(index int32) *Vector3 {
	ptr1 := (*Vector3)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector3Value)))
	return ptr1
}

// allocVector4Memory allocates memory for type C.Vector4 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector4Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector4Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector4Value = unsafe.Sizeof([1]C.Vector4{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearVector4Memory(x *gVector4) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		return
	}
}

// newVector4Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector4Ref(ref unsafe.Pointer) *gVector4 {
	if ref == nil {
		return nil
	}
	obj := new(gVector4)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector4) passRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		if x.allocsc0a9c490 != nil {
			return x.refc0a9c490, x.allocsc0a9c490.(*cgoAllocMap)
		} else {
			return x.refc0a9c490, nil
		}
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490

	return refc0a9c490, allocsc0a9c490
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector4) passValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gVector4) gc() {
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearVector4Memory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gVector4) convert() *Vector4 {
	if x.refc0a9c490 != nil {
		return (*Vector4)(unsafe.Pointer(x.refc0a9c490))
	}
	x.passRef()
	return (*Vector4)(unsafe.Pointer(x.refc0a9c490))
}

// NewVector4 new Go object and Mapping to C object.
func NewVector4(vX float32, vY float32, vZ float32, vW float32) Vector4 {
	obj := *new(gVector4)
	obj.gX = vX
	obj.gY = vY
	obj.gZ = vZ
	obj.gW = vW
	ret := obj.convert()
	return *(*Vector4)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Vector4) Index(index int32) *Vector4 {
	ptr1 := (*Vector4)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector4Value)))
	return ptr1
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearQuaternionMemory(x *gQuaternion) {
	if x != nil && x.allocsc0a9c490 != nil {
		x.allocsc0a9c490.(*cgoAllocMap).Free()
		x.refc0a9c490 = nil
		return
	}
}

// newQuaternionRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newQuaternionRef(ref unsafe.Pointer) *gQuaternion {
	if ref == nil {
		return nil
	}
	obj := new(gQuaternion)
	obj.refc0a9c490 = (*C.Vector4)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gQuaternion) passRef() (*C.Vector4, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc0a9c490 != nil {
		if x.allocsc0a9c490 != nil {
			return x.refc0a9c490, x.allocsc0a9c490.(*cgoAllocMap)
		} else {
			return x.refc0a9c490, nil
		}
	}
	memc0a9c490 := unsafe.Pointer(new(C.Vector4))
	refc0a9c490 := (*C.Vector4)(memc0a9c490)
	allocsc0a9c490 := new(cgoAllocMap)
	// allocsc0a9c490.Add(memc0a9c490)

	var cx_allocs *cgoAllocMap
	refc0a9c490.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refc0a9c490.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	refc0a9c490.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cz_allocs)
	x.gZ = *new(float32)

	var cw_allocs *cgoAllocMap
	refc0a9c490.w, cw_allocs = (C.float)(x.gW), cgoAllocsUnknown
	allocsc0a9c490.Borrow(cw_allocs)
	x.gW = *new(float32)

	x.refc0a9c490 = refc0a9c490
	x.allocsc0a9c490 = allocsc0a9c490

	return refc0a9c490, allocsc0a9c490
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gQuaternion) passValue() (C.Vector4, *cgoAllocMap) {
	if x.refc0a9c490 != nil {
		return *x.refc0a9c490, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gQuaternion) gc() {
	a := x.allocsc0a9c490.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearQuaternionMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gQuaternion) convert() *Quaternion {
	if x.refc0a9c490 != nil {
		return (*Quaternion)(unsafe.Pointer(x.refc0a9c490))
	}
	x.passRef()
	return (*Quaternion)(unsafe.Pointer(x.refc0a9c490))
}

// NewQuaternion new Go object and Mapping to C object.
func NewQuaternion(vX float32, vY float32, vZ float32, vW float32) Quaternion {
	obj := *new(gQuaternion)
	obj.gX = vX
	obj.gY = vY
	obj.gZ = vZ
	obj.gW = vW
	ret := obj.convert()
	return *(*Quaternion)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Quaternion) Index(index int32) *Quaternion {
	ptr1 := (*Quaternion)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector4Value)))
	return ptr1
}

// allocMatrixMemory allocates memory for type C.Matrix in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrixMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrixValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrixValue = unsafe.Sizeof([1]C.Matrix{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearMatrixMemory(x *gMatrix) {
	if x != nil && x.allocsff9f44f9 != nil {
		x.allocsff9f44f9.(*cgoAllocMap).Free()
		x.refff9f44f9 = nil
		return
	}
}

// newMatrixRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMatrixRef(ref unsafe.Pointer) *gMatrix {
	if ref == nil {
		return nil
	}
	obj := new(gMatrix)
	obj.refff9f44f9 = (*C.Matrix)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMatrix) passRef() (*C.Matrix, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refff9f44f9 != nil {
		if x.allocsff9f44f9 != nil {
			return x.refff9f44f9, x.allocsff9f44f9.(*cgoAllocMap)
		} else {
			return x.refff9f44f9, nil
		}
	}
	memff9f44f9 := unsafe.Pointer(new(C.Matrix))
	refff9f44f9 := (*C.Matrix)(memff9f44f9)
	allocsff9f44f9 := new(cgoAllocMap)
	// allocsff9f44f9.Add(memff9f44f9)

	var cm0_allocs *cgoAllocMap
	refff9f44f9.m0, cm0_allocs = (C.float)(x.gM0), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm0_allocs)
	x.gM0 = *new(float32)

	var cm4_allocs *cgoAllocMap
	refff9f44f9.m4, cm4_allocs = (C.float)(x.gM4), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm4_allocs)
	x.gM4 = *new(float32)

	var cm8_allocs *cgoAllocMap
	refff9f44f9.m8, cm8_allocs = (C.float)(x.gM8), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm8_allocs)
	x.gM8 = *new(float32)

	var cm12_allocs *cgoAllocMap
	refff9f44f9.m12, cm12_allocs = (C.float)(x.gM12), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm12_allocs)
	x.gM12 = *new(float32)

	var cm1_allocs *cgoAllocMap
	refff9f44f9.m1, cm1_allocs = (C.float)(x.gM1), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm1_allocs)
	x.gM1 = *new(float32)

	var cm5_allocs *cgoAllocMap
	refff9f44f9.m5, cm5_allocs = (C.float)(x.gM5), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm5_allocs)
	x.gM5 = *new(float32)

	var cm9_allocs *cgoAllocMap
	refff9f44f9.m9, cm9_allocs = (C.float)(x.gM9), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm9_allocs)
	x.gM9 = *new(float32)

	var cm13_allocs *cgoAllocMap
	refff9f44f9.m13, cm13_allocs = (C.float)(x.gM13), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm13_allocs)
	x.gM13 = *new(float32)

	var cm2_allocs *cgoAllocMap
	refff9f44f9.m2, cm2_allocs = (C.float)(x.gM2), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm2_allocs)
	x.gM2 = *new(float32)

	var cm6_allocs *cgoAllocMap
	refff9f44f9.m6, cm6_allocs = (C.float)(x.gM6), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm6_allocs)
	x.gM6 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refff9f44f9.m10, cm10_allocs = (C.float)(x.gM10), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm10_allocs)
	x.gM10 = *new(float32)

	var cm14_allocs *cgoAllocMap
	refff9f44f9.m14, cm14_allocs = (C.float)(x.gM14), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm14_allocs)
	x.gM14 = *new(float32)

	var cm3_allocs *cgoAllocMap
	refff9f44f9.m3, cm3_allocs = (C.float)(x.gM3), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm3_allocs)
	x.gM3 = *new(float32)

	var cm7_allocs *cgoAllocMap
	refff9f44f9.m7, cm7_allocs = (C.float)(x.gM7), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm7_allocs)
	x.gM7 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refff9f44f9.m11, cm11_allocs = (C.float)(x.gM11), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm11_allocs)
	x.gM11 = *new(float32)

	var cm15_allocs *cgoAllocMap
	refff9f44f9.m15, cm15_allocs = (C.float)(x.gM15), cgoAllocsUnknown
	allocsff9f44f9.Borrow(cm15_allocs)
	x.gM15 = *new(float32)

	x.refff9f44f9 = refff9f44f9
	x.allocsff9f44f9 = allocsff9f44f9

	return refff9f44f9, allocsff9f44f9
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMatrix) passValue() (C.Matrix, *cgoAllocMap) {
	if x.refff9f44f9 != nil {
		return *x.refff9f44f9, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gMatrix) gc() {
	a := x.allocsff9f44f9.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearMatrixMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gMatrix) convert() *Matrix {
	if x.refff9f44f9 != nil {
		return (*Matrix)(unsafe.Pointer(x.refff9f44f9))
	}
	x.passRef()
	return (*Matrix)(unsafe.Pointer(x.refff9f44f9))
}

// NewMatrix new Go object and Mapping to C object.
func NewMatrix(vM0 float32, vM4 float32, vM8 float32, vM12 float32, vM1 float32, vM5 float32, vM9 float32, vM13 float32, vM2 float32, vM6 float32, vM10 float32, vM14 float32, vM3 float32, vM7 float32, vM11 float32, vM15 float32) Matrix {
	obj := *new(gMatrix)
	obj.gM0 = vM0
	obj.gM4 = vM4
	obj.gM8 = vM8
	obj.gM12 = vM12
	obj.gM1 = vM1
	obj.gM5 = vM5
	obj.gM9 = vM9
	obj.gM13 = vM13
	obj.gM2 = vM2
	obj.gM6 = vM6
	obj.gM10 = vM10
	obj.gM14 = vM14
	obj.gM3 = vM3
	obj.gM7 = vM7
	obj.gM11 = vM11
	obj.gM15 = vM15
	ret := obj.convert()
	return *(*Matrix)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Matrix) Index(index int32) *Matrix {
	ptr1 := (*Matrix)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMatrixValue)))
	return ptr1
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearColorMemory(x *gColor) {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		return
	}
}

// newColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newColorRef(ref unsafe.Pointer) *gColor {
	if ref == nil {
		return nil
	}
	obj := new(gColor)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gColor) passRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		if x.allocsa79767ed != nil {
			return x.refa79767ed, x.allocsa79767ed.(*cgoAllocMap)
		} else {
			return x.refa79767ed, nil
		}
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.gR), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.gR = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.gG), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.gG = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.gB), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.gB = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.gA), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.gA = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed

	return refa79767ed, allocsa79767ed
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gColor) passValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gColor) gc() {
	a := x.allocsa79767ed.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearColorMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gColor) convert() *Color {
	if x.refa79767ed != nil {
		return (*Color)(unsafe.Pointer(x.refa79767ed))
	}
	x.passRef()
	return (*Color)(unsafe.Pointer(x.refa79767ed))
}

// NewColor new Go object and Mapping to C object.
func NewColor(vR byte, vG byte, vB byte, vA byte) Color {
	obj := *new(gColor)
	obj.gR = vR
	obj.gG = vG
	obj.gB = vB
	obj.gA = vA
	ret := obj.convert()
	return *(*Color)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Color) Index(index int32) *Color {
	ptr1 := (*Color)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfColorValue)))
	return ptr1
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearRectangleMemory(x *gRectangle) {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		return
	}
}

// newRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRectangleRef(ref unsafe.Pointer) *gRectangle {
	if ref == nil {
		return nil
	}
	obj := new(gRectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRectangle) passRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		if x.allocscee8783a != nil {
			return x.refcee8783a, x.allocscee8783a.(*cgoAllocMap)
		} else {
			return x.refcee8783a, nil
		}
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.gWidth), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.gWidth = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.gHeight), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.gHeight = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a

	return refcee8783a, allocscee8783a
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRectangle) passValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gRectangle) gc() {
	a := x.allocscee8783a.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearRectangleMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gRectangle) convert() *Rectangle {
	if x.refcee8783a != nil {
		return (*Rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.passRef()
	return (*Rectangle)(unsafe.Pointer(x.refcee8783a))
}

// NewRectangle new Go object and Mapping to C object.
func NewRectangle(vX float32, vY float32, vWidth float32, vHeight float32) Rectangle {
	obj := *new(gRectangle)
	obj.gX = vX
	obj.gY = vY
	obj.gWidth = vWidth
	obj.gHeight = vHeight
	ret := obj.convert()
	return *(*Rectangle)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Rectangle) Index(index int32) *Rectangle {
	ptr1 := (*Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	return ptr1
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearImageMemory(x *gImage) {
	if x != nil && x.allocs4fc2b5b != nil {
		x.allocs4fc2b5b.(*cgoAllocMap).Free()
		x.ref4fc2b5b = nil
		return
	}
}

// newImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newImageRef(ref unsafe.Pointer) *gImage {
	if ref == nil {
		return nil
	}
	obj := new(gImage)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gImage) passRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		if x.allocs4fc2b5b != nil {
			return x.ref4fc2b5b, x.allocs4fc2b5b.(*cgoAllocMap)
		} else {
			return x.ref4fc2b5b, nil
		}
	}
	mem4fc2b5b := unsafe.Pointer(new(C.Image))
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	// allocs4fc2b5b.Add(mem4fc2b5b)

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b

	return ref4fc2b5b, allocs4fc2b5b
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gImage) passValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gImage) gc() {
	a := x.allocs4fc2b5b.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearImageMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gImage) convert() *Image {
	if x.ref4fc2b5b != nil {
		return (*Image)(unsafe.Pointer(x.ref4fc2b5b))
	}
	x.passRef()
	return (*Image)(unsafe.Pointer(x.ref4fc2b5b))
}

// NewImage new Go object and Mapping to C object.
func NewImage(vData unsafe.Pointer, vWidth int32, vHeight int32, vMipmaps int32, vFormat int32) Image {
	obj := *new(gImage)
	obj.gData = vData
	obj.gWidth = vWidth
	obj.gHeight = vHeight
	obj.gMipmaps = vMipmaps
	obj.gFormat = vFormat
	ret := obj.convert()
	return *(*Image)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Image) Index(index int32) *Image {
	ptr1 := (*Image)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfImageValue)))
	return ptr1
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearTexture2DMemory(x *gTexture2D) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
}

// newTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTexture2DRef(ref unsafe.Pointer) *gTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(gTexture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTexture2D) passRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		if x.allocs3c51a40b != nil {
			return x.ref3c51a40b, x.allocs3c51a40b.(*cgoAllocMap)
		} else {
			return x.ref3c51a40b, nil
		}
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b

	return ref3c51a40b, allocs3c51a40b
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTexture2D) passValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gTexture2D) gc() {
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearTexture2DMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gTexture2D) convert() *Texture2D {
	if x.ref3c51a40b != nil {
		return (*Texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.passRef()
	return (*Texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// NewTexture2D new Go object and Mapping to C object.
func NewTexture2D(vId uint32, vWidth int32, vHeight int32, vMipmaps int32, vFormat int32) Texture2D {
	obj := *new(gTexture2D)
	obj.gId = vId
	obj.gWidth = vWidth
	obj.gHeight = vHeight
	obj.gMipmaps = vMipmaps
	obj.gFormat = vFormat
	ret := obj.convert()
	return *(*Texture2D)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Texture2D) Index(index int32) *Texture2D {
	ptr1 := (*Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	return ptr1
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearTextureMemory(x *gTexture) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
}

// newTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTextureRef(ref unsafe.Pointer) *gTexture {
	if ref == nil {
		return nil
	}
	obj := new(gTexture)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTexture) passRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		if x.allocs3c51a40b != nil {
			return x.ref3c51a40b, x.allocs3c51a40b.(*cgoAllocMap)
		} else {
			return x.ref3c51a40b, nil
		}
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b

	return ref3c51a40b, allocs3c51a40b
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTexture) passValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gTexture) gc() {
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearTextureMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gTexture) convert() *Texture {
	if x.ref3c51a40b != nil {
		return (*Texture)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.passRef()
	return (*Texture)(unsafe.Pointer(x.ref3c51a40b))
}

// NewTexture new Go object and Mapping to C object.
func NewTexture(vId uint32, vWidth int32, vHeight int32, vMipmaps int32, vFormat int32) Texture {
	obj := *new(gTexture)
	obj.gId = vId
	obj.gWidth = vWidth
	obj.gHeight = vHeight
	obj.gMipmaps = vMipmaps
	obj.gFormat = vFormat
	ret := obj.convert()
	return *(*Texture)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Texture) Index(index int32) *Texture {
	ptr1 := (*Texture)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	return ptr1
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearTextureCubemapMemory(x *gTextureCubemap) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
}

// newTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTextureCubemapRef(ref unsafe.Pointer) *gTextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(gTextureCubemap)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTextureCubemap) passRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		if x.allocs3c51a40b != nil {
			return x.ref3c51a40b, x.allocs3c51a40b.(*cgoAllocMap)
		} else {
			return x.ref3c51a40b, nil
		}
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b

	return ref3c51a40b, allocs3c51a40b
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTextureCubemap) passValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gTextureCubemap) gc() {
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearTextureCubemapMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gTextureCubemap) convert() *TextureCubemap {
	if x.ref3c51a40b != nil {
		return (*TextureCubemap)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.passRef()
	return (*TextureCubemap)(unsafe.Pointer(x.ref3c51a40b))
}

// NewTextureCubemap new Go object and Mapping to C object.
func NewTextureCubemap(vId uint32, vWidth int32, vHeight int32, vMipmaps int32, vFormat int32) TextureCubemap {
	obj := *new(gTextureCubemap)
	obj.gId = vId
	obj.gWidth = vWidth
	obj.gHeight = vHeight
	obj.gMipmaps = vMipmaps
	obj.gFormat = vFormat
	ret := obj.convert()
	return *(*TextureCubemap)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *TextureCubemap) Index(index int32) *TextureCubemap {
	ptr1 := (*TextureCubemap)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	return ptr1
}

// allocRenderTexture2DMemory allocates memory for type C.RenderTexture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRenderTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRenderTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRenderTexture2DValue = unsafe.Sizeof([1]C.RenderTexture2D{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearRenderTexture2DMemory(x *gRenderTexture2D) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		return
	}
}

// newRenderTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRenderTexture2DRef(ref unsafe.Pointer) *gRenderTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(gRenderTexture2D)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRenderTexture2D) passRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		if x.allocs2f94e9e3 != nil {
			return x.ref2f94e9e3, x.allocs2f94e9e3.(*cgoAllocMap)
		} else {
			return x.ref2f94e9e3, nil
		}
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.gTexture.passValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.gDepth.passValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.gDepth = *new(gTexture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.gDepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.gDepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3

	return ref2f94e9e3, allocs2f94e9e3
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRenderTexture2D) passValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gRenderTexture2D) gc() {
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearRenderTexture2DMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gRenderTexture2D) convert() *RenderTexture2D {
	if x.ref2f94e9e3 != nil {
		return (*RenderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.passRef()
	return (*RenderTexture2D)(unsafe.Pointer(x.ref2f94e9e3))
}

// NewRenderTexture2D new Go object and Mapping to C object.
func NewRenderTexture2D(vId uint32, vTexture Texture2D, vDepth Texture2D, vDepthTexture bool) RenderTexture2D {
	obj := *new(gRenderTexture2D)
	obj.gId = vId
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&vTexture))
	obj.gDepth = *newTexture2DRef(unsafe.Pointer(&vDepth))
	obj.gDepthTexture = vDepthTexture
	ret := obj.convert()
	return *(*RenderTexture2D)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *RenderTexture2D) Index(index int32) *RenderTexture2D {
	ptr1 := (*RenderTexture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRenderTexture2DValue)))
	return ptr1
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearRenderTextureMemory(x *gRenderTexture) {
	if x != nil && x.allocs2f94e9e3 != nil {
		x.allocs2f94e9e3.(*cgoAllocMap).Free()
		x.ref2f94e9e3 = nil
		return
	}
}

// newRenderTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRenderTextureRef(ref unsafe.Pointer) *gRenderTexture {
	if ref == nil {
		return nil
	}
	obj := new(gRenderTexture)
	obj.ref2f94e9e3 = (*C.RenderTexture2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRenderTexture) passRef() (*C.RenderTexture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref2f94e9e3 != nil {
		if x.allocs2f94e9e3 != nil {
			return x.ref2f94e9e3, x.allocs2f94e9e3.(*cgoAllocMap)
		} else {
			return x.ref2f94e9e3, nil
		}
	}
	mem2f94e9e3 := unsafe.Pointer(new(C.RenderTexture2D))
	ref2f94e9e3 := (*C.RenderTexture2D)(mem2f94e9e3)
	allocs2f94e9e3 := new(cgoAllocMap)
	// allocs2f94e9e3.Add(mem2f94e9e3)

	var cid_allocs *cgoAllocMap
	ref2f94e9e3.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var ctexture_allocs *cgoAllocMap
	ref2f94e9e3.texture, ctexture_allocs = x.gTexture.passValue()
	allocs2f94e9e3.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var cdepth_allocs *cgoAllocMap
	ref2f94e9e3.depth, cdepth_allocs = x.gDepth.passValue()
	allocs2f94e9e3.Borrow(cdepth_allocs)
	x.gDepth = *new(gTexture2D)

	var cdepthTexture_allocs *cgoAllocMap
	ref2f94e9e3.depthTexture, cdepthTexture_allocs = (C._Bool)(x.gDepthTexture), cgoAllocsUnknown
	allocs2f94e9e3.Borrow(cdepthTexture_allocs)
	x.gDepthTexture = *new(bool)

	x.ref2f94e9e3 = ref2f94e9e3
	x.allocs2f94e9e3 = allocs2f94e9e3

	return ref2f94e9e3, allocs2f94e9e3
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRenderTexture) passValue() (C.RenderTexture2D, *cgoAllocMap) {
	if x.ref2f94e9e3 != nil {
		return *x.ref2f94e9e3, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gRenderTexture) gc() {
	a := x.allocs2f94e9e3.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearRenderTextureMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gRenderTexture) convert() *RenderTexture {
	if x.ref2f94e9e3 != nil {
		return (*RenderTexture)(unsafe.Pointer(x.ref2f94e9e3))
	}
	x.passRef()
	return (*RenderTexture)(unsafe.Pointer(x.ref2f94e9e3))
}

// NewRenderTexture new Go object and Mapping to C object.
func NewRenderTexture(vId uint32, vTexture Texture2D, vDepth Texture2D, vDepthTexture bool) RenderTexture {
	obj := *new(gRenderTexture)
	obj.gId = vId
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&vTexture))
	obj.gDepth = *newTexture2DRef(unsafe.Pointer(&vDepth))
	obj.gDepthTexture = vDepthTexture
	ret := obj.convert()
	return *(*RenderTexture)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *RenderTexture) Index(index int32) *RenderTexture {
	ptr1 := (*RenderTexture)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRenderTexture2DValue)))
	return ptr1
}

// allocNPatchInfoMemory allocates memory for type C.NPatchInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocNPatchInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfNPatchInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfNPatchInfoValue = unsafe.Sizeof([1]C.NPatchInfo{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearNPatchInfoMemory(x *gNPatchInfo) {
	if x != nil && x.allocs78104a03 != nil {
		x.allocs78104a03.(*cgoAllocMap).Free()
		x.ref78104a03 = nil
		return
	}
}

// newNPatchInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newNPatchInfoRef(ref unsafe.Pointer) *gNPatchInfo {
	if ref == nil {
		return nil
	}
	obj := new(gNPatchInfo)
	obj.ref78104a03 = (*C.NPatchInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gNPatchInfo) passRef() (*C.NPatchInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref78104a03 != nil {
		if x.allocs78104a03 != nil {
			return x.ref78104a03, x.allocs78104a03.(*cgoAllocMap)
		} else {
			return x.ref78104a03, nil
		}
	}
	mem78104a03 := unsafe.Pointer(new(C.NPatchInfo))
	ref78104a03 := (*C.NPatchInfo)(mem78104a03)
	allocs78104a03 := new(cgoAllocMap)
	// allocs78104a03.Add(mem78104a03)

	var csourceRec_allocs *cgoAllocMap
	ref78104a03.sourceRec, csourceRec_allocs = x.gSourceRec.passValue()
	allocs78104a03.Borrow(csourceRec_allocs)
	x.gSourceRec = *new(gRectangle)

	var cleft_allocs *cgoAllocMap
	ref78104a03.left, cleft_allocs = (C.int)(x.gLeft), cgoAllocsUnknown
	allocs78104a03.Borrow(cleft_allocs)
	x.gLeft = *new(int32)

	var ctop_allocs *cgoAllocMap
	ref78104a03.top, ctop_allocs = (C.int)(x.gTop), cgoAllocsUnknown
	allocs78104a03.Borrow(ctop_allocs)
	x.gTop = *new(int32)

	var cright_allocs *cgoAllocMap
	ref78104a03.right, cright_allocs = (C.int)(x.gRight), cgoAllocsUnknown
	allocs78104a03.Borrow(cright_allocs)
	x.gRight = *new(int32)

	var cbottom_allocs *cgoAllocMap
	ref78104a03.bottom, cbottom_allocs = (C.int)(x.gBottom), cgoAllocsUnknown
	allocs78104a03.Borrow(cbottom_allocs)
	x.gBottom = *new(int32)

	var c_type_allocs *cgoAllocMap
	ref78104a03._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs78104a03.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref78104a03 = ref78104a03
	x.allocs78104a03 = allocs78104a03

	return ref78104a03, allocs78104a03
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gNPatchInfo) passValue() (C.NPatchInfo, *cgoAllocMap) {
	if x.ref78104a03 != nil {
		return *x.ref78104a03, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gNPatchInfo) gc() {
	a := x.allocs78104a03.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearNPatchInfoMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gNPatchInfo) convert() *NPatchInfo {
	if x.ref78104a03 != nil {
		return (*NPatchInfo)(unsafe.Pointer(x.ref78104a03))
	}
	x.passRef()
	return (*NPatchInfo)(unsafe.Pointer(x.ref78104a03))
}

// NewNPatchInfo new Go object and Mapping to C object.
func NewNPatchInfo(vSourceRec Rectangle, vLeft int32, vTop int32, vRight int32, vBottom int32, vType int32) NPatchInfo {
	obj := *new(gNPatchInfo)
	obj.gSourceRec = *newRectangleRef(unsafe.Pointer(&vSourceRec))
	obj.gLeft = vLeft
	obj.gTop = vTop
	obj.gRight = vRight
	obj.gBottom = vBottom
	obj.gType = vType
	ret := obj.convert()
	return *(*NPatchInfo)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *NPatchInfo) Index(index int32) *NPatchInfo {
	ptr1 := (*NPatchInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfNPatchInfoValue)))
	return ptr1
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearCharInfoMemory(x *gCharInfo) {
	if x != nil && x.allocs702c36c0 != nil {
		x.allocs702c36c0.(*cgoAllocMap).Free()
		x.ref702c36c0 = nil
		return
	}
}

// newCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCharInfoRef(ref unsafe.Pointer) *gCharInfo {
	if ref == nil {
		return nil
	}
	obj := new(gCharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCharInfo) passRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		if x.allocs702c36c0 != nil {
			return x.ref702c36c0, x.allocs702c36c0.(*cgoAllocMap)
		} else {
			return x.ref702c36c0, nil
		}
	}
	mem702c36c0 := unsafe.Pointer(new(C.CharInfo))
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	// allocs702c36c0.Add(mem702c36c0)

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.gValue), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)
	x.gValue = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.gOffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)
	x.gOffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.gOffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)
	x.gOffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.gAdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)
	x.gAdvanceX = *new(int32)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.gImage.passValue()
	allocs702c36c0.Borrow(cimage_allocs)
	x.gImage = *new(gImage)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0

	return ref702c36c0, allocs702c36c0
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCharInfo) passValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gCharInfo) gc() {
	a := x.allocs702c36c0.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearCharInfoMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gCharInfo) convert() *CharInfo {
	if x.ref702c36c0 != nil {
		return (*CharInfo)(unsafe.Pointer(x.ref702c36c0))
	}
	x.passRef()
	return (*CharInfo)(unsafe.Pointer(x.ref702c36c0))
}

// NewCharInfo new Go object and Mapping to C object.
func NewCharInfo(vValue int32, vOffsetX int32, vOffsetY int32, vAdvanceX int32, vImage Image) CharInfo {
	obj := *new(gCharInfo)
	obj.gValue = vValue
	obj.gOffsetX = vOffsetX
	obj.gOffsetY = vOffsetY
	obj.gAdvanceX = vAdvanceX
	obj.gImage = *newImageRef(unsafe.Pointer(&vImage))
	ret := obj.convert()
	return *(*CharInfo)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *CharInfo) Index(index int32) *CharInfo {
	ptr1 := (*CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCharInfoValue)))
	return ptr1
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []gRectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []gCharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearFontMemory(x *gFont) {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		return
	}
}

// newFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newFontRef(ref unsafe.Pointer) *gFont {
	if ref == nil {
		return nil
	}
	obj := new(gFont)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gFont) passRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		if x.allocs70a6a7ec != nil {
			return x.ref70a6a7ec, x.allocs70a6a7ec.(*cgoAllocMap)
		} else {
			return x.ref70a6a7ec, nil
		}
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.gBaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.gBaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.gCharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.gCharsCount = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.gTexture.passValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.gRecs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.gRecs = *new([]gRectangle)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.gChars)
	allocs70a6a7ec.Borrow(cchars_allocs)
	x.gChars = *new([]gCharInfo)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec

	return ref70a6a7ec, allocs70a6a7ec
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gFont) passValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gFont) gc() {
	a := x.allocs70a6a7ec.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearFontMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gFont) convert() *Font {
	if x.ref70a6a7ec != nil {
		return (*Font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.passRef()
	return (*Font)(unsafe.Pointer(x.ref70a6a7ec))
}

// NewFont new Go object and Mapping to C object.
func NewFont(vBaseSize int32, vCharsCount int32, vTexture Texture2D, vRecs []Rectangle, vChars []CharInfo) Font {
	obj := *new(gFont)
	obj.gBaseSize = vBaseSize
	obj.gCharsCount = vCharsCount
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&vTexture))

	var recsT []gRectangle
	for i0 := range vRecs {
		p0 := *newRectangleRef(unsafe.Pointer(&vRecs[i0]))
		recsT = append(recsT, p0)
	}
	obj.gRecs = recsT

	var charsT []gCharInfo
	for i0 := range vChars {
		p0 := *newCharInfoRef(unsafe.Pointer(&vChars[i0]))
		charsT = append(charsT, p0)
	}
	obj.gChars = charsT
	ret := obj.convert()
	return *(*Font)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Font) Index(index int32) *Font {
	ptr1 := (*Font)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfFontValue)))
	return ptr1
}

// allocCamera3DMemory allocates memory for type C.Camera3D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera3DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera3DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera3DValue = unsafe.Sizeof([1]C.Camera3D{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearCamera3DMemory(x *gCamera3D) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		return
	}
}

// newCamera3DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCamera3DRef(ref unsafe.Pointer) *gCamera3D {
	if ref == nil {
		return nil
	}
	obj := new(gCamera3D)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCamera3D) passRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		if x.allocs7b09036 != nil {
			return x.ref7b09036, x.allocs7b09036.(*cgoAllocMap)
		} else {
			return x.ref7b09036, nil
		}
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.passValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.passValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(gVector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.passValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(gVector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036

	return ref7b09036, allocs7b09036
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCamera3D) passValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gCamera3D) gc() {
	a := x.allocs7b09036.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearCamera3DMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gCamera3D) convert() *Camera3D {
	if x.ref7b09036 != nil {
		return (*Camera3D)(unsafe.Pointer(x.ref7b09036))
	}
	x.passRef()
	return (*Camera3D)(unsafe.Pointer(x.ref7b09036))
}

// NewCamera3D new Go object and Mapping to C object.
func NewCamera3D(vPosition Vector3, vTarget Vector3, vUp Vector3, vFovy float32, vType int32) Camera3D {
	obj := *new(gCamera3D)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&vPosition))
	obj.gTarget = *newVector3Ref(unsafe.Pointer(&vTarget))
	obj.gUp = *newVector3Ref(unsafe.Pointer(&vUp))
	obj.gFovy = vFovy
	obj.gType = vType
	ret := obj.convert()
	return *(*Camera3D)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Camera3D) Index(index int32) *Camera3D {
	ptr1 := (*Camera3D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCamera3DValue)))
	return ptr1
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearCameraMemory(x *gCamera) {
	if x != nil && x.allocs7b09036 != nil {
		x.allocs7b09036.(*cgoAllocMap).Free()
		x.ref7b09036 = nil
		return
	}
}

// newCameraRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCameraRef(ref unsafe.Pointer) *gCamera {
	if ref == nil {
		return nil
	}
	obj := new(gCamera)
	obj.ref7b09036 = (*C.Camera3D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCamera) passRef() (*C.Camera3D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7b09036 != nil {
		if x.allocs7b09036 != nil {
			return x.ref7b09036, x.allocs7b09036.(*cgoAllocMap)
		} else {
			return x.ref7b09036, nil
		}
	}
	mem7b09036 := unsafe.Pointer(new(C.Camera3D))
	ref7b09036 := (*C.Camera3D)(mem7b09036)
	allocs7b09036 := new(cgoAllocMap)
	// allocs7b09036.Add(mem7b09036)

	var cposition_allocs *cgoAllocMap
	ref7b09036.position, cposition_allocs = x.gPosition.passValue()
	allocs7b09036.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var ctarget_allocs *cgoAllocMap
	ref7b09036.target, ctarget_allocs = x.gTarget.passValue()
	allocs7b09036.Borrow(ctarget_allocs)
	x.gTarget = *new(gVector3)

	var cup_allocs *cgoAllocMap
	ref7b09036.up, cup_allocs = x.gUp.passValue()
	allocs7b09036.Borrow(cup_allocs)
	x.gUp = *new(gVector3)

	var cfovy_allocs *cgoAllocMap
	ref7b09036.fovy, cfovy_allocs = (C.float)(x.gFovy), cgoAllocsUnknown
	allocs7b09036.Borrow(cfovy_allocs)
	x.gFovy = *new(float32)

	var c_type_allocs *cgoAllocMap
	ref7b09036._type, c_type_allocs = (C.int)(x.gType), cgoAllocsUnknown
	allocs7b09036.Borrow(c_type_allocs)
	x.gType = *new(int32)

	x.ref7b09036 = ref7b09036
	x.allocs7b09036 = allocs7b09036

	return ref7b09036, allocs7b09036
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCamera) passValue() (C.Camera3D, *cgoAllocMap) {
	if x.ref7b09036 != nil {
		return *x.ref7b09036, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gCamera) gc() {
	a := x.allocs7b09036.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearCameraMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gCamera) convert() *Camera {
	if x.ref7b09036 != nil {
		return (*Camera)(unsafe.Pointer(x.ref7b09036))
	}
	x.passRef()
	return (*Camera)(unsafe.Pointer(x.ref7b09036))
}

// NewCamera new Go object and Mapping to C object.
func NewCamera(vPosition Vector3, vTarget Vector3, vUp Vector3, vFovy float32, vType int32) Camera {
	obj := *new(gCamera)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&vPosition))
	obj.gTarget = *newVector3Ref(unsafe.Pointer(&vTarget))
	obj.gUp = *newVector3Ref(unsafe.Pointer(&vUp))
	obj.gFovy = vFovy
	obj.gType = vType
	ret := obj.convert()
	return *(*Camera)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Camera) Index(index int32) *Camera {
	ptr1 := (*Camera)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCamera3DValue)))
	return ptr1
}

// allocCamera2DMemory allocates memory for type C.Camera2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCamera2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCamera2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCamera2DValue = unsafe.Sizeof([1]C.Camera2D{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearCamera2DMemory(x *gCamera2D) {
	if x != nil && x.allocs1eaba177 != nil {
		x.allocs1eaba177.(*cgoAllocMap).Free()
		x.ref1eaba177 = nil
		return
	}
}

// newCamera2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCamera2DRef(ref unsafe.Pointer) *gCamera2D {
	if ref == nil {
		return nil
	}
	obj := new(gCamera2D)
	obj.ref1eaba177 = (*C.Camera2D)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCamera2D) passRef() (*C.Camera2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref1eaba177 != nil {
		if x.allocs1eaba177 != nil {
			return x.ref1eaba177, x.allocs1eaba177.(*cgoAllocMap)
		} else {
			return x.ref1eaba177, nil
		}
	}
	mem1eaba177 := unsafe.Pointer(new(C.Camera2D))
	ref1eaba177 := (*C.Camera2D)(mem1eaba177)
	allocs1eaba177 := new(cgoAllocMap)
	// allocs1eaba177.Add(mem1eaba177)

	var coffset_allocs *cgoAllocMap
	ref1eaba177.offset, coffset_allocs = x.gOffset.passValue()
	allocs1eaba177.Borrow(coffset_allocs)
	x.gOffset = *new(gVector2)

	var ctarget_allocs *cgoAllocMap
	ref1eaba177.target, ctarget_allocs = x.gTarget.passValue()
	allocs1eaba177.Borrow(ctarget_allocs)
	x.gTarget = *new(gVector2)

	var crotation_allocs *cgoAllocMap
	ref1eaba177.rotation, crotation_allocs = (C.float)(x.gRotation), cgoAllocsUnknown
	allocs1eaba177.Borrow(crotation_allocs)
	x.gRotation = *new(float32)

	var czoom_allocs *cgoAllocMap
	ref1eaba177.zoom, czoom_allocs = (C.float)(x.gZoom), cgoAllocsUnknown
	allocs1eaba177.Borrow(czoom_allocs)
	x.gZoom = *new(float32)

	x.ref1eaba177 = ref1eaba177
	x.allocs1eaba177 = allocs1eaba177

	return ref1eaba177, allocs1eaba177
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCamera2D) passValue() (C.Camera2D, *cgoAllocMap) {
	if x.ref1eaba177 != nil {
		return *x.ref1eaba177, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gCamera2D) gc() {
	a := x.allocs1eaba177.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearCamera2DMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gCamera2D) convert() *Camera2D {
	if x.ref1eaba177 != nil {
		return (*Camera2D)(unsafe.Pointer(x.ref1eaba177))
	}
	x.passRef()
	return (*Camera2D)(unsafe.Pointer(x.ref1eaba177))
}

// NewCamera2D new Go object and Mapping to C object.
func NewCamera2D(vOffset Vector2, vTarget Vector2, vRotation float32, vZoom float32) Camera2D {
	obj := *new(gCamera2D)
	obj.gOffset = *newVector2Ref(unsafe.Pointer(&vOffset))
	obj.gTarget = *newVector2Ref(unsafe.Pointer(&vTarget))
	obj.gRotation = vRotation
	obj.gZoom = vZoom
	ret := obj.convert()
	return *(*Camera2D)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Camera2D) Index(index int32) *Camera2D {
	ptr1 := (*Camera2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCamera2DValue)))
	return ptr1
}

// allocMeshMemory allocates memory for type C.Mesh in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMeshMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMeshValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMeshValue = unsafe.Sizeof([1]C.Mesh{})

// allocFloatMemory allocates memory for type C.float in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFloatMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFloatValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFloatValue = unsafe.Sizeof([1]C.float{})

// unpackSFloat32 transforms a sliced Go data structure into plain C format.
func unpackSFloat32(x []float32) (unpacked *C.float, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.float) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocFloatMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.float)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.float)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.float)(h.Data)
	return
}

// allocUcharMemory allocates memory for type C.uchar in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUcharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUcharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUcharValue = unsafe.Sizeof([1]C.uchar{})

// unpackSByte transforms a sliced Go data structure into plain C format.
func unpackSByte(x []byte) (unpacked *C.uchar, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.uchar) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUcharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uchar)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.uchar)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uchar)(h.Data)
	return
}

// allocUshortMemory allocates memory for type C.ushort in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUshortMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUshortValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUshortValue = unsafe.Sizeof([1]C.ushort{})

// unpackSUUint16 transforms a sliced Go data structure into plain C format.
func unpackSUUint16(x []uint16) (unpacked *C.ushort, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.ushort) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUshortMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.ushort)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.ushort)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.ushort)(h.Data)
	return
}

// allocIntMemory allocates memory for type C.int in C.
// The caller is responsible for freeing the this memory via C.free.
func allocIntMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfIntValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfIntValue = unsafe.Sizeof([1]C.int{})

// unpackSInt32 transforms a sliced Go data structure into plain C format.
func unpackSInt32(x []int32) (unpacked *C.int, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.int) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocIntMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.int)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.int)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.int)(h.Data)
	return
}

// allocUintMemory allocates memory for type C.uint in C.
// The caller is responsible for freeing the this memory via C.free.
func allocUintMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfUintValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfUintValue = unsafe.Sizeof([1]C.uint{})

// unpackSUUint32 transforms a sliced Go data structure into plain C format.
func unpackSUUint32(x []uint32) (unpacked *C.uint, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.uint) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocUintMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.uint)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0] = (C.uint)(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.uint)(h.Data)
	return
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearMeshMemory(x *gMesh) {
	if x != nil && x.allocs415d9568 != nil {
		x.allocs415d9568.(*cgoAllocMap).Free()
		x.ref415d9568 = nil
		return
	}
}

// newMeshRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMeshRef(ref unsafe.Pointer) *gMesh {
	if ref == nil {
		return nil
	}
	obj := new(gMesh)
	obj.ref415d9568 = (*C.Mesh)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMesh) passRef() (*C.Mesh, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref415d9568 != nil {
		if x.allocs415d9568 != nil {
			return x.ref415d9568, x.allocs415d9568.(*cgoAllocMap)
		} else {
			return x.ref415d9568, nil
		}
	}
	mem415d9568 := unsafe.Pointer(new(C.Mesh))
	ref415d9568 := (*C.Mesh)(mem415d9568)
	allocs415d9568 := new(cgoAllocMap)
	// allocs415d9568.Add(mem415d9568)

	var cvertexCount_allocs *cgoAllocMap
	ref415d9568.vertexCount, cvertexCount_allocs = (C.int)(x.gVertexCount), cgoAllocsUnknown
	allocs415d9568.Borrow(cvertexCount_allocs)
	x.gVertexCount = *new(int32)

	var ctriangleCount_allocs *cgoAllocMap
	ref415d9568.triangleCount, ctriangleCount_allocs = (C.int)(x.gTriangleCount), cgoAllocsUnknown
	allocs415d9568.Borrow(ctriangleCount_allocs)
	x.gTriangleCount = *new(int32)

	var cvertices_allocs *cgoAllocMap
	ref415d9568.vertices, cvertices_allocs = unpackSFloat32(x.gVertices)
	allocs415d9568.Borrow(cvertices_allocs)
	x.gVertices = *new([]float32)

	var ctexcoords_allocs *cgoAllocMap
	ref415d9568.texcoords, ctexcoords_allocs = unpackSFloat32(x.gTexcoords)
	allocs415d9568.Borrow(ctexcoords_allocs)
	x.gTexcoords = *new([]float32)

	var ctexcoords2_allocs *cgoAllocMap
	ref415d9568.texcoords2, ctexcoords2_allocs = unpackSFloat32(x.gTexcoords2)
	allocs415d9568.Borrow(ctexcoords2_allocs)
	x.gTexcoords2 = *new([]float32)

	var cnormals_allocs *cgoAllocMap
	ref415d9568.normals, cnormals_allocs = unpackSFloat32(x.gNormals)
	allocs415d9568.Borrow(cnormals_allocs)
	x.gNormals = *new([]float32)

	var ctangents_allocs *cgoAllocMap
	ref415d9568.tangents, ctangents_allocs = unpackSFloat32(x.gTangents)
	allocs415d9568.Borrow(ctangents_allocs)
	x.gTangents = *new([]float32)

	var ccolors_allocs *cgoAllocMap
	ref415d9568.colors, ccolors_allocs = unpackSByte(x.gColors)
	allocs415d9568.Borrow(ccolors_allocs)
	x.gColors = *new([]byte)

	var cindices_allocs *cgoAllocMap
	ref415d9568.indices, cindices_allocs = unpackSUUint16(x.gIndices)
	allocs415d9568.Borrow(cindices_allocs)
	x.gIndices = *new([]uint16)

	var canimVertices_allocs *cgoAllocMap
	ref415d9568.animVertices, canimVertices_allocs = unpackSFloat32(x.gAnimVertices)
	allocs415d9568.Borrow(canimVertices_allocs)
	x.gAnimVertices = *new([]float32)

	var canimNormals_allocs *cgoAllocMap
	ref415d9568.animNormals, canimNormals_allocs = unpackSFloat32(x.gAnimNormals)
	allocs415d9568.Borrow(canimNormals_allocs)
	x.gAnimNormals = *new([]float32)

	var cboneIds_allocs *cgoAllocMap
	ref415d9568.boneIds, cboneIds_allocs = unpackSInt32(x.gBoneIds)
	allocs415d9568.Borrow(cboneIds_allocs)
	x.gBoneIds = *new([]int32)

	var cboneWeights_allocs *cgoAllocMap
	ref415d9568.boneWeights, cboneWeights_allocs = unpackSFloat32(x.gBoneWeights)
	allocs415d9568.Borrow(cboneWeights_allocs)
	x.gBoneWeights = *new([]float32)

	var cvaoId_allocs *cgoAllocMap
	ref415d9568.vaoId, cvaoId_allocs = (C.uint)(x.gVaoId), cgoAllocsUnknown
	allocs415d9568.Borrow(cvaoId_allocs)
	x.gVaoId = *new(uint32)

	var cvboId_allocs *cgoAllocMap
	ref415d9568.vboId, cvboId_allocs = unpackSUUint32(x.gVboId)
	allocs415d9568.Borrow(cvboId_allocs)
	x.gVboId = *new([]uint32)

	x.ref415d9568 = ref415d9568
	x.allocs415d9568 = allocs415d9568

	return ref415d9568, allocs415d9568
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMesh) passValue() (C.Mesh, *cgoAllocMap) {
	if x.ref415d9568 != nil {
		return *x.ref415d9568, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gMesh) gc() {
	a := x.allocs415d9568.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearMeshMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gMesh) convert() *Mesh {
	if x.ref415d9568 != nil {
		return (*Mesh)(unsafe.Pointer(x.ref415d9568))
	}
	x.passRef()
	return (*Mesh)(unsafe.Pointer(x.ref415d9568))
}

// NewMesh new Go object and Mapping to C object.
func NewMesh(vVertexCount int32, vTriangleCount int32, vVertices []float32, vTexcoords []float32, vTexcoords2 []float32, vNormals []float32, vTangents []float32, vColors []byte, vIndices []uint16, vAnimVertices []float32, vAnimNormals []float32, vBoneIds []int32, vBoneWeights []float32, vVaoId uint32, vVboId []uint32) Mesh {
	obj := *new(gMesh)
	obj.gVertexCount = vVertexCount
	obj.gTriangleCount = vTriangleCount
	obj.gVertices = vVertices
	obj.gTexcoords = vTexcoords
	obj.gTexcoords2 = vTexcoords2
	obj.gNormals = vNormals
	obj.gTangents = vTangents
	obj.gColors = vColors
	obj.gIndices = vIndices
	obj.gAnimVertices = vAnimVertices
	obj.gAnimNormals = vAnimNormals
	obj.gBoneIds = vBoneIds
	obj.gBoneWeights = vBoneWeights
	obj.gVaoId = vVaoId
	obj.gVboId = vVboId
	ret := obj.convert()
	return *(*Mesh)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Mesh) Index(index int32) *Mesh {
	ptr1 := (*Mesh)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMeshValue)))
	return ptr1
}

// allocShaderMemory allocates memory for type C.Shader in C.
// The caller is responsible for freeing the this memory via C.free.
func allocShaderMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfShaderValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfShaderValue = unsafe.Sizeof([1]C.Shader{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearShaderMemory(x *gShader) {
	if x != nil && x.allocsf85f9b1e != nil {
		x.allocsf85f9b1e.(*cgoAllocMap).Free()
		x.reff85f9b1e = nil
		return
	}
}

// newShaderRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newShaderRef(ref unsafe.Pointer) *gShader {
	if ref == nil {
		return nil
	}
	obj := new(gShader)
	obj.reff85f9b1e = (*C.Shader)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gShader) passRef() (*C.Shader, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff85f9b1e != nil {
		if x.allocsf85f9b1e != nil {
			return x.reff85f9b1e, x.allocsf85f9b1e.(*cgoAllocMap)
		} else {
			return x.reff85f9b1e, nil
		}
	}
	memf85f9b1e := unsafe.Pointer(new(C.Shader))
	reff85f9b1e := (*C.Shader)(memf85f9b1e)
	allocsf85f9b1e := new(cgoAllocMap)
	// allocsf85f9b1e.Add(memf85f9b1e)

	var cid_allocs *cgoAllocMap
	reff85f9b1e.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocsf85f9b1e.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var clocs_allocs *cgoAllocMap
	reff85f9b1e.locs, clocs_allocs = unpackSInt32(x.gLocs)
	allocsf85f9b1e.Borrow(clocs_allocs)
	x.gLocs = *new([]int32)

	x.reff85f9b1e = reff85f9b1e
	x.allocsf85f9b1e = allocsf85f9b1e

	return reff85f9b1e, allocsf85f9b1e
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gShader) passValue() (C.Shader, *cgoAllocMap) {
	if x.reff85f9b1e != nil {
		return *x.reff85f9b1e, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gShader) gc() {
	a := x.allocsf85f9b1e.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearShaderMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gShader) convert() *Shader {
	if x.reff85f9b1e != nil {
		return (*Shader)(unsafe.Pointer(x.reff85f9b1e))
	}
	x.passRef()
	return (*Shader)(unsafe.Pointer(x.reff85f9b1e))
}

// NewShader new Go object and Mapping to C object.
func NewShader(vId uint32, vLocs []int32) Shader {
	obj := *new(gShader)
	obj.gId = vId
	obj.gLocs = vLocs
	ret := obj.convert()
	return *(*Shader)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Shader) Index(index int32) *Shader {
	ptr1 := (*Shader)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfShaderValue)))
	return ptr1
}

// allocMaterialMapMemory allocates memory for type C.MaterialMap in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMapMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialMapValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialMapValue = unsafe.Sizeof([1]C.MaterialMap{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearMaterialMapMemory(x *gMaterialMap) {
	if x != nil && x.allocsa8350ad3 != nil {
		x.allocsa8350ad3.(*cgoAllocMap).Free()
		x.refa8350ad3 = nil
		return
	}
}

// newMaterialMapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMaterialMapRef(ref unsafe.Pointer) *gMaterialMap {
	if ref == nil {
		return nil
	}
	obj := new(gMaterialMap)
	obj.refa8350ad3 = (*C.MaterialMap)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMaterialMap) passRef() (*C.MaterialMap, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa8350ad3 != nil {
		if x.allocsa8350ad3 != nil {
			return x.refa8350ad3, x.allocsa8350ad3.(*cgoAllocMap)
		} else {
			return x.refa8350ad3, nil
		}
	}
	mema8350ad3 := unsafe.Pointer(new(C.MaterialMap))
	refa8350ad3 := (*C.MaterialMap)(mema8350ad3)
	allocsa8350ad3 := new(cgoAllocMap)
	// allocsa8350ad3.Add(mema8350ad3)

	var ctexture_allocs *cgoAllocMap
	refa8350ad3.texture, ctexture_allocs = x.gTexture.passValue()
	allocsa8350ad3.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var ccolor_allocs *cgoAllocMap
	refa8350ad3.color, ccolor_allocs = x.gColor.passValue()
	allocsa8350ad3.Borrow(ccolor_allocs)
	x.gColor = *new(gColor)

	var cvalue_allocs *cgoAllocMap
	refa8350ad3.value, cvalue_allocs = (C.float)(x.gValue), cgoAllocsUnknown
	allocsa8350ad3.Borrow(cvalue_allocs)
	x.gValue = *new(float32)

	x.refa8350ad3 = refa8350ad3
	x.allocsa8350ad3 = allocsa8350ad3

	return refa8350ad3, allocsa8350ad3
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMaterialMap) passValue() (C.MaterialMap, *cgoAllocMap) {
	if x.refa8350ad3 != nil {
		return *x.refa8350ad3, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gMaterialMap) gc() {
	a := x.allocsa8350ad3.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearMaterialMapMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gMaterialMap) convert() *MaterialMap {
	if x.refa8350ad3 != nil {
		return (*MaterialMap)(unsafe.Pointer(x.refa8350ad3))
	}
	x.passRef()
	return (*MaterialMap)(unsafe.Pointer(x.refa8350ad3))
}

// NewMaterialMap new Go object and Mapping to C object.
func NewMaterialMap(vTexture Texture2D, vColor Color, vValue float32) MaterialMap {
	obj := *new(gMaterialMap)
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&vTexture))
	obj.gColor = *newColorRef(unsafe.Pointer(&vColor))
	obj.gValue = vValue
	ret := obj.convert()
	return *(*MaterialMap)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *MaterialMap) Index(index int32) *MaterialMap {
	ptr1 := (*MaterialMap)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMaterialMapValue)))
	return ptr1
}

// allocMaterialMemory allocates memory for type C.Material in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMaterialMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMaterialValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMaterialValue = unsafe.Sizeof([1]C.Material{})

// unpackSMaterialMap transforms a sliced Go data structure into plain C format.
func unpackSMaterialMap(x []gMaterialMap) (unpacked *C.MaterialMap, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.MaterialMap) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMapMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.MaterialMap)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.MaterialMap)(h.Data)
	return
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearMaterialMemory(x *gMaterial) {
	if x != nil && x.allocs85c817c3 != nil {
		x.allocs85c817c3.(*cgoAllocMap).Free()
		x.ref85c817c3 = nil
		return
	}
}

// newMaterialRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMaterialRef(ref unsafe.Pointer) *gMaterial {
	if ref == nil {
		return nil
	}
	obj := new(gMaterial)
	obj.ref85c817c3 = (*C.Material)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMaterial) passRef() (*C.Material, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref85c817c3 != nil {
		if x.allocs85c817c3 != nil {
			return x.ref85c817c3, x.allocs85c817c3.(*cgoAllocMap)
		} else {
			return x.ref85c817c3, nil
		}
	}
	mem85c817c3 := unsafe.Pointer(new(C.Material))
	ref85c817c3 := (*C.Material)(mem85c817c3)
	allocs85c817c3 := new(cgoAllocMap)
	// allocs85c817c3.Add(mem85c817c3)

	var cshader_allocs *cgoAllocMap
	ref85c817c3.shader, cshader_allocs = x.gShader.passValue()
	allocs85c817c3.Borrow(cshader_allocs)
	x.gShader = *new(gShader)

	var cmaps_allocs *cgoAllocMap
	ref85c817c3.maps, cmaps_allocs = unpackSMaterialMap(x.gMaps)
	allocs85c817c3.Borrow(cmaps_allocs)
	x.gMaps = *new([]gMaterialMap)

	var cparams_allocs *cgoAllocMap
	ref85c817c3.params, cparams_allocs = unpackSFloat32(x.gParams)
	allocs85c817c3.Borrow(cparams_allocs)
	x.gParams = *new([]float32)

	x.ref85c817c3 = ref85c817c3
	x.allocs85c817c3 = allocs85c817c3

	return ref85c817c3, allocs85c817c3
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMaterial) passValue() (C.Material, *cgoAllocMap) {
	if x.ref85c817c3 != nil {
		return *x.ref85c817c3, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gMaterial) gc() {
	a := x.allocs85c817c3.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearMaterialMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gMaterial) convert() *Material {
	if x.ref85c817c3 != nil {
		return (*Material)(unsafe.Pointer(x.ref85c817c3))
	}
	x.passRef()
	return (*Material)(unsafe.Pointer(x.ref85c817c3))
}

// NewMaterial new Go object and Mapping to C object.
func NewMaterial(vShader Shader, vMaps []MaterialMap, vParams []float32) Material {
	obj := *new(gMaterial)
	obj.gShader = *newShaderRef(unsafe.Pointer(&vShader))

	var mapsT []gMaterialMap
	for i0 := range vMaps {
		p0 := *newMaterialMapRef(unsafe.Pointer(&vMaps[i0]))
		mapsT = append(mapsT, p0)
	}
	obj.gMaps = mapsT
	obj.gParams = vParams
	ret := obj.convert()
	return *(*Material)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Material) Index(index int32) *Material {
	ptr1 := (*Material)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMaterialValue)))
	return ptr1
}

// allocTransformMemory allocates memory for type C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTransformValue = unsafe.Sizeof([1]C.Transform{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearTransformMemory(x *gTransform) {
	if x != nil && x.allocsf543030e != nil {
		x.allocsf543030e.(*cgoAllocMap).Free()
		x.reff543030e = nil
		return
	}
}

// newTransformRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTransformRef(ref unsafe.Pointer) *gTransform {
	if ref == nil {
		return nil
	}
	obj := new(gTransform)
	obj.reff543030e = (*C.Transform)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTransform) passRef() (*C.Transform, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.reff543030e != nil {
		if x.allocsf543030e != nil {
			return x.reff543030e, x.allocsf543030e.(*cgoAllocMap)
		} else {
			return x.reff543030e, nil
		}
	}
	memf543030e := unsafe.Pointer(new(C.Transform))
	reff543030e := (*C.Transform)(memf543030e)
	allocsf543030e := new(cgoAllocMap)
	// allocsf543030e.Add(memf543030e)

	var ctranslation_allocs *cgoAllocMap
	reff543030e.translation, ctranslation_allocs = x.gTranslation.passValue()
	allocsf543030e.Borrow(ctranslation_allocs)
	x.gTranslation = *new(gVector3)

	var crotation_allocs *cgoAllocMap
	reff543030e.rotation, crotation_allocs = x.gRotation.passValue()
	allocsf543030e.Borrow(crotation_allocs)
	x.gRotation = *new(gQuaternion)

	var cscale_allocs *cgoAllocMap
	reff543030e.scale, cscale_allocs = x.gScale.passValue()
	allocsf543030e.Borrow(cscale_allocs)
	x.gScale = *new(gVector3)

	x.reff543030e = reff543030e
	x.allocsf543030e = allocsf543030e

	return reff543030e, allocsf543030e
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTransform) passValue() (C.Transform, *cgoAllocMap) {
	if x.reff543030e != nil {
		return *x.reff543030e, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gTransform) gc() {
	a := x.allocsf543030e.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearTransformMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gTransform) convert() *Transform {
	if x.reff543030e != nil {
		return (*Transform)(unsafe.Pointer(x.reff543030e))
	}
	x.passRef()
	return (*Transform)(unsafe.Pointer(x.reff543030e))
}

// NewTransform new Go object and Mapping to C object.
func NewTransform(vTranslation Vector3, vRotation Quaternion, vScale Vector3) Transform {
	obj := *new(gTransform)
	obj.gTranslation = *newVector3Ref(unsafe.Pointer(&vTranslation))
	obj.gRotation = *newQuaternionRef(unsafe.Pointer(&vRotation))
	obj.gScale = *newVector3Ref(unsafe.Pointer(&vScale))
	ret := obj.convert()
	return *(*Transform)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Transform) Index(index int32) *Transform {
	ptr1 := (*Transform)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTransformValue)))
	return ptr1
}

// allocBoneInfoMemory allocates memory for type C.BoneInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoneInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoneInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoneInfoValue = unsafe.Sizeof([1]C.BoneInfo{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearBoneInfoMemory(x *gBoneInfo) {
	if x != nil && x.allocs5ab7f197 != nil {
		x.allocs5ab7f197.(*cgoAllocMap).Free()
		x.ref5ab7f197 = nil
		return
	}
}

// newBoneInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newBoneInfoRef(ref unsafe.Pointer) *gBoneInfo {
	if ref == nil {
		return nil
	}
	obj := new(gBoneInfo)
	obj.ref5ab7f197 = (*C.BoneInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gBoneInfo) passRef() (*C.BoneInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ab7f197 != nil {
		if x.allocs5ab7f197 != nil {
			return x.ref5ab7f197, x.allocs5ab7f197.(*cgoAllocMap)
		} else {
			return x.ref5ab7f197, nil
		}
	}
	mem5ab7f197 := unsafe.Pointer(new(C.BoneInfo))
	ref5ab7f197 := (*C.BoneInfo)(mem5ab7f197)
	allocs5ab7f197 := new(cgoAllocMap)
	// allocs5ab7f197.Add(mem5ab7f197)

	var cname_allocs *cgoAllocMap
	ref5ab7f197.name, cname_allocs = *(*[32]C.char)(unsafe.Pointer(&x.gName)), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cname_allocs)
	x.gName = *new([32]byte)

	var cparent_allocs *cgoAllocMap
	ref5ab7f197.parent, cparent_allocs = (C.int)(x.gParent), cgoAllocsUnknown
	allocs5ab7f197.Borrow(cparent_allocs)
	x.gParent = *new(int32)

	x.ref5ab7f197 = ref5ab7f197
	x.allocs5ab7f197 = allocs5ab7f197

	return ref5ab7f197, allocs5ab7f197
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gBoneInfo) passValue() (C.BoneInfo, *cgoAllocMap) {
	if x.ref5ab7f197 != nil {
		return *x.ref5ab7f197, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gBoneInfo) gc() {
	a := x.allocs5ab7f197.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearBoneInfoMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gBoneInfo) convert() *BoneInfo {
	if x.ref5ab7f197 != nil {
		return (*BoneInfo)(unsafe.Pointer(x.ref5ab7f197))
	}
	x.passRef()
	return (*BoneInfo)(unsafe.Pointer(x.ref5ab7f197))
}

// NewBoneInfo new Go object and Mapping to C object.
func NewBoneInfo(vName [32]byte, vParent int32) BoneInfo {
	obj := *new(gBoneInfo)
	obj.gName = vName
	obj.gParent = vParent
	ret := obj.convert()
	return *(*BoneInfo)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *BoneInfo) Index(index int32) *BoneInfo {
	ptr1 := (*BoneInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfBoneInfoValue)))
	return ptr1
}

// allocModelMemory allocates memory for type C.Model in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelValue = unsafe.Sizeof([1]C.Model{})

// unpackSMesh transforms a sliced Go data structure into plain C format.
func unpackSMesh(x []gMesh) (unpacked *C.Mesh, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Mesh) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMeshMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Mesh)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Mesh)(h.Data)
	return
}

// unpackSMaterial transforms a sliced Go data structure into plain C format.
func unpackSMaterial(x []gMaterial) (unpacked *C.Material, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Material) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocMaterialMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Material)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Material)(h.Data)
	return
}

// unpackSBoneInfo transforms a sliced Go data structure into plain C format.
func unpackSBoneInfo(x []gBoneInfo) (unpacked *C.BoneInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.BoneInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocBoneInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.BoneInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.BoneInfo)(h.Data)
	return
}

// unpackSTransform transforms a sliced Go data structure into plain C format.
func unpackSTransform(x []gTransform) (unpacked *C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Transform)(h.Data)
	return
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearModelMemory(x *gModel) {
	if x != nil && x.allocs16545ddd != nil {
		x.allocs16545ddd.(*cgoAllocMap).Free()
		x.ref16545ddd = nil
		return
	}
}

// newModelRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newModelRef(ref unsafe.Pointer) *gModel {
	if ref == nil {
		return nil
	}
	obj := new(gModel)
	obj.ref16545ddd = (*C.Model)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gModel) passRef() (*C.Model, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref16545ddd != nil {
		if x.allocs16545ddd != nil {
			return x.ref16545ddd, x.allocs16545ddd.(*cgoAllocMap)
		} else {
			return x.ref16545ddd, nil
		}
	}
	mem16545ddd := unsafe.Pointer(new(C.Model))
	ref16545ddd := (*C.Model)(mem16545ddd)
	allocs16545ddd := new(cgoAllocMap)
	// allocs16545ddd.Add(mem16545ddd)

	var ctransform_allocs *cgoAllocMap
	ref16545ddd.transform, ctransform_allocs = x.gTransform.passValue()
	allocs16545ddd.Borrow(ctransform_allocs)
	x.gTransform = *new(gMatrix)

	var cmeshCount_allocs *cgoAllocMap
	ref16545ddd.meshCount, cmeshCount_allocs = (C.int)(x.gMeshCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmeshCount_allocs)
	x.gMeshCount = *new(int32)

	var cmeshes_allocs *cgoAllocMap
	ref16545ddd.meshes, cmeshes_allocs = unpackSMesh(x.gMeshes)
	allocs16545ddd.Borrow(cmeshes_allocs)
	x.gMeshes = *new([]gMesh)

	var cmaterialCount_allocs *cgoAllocMap
	ref16545ddd.materialCount, cmaterialCount_allocs = (C.int)(x.gMaterialCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cmaterialCount_allocs)
	x.gMaterialCount = *new(int32)

	var cmaterials_allocs *cgoAllocMap
	ref16545ddd.materials, cmaterials_allocs = unpackSMaterial(x.gMaterials)
	allocs16545ddd.Borrow(cmaterials_allocs)
	x.gMaterials = *new([]gMaterial)

	var cmeshMaterial_allocs *cgoAllocMap
	ref16545ddd.meshMaterial, cmeshMaterial_allocs = unpackSInt32(x.gMeshMaterial)
	allocs16545ddd.Borrow(cmeshMaterial_allocs)
	x.gMeshMaterial = *new([]int32)

	var cboneCount_allocs *cgoAllocMap
	ref16545ddd.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs16545ddd.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref16545ddd.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs16545ddd.Borrow(cbones_allocs)
	x.gBones = *new([]gBoneInfo)

	var cbindPose_allocs *cgoAllocMap
	ref16545ddd.bindPose, cbindPose_allocs = unpackSTransform(x.gBindPose)
	allocs16545ddd.Borrow(cbindPose_allocs)
	x.gBindPose = *new([]gTransform)

	x.ref16545ddd = ref16545ddd
	x.allocs16545ddd = allocs16545ddd

	return ref16545ddd, allocs16545ddd
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gModel) passValue() (C.Model, *cgoAllocMap) {
	if x.ref16545ddd != nil {
		return *x.ref16545ddd, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gModel) gc() {
	a := x.allocs16545ddd.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearModelMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gModel) convert() *Model {
	if x.ref16545ddd != nil {
		return (*Model)(unsafe.Pointer(x.ref16545ddd))
	}
	x.passRef()
	return (*Model)(unsafe.Pointer(x.ref16545ddd))
}

// NewModel new Go object and Mapping to C object.
func NewModel(vTransform Matrix, vMeshCount int32, vMeshes []Mesh, vMaterialCount int32, vMaterials []Material, vMeshMaterial []int32, vBoneCount int32, vBones []BoneInfo, vBindPose []Transform) Model {
	obj := *new(gModel)
	obj.gTransform = *newMatrixRef(unsafe.Pointer(&vTransform))
	obj.gMeshCount = vMeshCount

	var meshesT []gMesh
	for i0 := range vMeshes {
		p0 := *newMeshRef(unsafe.Pointer(&vMeshes[i0]))
		meshesT = append(meshesT, p0)
	}
	obj.gMeshes = meshesT
	obj.gMaterialCount = vMaterialCount

	var materialsT []gMaterial
	for i0 := range vMaterials {
		p0 := *newMaterialRef(unsafe.Pointer(&vMaterials[i0]))
		materialsT = append(materialsT, p0)
	}
	obj.gMaterials = materialsT
	obj.gMeshMaterial = vMeshMaterial
	obj.gBoneCount = vBoneCount

	var bonesT []gBoneInfo
	for i0 := range vBones {
		p0 := *newBoneInfoRef(unsafe.Pointer(&vBones[i0]))
		bonesT = append(bonesT, p0)
	}
	obj.gBones = bonesT

	var bindPoseT []gTransform
	for i0 := range vBindPose {
		p0 := *newTransformRef(unsafe.Pointer(&vBindPose[i0]))
		bindPoseT = append(bindPoseT, p0)
	}
	obj.gBindPose = bindPoseT
	ret := obj.convert()
	return *(*Model)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Model) Index(index int32) *Model {
	ptr1 := (*Model)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfModelValue)))
	return ptr1
}

// allocModelAnimationMemory allocates memory for type C.ModelAnimation in C.
// The caller is responsible for freeing the this memory via C.free.
func allocModelAnimationMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfModelAnimationValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfModelAnimationValue = unsafe.Sizeof([1]C.ModelAnimation{})

// allocPTransformMemory allocates memory for type *C.Transform in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPTransformMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPTransformValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPTransformValue = unsafe.Sizeof([1]*C.Transform{})

// unpackSSTransform transforms a sliced Go data structure into plain C format.
func unpackSSTransform(x [][]gTransform) (unpacked **C.Transform, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.Transform) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPTransformMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.Transform)(unsafe.Pointer(h0))
	for i0 := range x {
		len1 := len(x[i0])
		mem1 := allocTransformMemory(len1)
		allocs.Add(mem1)
		h1 := &sliceHeader{
			Data: mem1,
			Cap:  len1,
			Len:  len1,
		}
		v1 := *(*[]C.Transform)(unsafe.Pointer(h1))
		for i1 := range x[i0] {
			allocs1 := new(cgoAllocMap)
			v1[i1], allocs1 = x[i0][i1].passValue()
			allocs.Borrow(allocs1)
		}
		h := (*sliceHeader)(unsafe.Pointer(&v1))
		v0[i0] = (*C.Transform)(h.Data)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.Transform)(h.Data)
	return
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearModelAnimationMemory(x *gModelAnimation) {
	if x != nil && x.allocs26dd6a24 != nil {
		x.allocs26dd6a24.(*cgoAllocMap).Free()
		x.ref26dd6a24 = nil
		return
	}
}

// newModelAnimationRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newModelAnimationRef(ref unsafe.Pointer) *gModelAnimation {
	if ref == nil {
		return nil
	}
	obj := new(gModelAnimation)
	obj.ref26dd6a24 = (*C.ModelAnimation)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gModelAnimation) passRef() (*C.ModelAnimation, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref26dd6a24 != nil {
		if x.allocs26dd6a24 != nil {
			return x.ref26dd6a24, x.allocs26dd6a24.(*cgoAllocMap)
		} else {
			return x.ref26dd6a24, nil
		}
	}
	mem26dd6a24 := unsafe.Pointer(new(C.ModelAnimation))
	ref26dd6a24 := (*C.ModelAnimation)(mem26dd6a24)
	allocs26dd6a24 := new(cgoAllocMap)
	// allocs26dd6a24.Add(mem26dd6a24)

	var cboneCount_allocs *cgoAllocMap
	ref26dd6a24.boneCount, cboneCount_allocs = (C.int)(x.gBoneCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cboneCount_allocs)
	x.gBoneCount = *new(int32)

	var cbones_allocs *cgoAllocMap
	ref26dd6a24.bones, cbones_allocs = unpackSBoneInfo(x.gBones)
	allocs26dd6a24.Borrow(cbones_allocs)
	x.gBones = *new([]gBoneInfo)

	var cframeCount_allocs *cgoAllocMap
	ref26dd6a24.frameCount, cframeCount_allocs = (C.int)(x.gFrameCount), cgoAllocsUnknown
	allocs26dd6a24.Borrow(cframeCount_allocs)
	x.gFrameCount = *new(int32)

	var cframePoses_allocs *cgoAllocMap
	ref26dd6a24.framePoses, cframePoses_allocs = unpackSSTransform(x.gFramePoses)
	allocs26dd6a24.Borrow(cframePoses_allocs)
	x.gFramePoses = *new([][]gTransform)

	x.ref26dd6a24 = ref26dd6a24
	x.allocs26dd6a24 = allocs26dd6a24

	return ref26dd6a24, allocs26dd6a24
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gModelAnimation) passValue() (C.ModelAnimation, *cgoAllocMap) {
	if x.ref26dd6a24 != nil {
		return *x.ref26dd6a24, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gModelAnimation) gc() {
	a := x.allocs26dd6a24.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearModelAnimationMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gModelAnimation) convert() *ModelAnimation {
	if x.ref26dd6a24 != nil {
		return (*ModelAnimation)(unsafe.Pointer(x.ref26dd6a24))
	}
	x.passRef()
	return (*ModelAnimation)(unsafe.Pointer(x.ref26dd6a24))
}

// NewModelAnimation new Go object and Mapping to C object.
func NewModelAnimation(vBoneCount int32, vBones []BoneInfo, vFrameCount int32, vFramePoses [][]Transform) ModelAnimation {
	obj := *new(gModelAnimation)
	obj.gBoneCount = vBoneCount

	var bonesT []gBoneInfo
	for i0 := range vBones {
		p0 := *newBoneInfoRef(unsafe.Pointer(&vBones[i0]))
		bonesT = append(bonesT, p0)
	}
	obj.gBones = bonesT
	obj.gFrameCount = vFrameCount

	var framePosesT [][]gTransform
	for i0, v0 := range vFramePoses {
		s0 := make([]gTransform, len(v0))
		for i1 := range v0 {
			p0 := *newTransformRef(unsafe.Pointer(&vFramePoses[i0][i1]))
			s0 = append(s0, p0)
		}
		framePosesT = append(framePosesT, s0)
	}
	obj.gFramePoses = framePosesT
	ret := obj.convert()
	return *(*ModelAnimation)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *ModelAnimation) Index(index int32) *ModelAnimation {
	ptr1 := (*ModelAnimation)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfModelAnimationValue)))
	return ptr1
}

// allocRayMemory allocates memory for type C.Ray in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayValue = unsafe.Sizeof([1]C.Ray{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearRayMemory(x *gRay) {
	if x != nil && x.allocsc546b0b2 != nil {
		x.allocsc546b0b2.(*cgoAllocMap).Free()
		x.refc546b0b2 = nil
		return
	}
}

// newRayRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRayRef(ref unsafe.Pointer) *gRay {
	if ref == nil {
		return nil
	}
	obj := new(gRay)
	obj.refc546b0b2 = (*C.Ray)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRay) passRef() (*C.Ray, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc546b0b2 != nil {
		if x.allocsc546b0b2 != nil {
			return x.refc546b0b2, x.allocsc546b0b2.(*cgoAllocMap)
		} else {
			return x.refc546b0b2, nil
		}
	}
	memc546b0b2 := unsafe.Pointer(new(C.Ray))
	refc546b0b2 := (*C.Ray)(memc546b0b2)
	allocsc546b0b2 := new(cgoAllocMap)
	// allocsc546b0b2.Add(memc546b0b2)

	var cposition_allocs *cgoAllocMap
	refc546b0b2.position, cposition_allocs = x.gPosition.passValue()
	allocsc546b0b2.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var cdirection_allocs *cgoAllocMap
	refc546b0b2.direction, cdirection_allocs = x.gDirection.passValue()
	allocsc546b0b2.Borrow(cdirection_allocs)
	x.gDirection = *new(gVector3)

	x.refc546b0b2 = refc546b0b2
	x.allocsc546b0b2 = allocsc546b0b2

	return refc546b0b2, allocsc546b0b2
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRay) passValue() (C.Ray, *cgoAllocMap) {
	if x.refc546b0b2 != nil {
		return *x.refc546b0b2, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gRay) gc() {
	a := x.allocsc546b0b2.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearRayMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gRay) convert() *Ray {
	if x.refc546b0b2 != nil {
		return (*Ray)(unsafe.Pointer(x.refc546b0b2))
	}
	x.passRef()
	return (*Ray)(unsafe.Pointer(x.refc546b0b2))
}

// NewRay new Go object and Mapping to C object.
func NewRay(vPosition Vector3, vDirection Vector3) Ray {
	obj := *new(gRay)
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&vPosition))
	obj.gDirection = *newVector3Ref(unsafe.Pointer(&vDirection))
	ret := obj.convert()
	return *(*Ray)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Ray) Index(index int32) *Ray {
	ptr1 := (*Ray)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRayValue)))
	return ptr1
}

// allocRayHitInfoMemory allocates memory for type C.RayHitInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRayHitInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRayHitInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRayHitInfoValue = unsafe.Sizeof([1]C.RayHitInfo{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearRayHitInfoMemory(x *gRayHitInfo) {
	if x != nil && x.allocsb8de43a9 != nil {
		x.allocsb8de43a9.(*cgoAllocMap).Free()
		x.refb8de43a9 = nil
		return
	}
}

// newRayHitInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRayHitInfoRef(ref unsafe.Pointer) *gRayHitInfo {
	if ref == nil {
		return nil
	}
	obj := new(gRayHitInfo)
	obj.refb8de43a9 = (*C.RayHitInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRayHitInfo) passRef() (*C.RayHitInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb8de43a9 != nil {
		if x.allocsb8de43a9 != nil {
			return x.refb8de43a9, x.allocsb8de43a9.(*cgoAllocMap)
		} else {
			return x.refb8de43a9, nil
		}
	}
	memb8de43a9 := unsafe.Pointer(new(C.RayHitInfo))
	refb8de43a9 := (*C.RayHitInfo)(memb8de43a9)
	allocsb8de43a9 := new(cgoAllocMap)
	// allocsb8de43a9.Add(memb8de43a9)

	var chit_allocs *cgoAllocMap
	refb8de43a9.hit, chit_allocs = (C._Bool)(x.gHit), cgoAllocsUnknown
	allocsb8de43a9.Borrow(chit_allocs)
	x.gHit = *new(bool)

	var cdistance_allocs *cgoAllocMap
	refb8de43a9.distance, cdistance_allocs = (C.float)(x.gDistance), cgoAllocsUnknown
	allocsb8de43a9.Borrow(cdistance_allocs)
	x.gDistance = *new(float32)

	var cposition_allocs *cgoAllocMap
	refb8de43a9.position, cposition_allocs = x.gPosition.passValue()
	allocsb8de43a9.Borrow(cposition_allocs)
	x.gPosition = *new(gVector3)

	var cnormal_allocs *cgoAllocMap
	refb8de43a9.normal, cnormal_allocs = x.gNormal.passValue()
	allocsb8de43a9.Borrow(cnormal_allocs)
	x.gNormal = *new(gVector3)

	x.refb8de43a9 = refb8de43a9
	x.allocsb8de43a9 = allocsb8de43a9

	return refb8de43a9, allocsb8de43a9
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRayHitInfo) passValue() (C.RayHitInfo, *cgoAllocMap) {
	if x.refb8de43a9 != nil {
		return *x.refb8de43a9, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gRayHitInfo) gc() {
	a := x.allocsb8de43a9.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearRayHitInfoMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gRayHitInfo) convert() *RayHitInfo {
	if x.refb8de43a9 != nil {
		return (*RayHitInfo)(unsafe.Pointer(x.refb8de43a9))
	}
	x.passRef()
	return (*RayHitInfo)(unsafe.Pointer(x.refb8de43a9))
}

// NewRayHitInfo new Go object and Mapping to C object.
func NewRayHitInfo(vHit bool, vDistance float32, vPosition Vector3, vNormal Vector3) RayHitInfo {
	obj := *new(gRayHitInfo)
	obj.gHit = vHit
	obj.gDistance = vDistance
	obj.gPosition = *newVector3Ref(unsafe.Pointer(&vPosition))
	obj.gNormal = *newVector3Ref(unsafe.Pointer(&vNormal))
	ret := obj.convert()
	return *(*RayHitInfo)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *RayHitInfo) Index(index int32) *RayHitInfo {
	ptr1 := (*RayHitInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRayHitInfoValue)))
	return ptr1
}

// allocBoundingBoxMemory allocates memory for type C.BoundingBox in C.
// The caller is responsible for freeing the this memory via C.free.
func allocBoundingBoxMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfBoundingBoxValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfBoundingBoxValue = unsafe.Sizeof([1]C.BoundingBox{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearBoundingBoxMemory(x *gBoundingBox) {
	if x != nil && x.allocsa54e9d16 != nil {
		x.allocsa54e9d16.(*cgoAllocMap).Free()
		x.refa54e9d16 = nil
		return
	}
}

// newBoundingBoxRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newBoundingBoxRef(ref unsafe.Pointer) *gBoundingBox {
	if ref == nil {
		return nil
	}
	obj := new(gBoundingBox)
	obj.refa54e9d16 = (*C.BoundingBox)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gBoundingBox) passRef() (*C.BoundingBox, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa54e9d16 != nil {
		if x.allocsa54e9d16 != nil {
			return x.refa54e9d16, x.allocsa54e9d16.(*cgoAllocMap)
		} else {
			return x.refa54e9d16, nil
		}
	}
	mema54e9d16 := unsafe.Pointer(new(C.BoundingBox))
	refa54e9d16 := (*C.BoundingBox)(mema54e9d16)
	allocsa54e9d16 := new(cgoAllocMap)
	// allocsa54e9d16.Add(mema54e9d16)

	var cmin_allocs *cgoAllocMap
	refa54e9d16.min, cmin_allocs = x.gMin.passValue()
	allocsa54e9d16.Borrow(cmin_allocs)
	x.gMin = *new(gVector3)

	var cmax_allocs *cgoAllocMap
	refa54e9d16.max, cmax_allocs = x.gMax.passValue()
	allocsa54e9d16.Borrow(cmax_allocs)
	x.gMax = *new(gVector3)

	x.refa54e9d16 = refa54e9d16
	x.allocsa54e9d16 = allocsa54e9d16

	return refa54e9d16, allocsa54e9d16
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gBoundingBox) passValue() (C.BoundingBox, *cgoAllocMap) {
	if x.refa54e9d16 != nil {
		return *x.refa54e9d16, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gBoundingBox) gc() {
	a := x.allocsa54e9d16.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearBoundingBoxMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gBoundingBox) convert() *BoundingBox {
	if x.refa54e9d16 != nil {
		return (*BoundingBox)(unsafe.Pointer(x.refa54e9d16))
	}
	x.passRef()
	return (*BoundingBox)(unsafe.Pointer(x.refa54e9d16))
}

// NewBoundingBox new Go object and Mapping to C object.
func NewBoundingBox(vMin Vector3, vMax Vector3) BoundingBox {
	obj := *new(gBoundingBox)
	obj.gMin = *newVector3Ref(unsafe.Pointer(&vMin))
	obj.gMax = *newVector3Ref(unsafe.Pointer(&vMax))
	ret := obj.convert()
	return *(*BoundingBox)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *BoundingBox) Index(index int32) *BoundingBox {
	ptr1 := (*BoundingBox)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfBoundingBoxValue)))
	return ptr1
}

// allocWaveMemory allocates memory for type C.Wave in C.
// The caller is responsible for freeing the this memory via C.free.
func allocWaveMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfWaveValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfWaveValue = unsafe.Sizeof([1]C.Wave{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearWaveMemory(x *gWave) {
	if x != nil && x.allocs7a3602b7 != nil {
		x.allocs7a3602b7.(*cgoAllocMap).Free()
		x.ref7a3602b7 = nil
		return
	}
}

// newWaveRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newWaveRef(ref unsafe.Pointer) *gWave {
	if ref == nil {
		return nil
	}
	obj := new(gWave)
	obj.ref7a3602b7 = (*C.Wave)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gWave) passRef() (*C.Wave, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref7a3602b7 != nil {
		if x.allocs7a3602b7 != nil {
			return x.ref7a3602b7, x.allocs7a3602b7.(*cgoAllocMap)
		} else {
			return x.ref7a3602b7, nil
		}
	}
	mem7a3602b7 := unsafe.Pointer(new(C.Wave))
	ref7a3602b7 := (*C.Wave)(mem7a3602b7)
	allocs7a3602b7 := new(cgoAllocMap)
	// allocs7a3602b7.Add(mem7a3602b7)

	var csampleCount_allocs *cgoAllocMap
	ref7a3602b7.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var csampleRate_allocs *cgoAllocMap
	ref7a3602b7.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref7a3602b7.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs7a3602b7.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref7a3602b7.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	var cdata_allocs *cgoAllocMap
	ref7a3602b7.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs7a3602b7.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	x.ref7a3602b7 = ref7a3602b7
	x.allocs7a3602b7 = allocs7a3602b7

	return ref7a3602b7, allocs7a3602b7
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gWave) passValue() (C.Wave, *cgoAllocMap) {
	if x.ref7a3602b7 != nil {
		return *x.ref7a3602b7, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gWave) gc() {
	a := x.allocs7a3602b7.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearWaveMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gWave) convert() *Wave {
	if x.ref7a3602b7 != nil {
		return (*Wave)(unsafe.Pointer(x.ref7a3602b7))
	}
	x.passRef()
	return (*Wave)(unsafe.Pointer(x.ref7a3602b7))
}

// NewWave new Go object and Mapping to C object.
func NewWave(vSampleCount uint32, vSampleRate uint32, vSampleSize uint32, vChannels uint32, vData unsafe.Pointer) Wave {
	obj := *new(gWave)
	obj.gSampleCount = vSampleCount
	obj.gSampleRate = vSampleRate
	obj.gSampleSize = vSampleSize
	obj.gChannels = vChannels
	obj.gData = vData
	ret := obj.convert()
	return *(*Wave)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Wave) Index(index int32) *Wave {
	ptr1 := (*Wave)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfWaveValue)))
	return ptr1
}

// allocAudioStreamMemory allocates memory for type C.AudioStream in C.
// The caller is responsible for freeing the this memory via C.free.
func allocAudioStreamMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfAudioStreamValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfAudioStreamValue = unsafe.Sizeof([1]C.AudioStream{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearAudioStreamMemory(x *gAudioStream) {
	if x != nil && x.allocs997374a2 != nil {
		x.allocs997374a2.(*cgoAllocMap).Free()
		x.ref997374a2 = nil
		return
	}
}

// newAudioStreamRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newAudioStreamRef(ref unsafe.Pointer) *gAudioStream {
	if ref == nil {
		return nil
	}
	obj := new(gAudioStream)
	obj.ref997374a2 = (*C.AudioStream)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gAudioStream) passRef() (*C.AudioStream, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref997374a2 != nil {
		if x.allocs997374a2 != nil {
			return x.ref997374a2, x.allocs997374a2.(*cgoAllocMap)
		} else {
			return x.ref997374a2, nil
		}
	}
	mem997374a2 := unsafe.Pointer(new(C.AudioStream))
	ref997374a2 := (*C.AudioStream)(mem997374a2)
	allocs997374a2 := new(cgoAllocMap)
	// allocs997374a2.Add(mem997374a2)

	var csampleRate_allocs *cgoAllocMap
	ref997374a2.sampleRate, csampleRate_allocs = (C.uint)(x.gSampleRate), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleRate_allocs)
	x.gSampleRate = *new(uint32)

	var csampleSize_allocs *cgoAllocMap
	ref997374a2.sampleSize, csampleSize_allocs = (C.uint)(x.gSampleSize), cgoAllocsUnknown
	allocs997374a2.Borrow(csampleSize_allocs)
	x.gSampleSize = *new(uint32)

	var cchannels_allocs *cgoAllocMap
	ref997374a2.channels, cchannels_allocs = (C.uint)(x.gChannels), cgoAllocsUnknown
	allocs997374a2.Borrow(cchannels_allocs)
	x.gChannels = *new(uint32)

	x.ref997374a2 = ref997374a2
	x.allocs997374a2 = allocs997374a2

	return ref997374a2, allocs997374a2
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gAudioStream) passValue() (C.AudioStream, *cgoAllocMap) {
	if x.ref997374a2 != nil {
		return *x.ref997374a2, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gAudioStream) gc() {
	a := x.allocs997374a2.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearAudioStreamMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gAudioStream) convert() *AudioStream {
	if x.ref997374a2 != nil {
		return (*AudioStream)(unsafe.Pointer(x.ref997374a2))
	}
	x.passRef()
	return (*AudioStream)(unsafe.Pointer(x.ref997374a2))
}

// NewAudioStream new Go object and Mapping to C object.
func NewAudioStream(vSampleRate uint32, vSampleSize uint32, vChannels uint32) AudioStream {
	obj := *new(gAudioStream)
	obj.gSampleRate = vSampleRate
	obj.gSampleSize = vSampleSize
	obj.gChannels = vChannels
	ret := obj.convert()
	return *(*AudioStream)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *AudioStream) Index(index int32) *AudioStream {
	ptr1 := (*AudioStream)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfAudioStreamValue)))
	return ptr1
}

// allocSoundMemory allocates memory for type C.Sound in C.
// The caller is responsible for freeing the this memory via C.free.
func allocSoundMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfSoundValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfSoundValue = unsafe.Sizeof([1]C.Sound{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearSoundMemory(x *gSound) {
	if x != nil && x.allocs394fec80 != nil {
		x.allocs394fec80.(*cgoAllocMap).Free()
		x.ref394fec80 = nil
		return
	}
}

// newSoundRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newSoundRef(ref unsafe.Pointer) *gSound {
	if ref == nil {
		return nil
	}
	obj := new(gSound)
	obj.ref394fec80 = (*C.Sound)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gSound) passRef() (*C.Sound, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref394fec80 != nil {
		if x.allocs394fec80 != nil {
			return x.ref394fec80, x.allocs394fec80.(*cgoAllocMap)
		} else {
			return x.ref394fec80, nil
		}
	}
	mem394fec80 := unsafe.Pointer(new(C.Sound))
	ref394fec80 := (*C.Sound)(mem394fec80)
	allocs394fec80 := new(cgoAllocMap)
	// allocs394fec80.Add(mem394fec80)

	var csampleCount_allocs *cgoAllocMap
	ref394fec80.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocs394fec80.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	ref394fec80.stream, cstream_allocs = x.gStream.passValue()
	allocs394fec80.Borrow(cstream_allocs)
	x.gStream = *new(gAudioStream)

	x.ref394fec80 = ref394fec80
	x.allocs394fec80 = allocs394fec80

	return ref394fec80, allocs394fec80
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gSound) passValue() (C.Sound, *cgoAllocMap) {
	if x.ref394fec80 != nil {
		return *x.ref394fec80, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gSound) gc() {
	a := x.allocs394fec80.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearSoundMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gSound) convert() *Sound {
	if x.ref394fec80 != nil {
		return (*Sound)(unsafe.Pointer(x.ref394fec80))
	}
	x.passRef()
	return (*Sound)(unsafe.Pointer(x.ref394fec80))
}

// NewSound new Go object and Mapping to C object.
func NewSound(vSampleCount uint32, vStream AudioStream) Sound {
	obj := *new(gSound)
	obj.gSampleCount = vSampleCount
	obj.gStream = *newAudioStreamRef(unsafe.Pointer(&vStream))
	ret := obj.convert()
	return *(*Sound)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Sound) Index(index int32) *Sound {
	ptr1 := (*Sound)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfSoundValue)))
	return ptr1
}

// allocMusicMemory allocates memory for type C.Music in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMusicMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMusicValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMusicValue = unsafe.Sizeof([1]C.Music{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearMusicMemory(x *gMusic) {
	if x != nil && x.allocsc930d4e != nil {
		x.allocsc930d4e.(*cgoAllocMap).Free()
		x.refc930d4e = nil
		return
	}
}

// newMusicRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMusicRef(ref unsafe.Pointer) *gMusic {
	if ref == nil {
		return nil
	}
	obj := new(gMusic)
	obj.refc930d4e = (*C.Music)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMusic) passRef() (*C.Music, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refc930d4e != nil {
		if x.allocsc930d4e != nil {
			return x.refc930d4e, x.allocsc930d4e.(*cgoAllocMap)
		} else {
			return x.refc930d4e, nil
		}
	}
	memc930d4e := unsafe.Pointer(new(C.Music))
	refc930d4e := (*C.Music)(memc930d4e)
	allocsc930d4e := new(cgoAllocMap)
	// allocsc930d4e.Add(memc930d4e)

	var cctxType_allocs *cgoAllocMap
	refc930d4e.ctxType, cctxType_allocs = (C.int)(x.gCtxType), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxType_allocs)
	x.gCtxType = *new(int32)

	var cctxData_allocs *cgoAllocMap
	refc930d4e.ctxData, cctxData_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gCtxData)), cgoAllocsUnknown
	allocsc930d4e.Borrow(cctxData_allocs)
	x.gCtxData = *new(unsafe.Pointer)

	var clooping_allocs *cgoAllocMap
	refc930d4e.looping, clooping_allocs = (C._Bool)(x.gLooping), cgoAllocsUnknown
	allocsc930d4e.Borrow(clooping_allocs)
	x.gLooping = *new(bool)

	var csampleCount_allocs *cgoAllocMap
	refc930d4e.sampleCount, csampleCount_allocs = (C.uint)(x.gSampleCount), cgoAllocsUnknown
	allocsc930d4e.Borrow(csampleCount_allocs)
	x.gSampleCount = *new(uint32)

	var cstream_allocs *cgoAllocMap
	refc930d4e.stream, cstream_allocs = x.gStream.passValue()
	allocsc930d4e.Borrow(cstream_allocs)
	x.gStream = *new(gAudioStream)

	x.refc930d4e = refc930d4e
	x.allocsc930d4e = allocsc930d4e

	return refc930d4e, allocsc930d4e
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMusic) passValue() (C.Music, *cgoAllocMap) {
	if x.refc930d4e != nil {
		return *x.refc930d4e, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gMusic) gc() {
	a := x.allocsc930d4e.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearMusicMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gMusic) convert() *Music {
	if x.refc930d4e != nil {
		return (*Music)(unsafe.Pointer(x.refc930d4e))
	}
	x.passRef()
	return (*Music)(unsafe.Pointer(x.refc930d4e))
}

// NewMusic new Go object and Mapping to C object.
func NewMusic(vCtxType int32, vCtxData unsafe.Pointer, vLooping bool, vSampleCount uint32, vStream AudioStream) Music {
	obj := *new(gMusic)
	obj.gCtxType = vCtxType
	obj.gCtxData = vCtxData
	obj.gLooping = vLooping
	obj.gSampleCount = vSampleCount
	obj.gStream = *newAudioStreamRef(unsafe.Pointer(&vStream))
	ret := obj.convert()
	return *(*Music)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *Music) Index(index int32) *Music {
	ptr1 := (*Music)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMusicValue)))
	return ptr1
}

// allocVrDeviceInfoMemory allocates memory for type C.VrDeviceInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVrDeviceInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVrDeviceInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVrDeviceInfoValue = unsafe.Sizeof([1]C.VrDeviceInfo{})

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearVrDeviceInfoMemory(x *gVrDeviceInfo) {
	if x != nil && x.allocs6e24e41d != nil {
		x.allocs6e24e41d.(*cgoAllocMap).Free()
		x.ref6e24e41d = nil
		return
	}
}

// newVrDeviceInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVrDeviceInfoRef(ref unsafe.Pointer) *gVrDeviceInfo {
	if ref == nil {
		return nil
	}
	obj := new(gVrDeviceInfo)
	obj.ref6e24e41d = (*C.VrDeviceInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVrDeviceInfo) passRef() (*C.VrDeviceInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref6e24e41d != nil {
		if x.allocs6e24e41d != nil {
			return x.ref6e24e41d, x.allocs6e24e41d.(*cgoAllocMap)
		} else {
			return x.ref6e24e41d, nil
		}
	}
	mem6e24e41d := unsafe.Pointer(new(C.VrDeviceInfo))
	ref6e24e41d := (*C.VrDeviceInfo)(mem6e24e41d)
	allocs6e24e41d := new(cgoAllocMap)
	// allocs6e24e41d.Add(mem6e24e41d)

	var chResolution_allocs *cgoAllocMap
	ref6e24e41d.hResolution, chResolution_allocs = (C.int)(x.gHResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chResolution_allocs)
	x.gHResolution = *new(int32)

	var cvResolution_allocs *cgoAllocMap
	ref6e24e41d.vResolution, cvResolution_allocs = (C.int)(x.gVResolution), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvResolution_allocs)
	x.gVResolution = *new(int32)

	var chScreenSize_allocs *cgoAllocMap
	ref6e24e41d.hScreenSize, chScreenSize_allocs = (C.float)(x.gHScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(chScreenSize_allocs)
	x.gHScreenSize = *new(float32)

	var cvScreenSize_allocs *cgoAllocMap
	ref6e24e41d.vScreenSize, cvScreenSize_allocs = (C.float)(x.gVScreenSize), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenSize_allocs)
	x.gVScreenSize = *new(float32)

	var cvScreenCenter_allocs *cgoAllocMap
	ref6e24e41d.vScreenCenter, cvScreenCenter_allocs = (C.float)(x.gVScreenCenter), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cvScreenCenter_allocs)
	x.gVScreenCenter = *new(float32)

	var ceyeToScreenDistance_allocs *cgoAllocMap
	ref6e24e41d.eyeToScreenDistance, ceyeToScreenDistance_allocs = (C.float)(x.gEyeToScreenDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(ceyeToScreenDistance_allocs)
	x.gEyeToScreenDistance = *new(float32)

	var clensSeparationDistance_allocs *cgoAllocMap
	ref6e24e41d.lensSeparationDistance, clensSeparationDistance_allocs = (C.float)(x.gLensSeparationDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensSeparationDistance_allocs)
	x.gLensSeparationDistance = *new(float32)

	var cinterpupillaryDistance_allocs *cgoAllocMap
	ref6e24e41d.interpupillaryDistance, cinterpupillaryDistance_allocs = (C.float)(x.gInterpupillaryDistance), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cinterpupillaryDistance_allocs)
	x.gInterpupillaryDistance = *new(float32)

	var clensDistortionValues_allocs *cgoAllocMap
	ref6e24e41d.lensDistortionValues, clensDistortionValues_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gLensDistortionValues)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(clensDistortionValues_allocs)
	x.gLensDistortionValues = *new([4]float32)

	var cchromaAbCorrection_allocs *cgoAllocMap
	ref6e24e41d.chromaAbCorrection, cchromaAbCorrection_allocs = *(*[4]C.float)(unsafe.Pointer(&x.gChromaAbCorrection)), cgoAllocsUnknown
	allocs6e24e41d.Borrow(cchromaAbCorrection_allocs)
	x.gChromaAbCorrection = *new([4]float32)

	x.ref6e24e41d = ref6e24e41d
	x.allocs6e24e41d = allocs6e24e41d

	return ref6e24e41d, allocs6e24e41d
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVrDeviceInfo) passValue() (C.VrDeviceInfo, *cgoAllocMap) {
	if x.ref6e24e41d != nil {
		return *x.ref6e24e41d, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gVrDeviceInfo) gc() {
	a := x.allocs6e24e41d.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearVrDeviceInfoMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gVrDeviceInfo) convert() *VrDeviceInfo {
	if x.ref6e24e41d != nil {
		return (*VrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
	}
	x.passRef()
	return (*VrDeviceInfo)(unsafe.Pointer(x.ref6e24e41d))
}

// NewVrDeviceInfo new Go object and Mapping to C object.
func NewVrDeviceInfo(vHResolution int32, vVResolution int32, vHScreenSize float32, vVScreenSize float32, vVScreenCenter float32, vEyeToScreenDistance float32, vLensSeparationDistance float32, vInterpupillaryDistance float32, vLensDistortionValues [4]float32, vChromaAbCorrection [4]float32) VrDeviceInfo {
	obj := *new(gVrDeviceInfo)
	obj.gHResolution = vHResolution
	obj.gVResolution = vVResolution
	obj.gHScreenSize = vHScreenSize
	obj.gVScreenSize = vVScreenSize
	obj.gVScreenCenter = vVScreenCenter
	obj.gEyeToScreenDistance = vEyeToScreenDistance
	obj.gLensSeparationDistance = vLensSeparationDistance
	obj.gInterpupillaryDistance = vInterpupillaryDistance
	obj.gLensDistortionValues = vLensDistortionValues
	obj.gChromaAbCorrection = vChromaAbCorrection
	ret := obj.convert()
	return *(*VrDeviceInfo)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *VrDeviceInfo) Index(index int32) *VrDeviceInfo {
	ptr1 := (*VrDeviceInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVrDeviceInfoValue)))
	return ptr1
}

// allocMultiTextMemory allocates memory for type C.MultiText in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMultiTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMultiTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMultiTextValue = unsafe.Sizeof([1]C.MultiText{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		var allocs0 *cgoAllocMap
		v0[i0], allocs0 = unpackMemoryPCharString(x[i0])
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackMemoryPCharString represents the data from Go string as *C.char and avoids copying.
func unpackMemoryPCharString(str string) (*C.char, *cgoAllocMap) {
	ptr0 := C.CString(str)
	mem0 := unsafe.Pointer(ptr0)
	allocs0 := new(cgoAllocMap)
	allocs0.Add(mem0)
	return ptr0, allocs0
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func clearMultiTextMemory(x *gMultiText) {
	if x != nil && x.allocsdf1ec495 != nil {
		x.allocsdf1ec495.(*cgoAllocMap).Free()
		x.refdf1ec495 = nil
		return
	}
}

// newMultiTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMultiTextRef(ref unsafe.Pointer) *gMultiText {
	if ref == nil {
		return nil
	}
	obj := new(gMultiText)
	obj.refdf1ec495 = (*C.MultiText)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMultiText) passRef() (*C.MultiText, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf1ec495 != nil {
		if x.allocsdf1ec495 != nil {
			return x.refdf1ec495, x.allocsdf1ec495.(*cgoAllocMap)
		} else {
			return x.refdf1ec495, nil
		}
	}
	memdf1ec495 := unsafe.Pointer(new(C.MultiText))
	refdf1ec495 := (*C.MultiText)(memdf1ec495)
	allocsdf1ec495 := new(cgoAllocMap)
	// allocsdf1ec495.Add(memdf1ec495)

	var ctext_allocs *cgoAllocMap
	refdf1ec495.text, ctext_allocs = unpackSString(x.gText)
	allocsdf1ec495.Borrow(ctext_allocs)
	x.gText = *new([]string)

	x.refdf1ec495 = refdf1ec495
	x.allocsdf1ec495 = allocsdf1ec495

	return refdf1ec495, allocsdf1ec495
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMultiText) passValue() (C.MultiText, *cgoAllocMap) {
	if x.refdf1ec495 != nil {
		return *x.refdf1ec495, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// gc is register for garbage collection.
func (x *gMultiText) gc() {
	a := x.allocsdf1ec495.(*cgoAllocMap)
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, clearMultiTextMemory)
	}
}

// convert struct for mapping C struct unanimous.
func (x *gMultiText) convert() *MultiText {
	if x.refdf1ec495 != nil {
		return (*MultiText)(unsafe.Pointer(x.refdf1ec495))
	}
	x.passRef()
	return (*MultiText)(unsafe.Pointer(x.refdf1ec495))
}

// NewMultiText new Go object and Mapping to C object.
func NewMultiText(vText []string) MultiText {
	obj := *new(gMultiText)
	obj.gText = vText
	ret := obj.convert()
	return *(*MultiText)(unsafe.Pointer(ret))
}

// Index reads Go data structure out from plain C format.
func (x *MultiText) Index(index int32) *MultiText {
	ptr1 := (*MultiText)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMultiTextValue)))
	return ptr1
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
