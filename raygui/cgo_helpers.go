// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Mon, 03 Aug 2020 11:53:51 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raygui

/*
#include "../lib/raygui/src/raygui.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("add reference, still exist: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocGuiStylePropMemory allocates memory for type C.GuiStyleProp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGuiStylePropMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGuiStylePropValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGuiStylePropValue = unsafe.Sizeof([1]C.GuiStyleProp{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *GuiStyleProp) Ref() *C.GuiStyleProp {
	if x == nil {
		return nil
	}
	return x.ref8760bcee
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *GuiStyleProp) ResetRef() {
	if x == nil {
		return
	}
	x.ref8760bcee = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GuiStyleProp) FreeRef() {
	if x != nil && x.allocs8760bcee != nil {
		x.allocs8760bcee.(*cgoAllocMap).Free()
		x.ref8760bcee = nil
		return
	}
	if x != nil && x.ref8760bcee != nil && x.allocs8760bcee == nil {
		C.free(unsafe.Pointer(x.ref8760bcee))
		x.ref8760bcee = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeGuiStyleProp(x *GuiStyleProp) {
	if x != nil && x.allocs8760bcee != nil {
		x.allocs8760bcee.(*cgoAllocMap).Free()
		x.ref8760bcee = nil
		// fmt.Printf("GuiStyleProp memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs8760bcee.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.GuiStyleProp memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewGuiStylePropRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGuiStylePropRef(ref unsafe.Pointer) *GuiStyleProp {
	if ref == nil {
		return nil
	}
	obj := new(GuiStyleProp)
	obj.ref8760bcee = (*C.GuiStyleProp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GuiStyleProp) PassRef() (*C.GuiStyleProp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8760bcee != nil {
		return x.ref8760bcee, nil
	}
	mem8760bcee := unsafe.Pointer(new(C.GuiStyleProp))
	ref8760bcee := (*C.GuiStyleProp)(mem8760bcee)
	allocs8760bcee := new(cgoAllocMap)
	// allocs8760bcee.Add(mem8760bcee)

	var ccontrolId_allocs *cgoAllocMap
	ref8760bcee.controlId, ccontrolId_allocs = (C.ushort)(x.ControlId), cgoAllocsUnknown
	allocs8760bcee.Borrow(ccontrolId_allocs)
	x.ControlId = *new(uint16)

	var cpropertyId_allocs *cgoAllocMap
	ref8760bcee.propertyId, cpropertyId_allocs = (C.ushort)(x.PropertyId), cgoAllocsUnknown
	allocs8760bcee.Borrow(cpropertyId_allocs)
	x.PropertyId = *new(uint16)

	var cpropertyValue_allocs *cgoAllocMap
	ref8760bcee.propertyValue, cpropertyValue_allocs = (C.int)(x.PropertyValue), cgoAllocsUnknown
	allocs8760bcee.Borrow(cpropertyValue_allocs)
	x.PropertyValue = *new(int32)

	x.ref8760bcee = ref8760bcee
	x.allocs8760bcee = allocs8760bcee
	defer func() {
		if len(x.allocs8760bcee.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeGuiStyleProp)
		}
	}()
	return ref8760bcee, allocs8760bcee

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GuiStyleProp) PassValue() (C.GuiStyleProp, *cgoAllocMap) {
	if x.ref8760bcee != nil {
		return *x.ref8760bcee, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *GuiStyleProp) Convert() *guiStyleProp {
	if x.ref8760bcee != nil {
		return (*guiStyleProp)(unsafe.Pointer(x.ref8760bcee))
	}
	x.PassRef()
	return (*guiStyleProp)(unsafe.Pointer(x.ref8760bcee))
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) Ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector2) ResetRef() {
	if x == nil {
		return
	}
	x.ref29ca61a5 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector2) FreeRef() {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		return
	}
	if x != nil && x.ref29ca61a5 != nil && x.allocs29ca61a5 == nil {
		C.free(unsafe.Pointer(x.ref29ca61a5))
		x.ref29ca61a5 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.Y = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector2) Convert() *vector2 {
	if x.ref29ca61a5 != nil {
		return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.PassRef()
	return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector3) Ref() *C.Vector3 {
	if x == nil {
		return nil
	}
	return x.ref5ecd5133
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector3) ResetRef() {
	if x == nil {
		return
	}
	x.ref5ecd5133 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector3) FreeRef() {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		return
	}
	if x != nil && x.ref5ecd5133 != nil && x.allocs5ecd5133 == nil {
		C.free(unsafe.Pointer(x.ref5ecd5133))
		x.ref5ecd5133 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector3(x *Vector3) {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		// fmt.Printf("Vector3 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ecd5133.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector3 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector3Ref(ref unsafe.Pointer) *Vector3 {
	if ref == nil {
		return nil
	}
	obj := new(Vector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector3) PassRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		return x.ref5ecd5133, nil
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.Y = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.Z), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.Z = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133
	defer func() {
		if len(x.allocs5ecd5133.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector3)
		}
	}()
	return ref5ecd5133, allocs5ecd5133

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector3) PassValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Vector3) Convert() *vector3 {
	if x.ref5ecd5133 != nil {
		return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.PassRef()
	return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) Ref() *C.Color {
	if x == nil {
		return nil
	}
	return x.refa79767ed
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Color) ResetRef() {
	if x == nil {
		return
	}
	x.refa79767ed = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) FreeRef() {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		return
	}
	if x != nil && x.refa79767ed != nil && x.allocsa79767ed == nil {
		C.free(unsafe.Pointer(x.refa79767ed))
		x.refa79767ed = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeColor(x *Color) {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		// fmt.Printf("Color memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa79767ed.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Color memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		return x.refa79767ed, nil
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.R), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.R = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.G), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.G = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.B), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.B = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.A), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.A = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed
	defer func() {
		if len(x.allocsa79767ed.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeColor)
		}
	}()
	return refa79767ed, allocsa79767ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Color) Convert() *color {
	if x.refa79767ed != nil {
		return (*color)(unsafe.Pointer(x.refa79767ed))
	}
	x.PassRef()
	return (*color)(unsafe.Pointer(x.refa79767ed))
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) Ref() *C.Rectangle {
	if x == nil {
		return nil
	}
	return x.refcee8783a
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Rectangle) ResetRef() {
	if x == nil {
		return
	}
	x.refcee8783a = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rectangle) FreeRef() {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		return
	}
	if x != nil && x.refcee8783a != nil && x.allocscee8783a == nil {
		C.free(unsafe.Pointer(x.refcee8783a))
		x.refcee8783a = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRectangle(x *Rectangle) {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		// fmt.Printf("Rectangle memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocscee8783a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Rectangle memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		return x.refcee8783a, nil
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.Y = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.Width), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.Width = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.Height), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.Height = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a
	defer func() {
		if len(x.allocscee8783a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRectangle)
		}
	}()
	return refcee8783a, allocscee8783a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Rectangle) Convert() *rectangle {
	if x.refcee8783a != nil {
		return (*rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.PassRef()
	return (*rectangle)(unsafe.Pointer(x.refcee8783a))
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture2D) Ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Texture2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture2D) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture2D(x *Texture2D) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTexture2DRef(ref unsafe.Pointer) *Texture2D {
	if ref == nil {
		return nil
	}
	obj := new(Texture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture2D) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.Width), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.Width = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.Height), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.Height = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.Mipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.Mipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.Format), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.Format = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture2D)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture2D) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Texture2D) Convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Font) Ref() *C.Font {
	if x == nil {
		return nil
	}
	return x.ref70a6a7ec
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Font) ResetRef() {
	if x == nil {
		return
	}
	x.ref70a6a7ec = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Font) FreeRef() {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		return
	}
	if x != nil && x.ref70a6a7ec != nil && x.allocs70a6a7ec == nil {
		C.free(unsafe.Pointer(x.ref70a6a7ec))
		x.ref70a6a7ec = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeFont(x *Font) {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		// fmt.Printf("Font memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs70a6a7ec.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Font memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontRef(ref unsafe.Pointer) *Font {
	if ref == nil {
		return nil
	}
	obj := new(Font)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Font) PassRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		return x.ref70a6a7ec, nil
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.BaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.BaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.CharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.CharsCount = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.Texture.PassValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.Texture = *new(Texture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.Recs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.Recs = *new([]Rectangle)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec
	defer func() {
		if len(x.allocs70a6a7ec.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeFont)
		}
	}()
	return ref70a6a7ec, allocs70a6a7ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Font) PassValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Convert struct for mapping C struct unanimous.
func (x *Font) Convert() *font {
	if x.ref70a6a7ec != nil {
		return (*font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.PassRef()
	return (*font)(unsafe.Pointer(x.ref70a6a7ec))
}

// GetTexture returns a reference to C object within a struct
func (s *Font) GetTexture() *Texture2D {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.Ref().texture))
	return ret
}

// GetRecs returns a reference to C object within a struct
func (s *Font) GetRecs(recsIndex int32) *Rectangle {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	// c struct pointer offset
	ptr0 := s.Ref().recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(recsIndex)*uintptr(sizeOfRectangleValue)))

	ret = NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackArgSString transforms a sliced Go data structure into plain C format.
func unpackArgSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		v0[i0], _ = unpackPCharString(x[i0])
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// packSString reads sliced Go data structure out from plain C format.
func packSString(v []string, ptr0 **C.char) {
	const m = 0x7fffffff
	for i0 := range v {
		ptr1 := (*(*[m / sizeOfPtr]*C.char)(unsafe.Pointer(ptr0)))[i0]
		v[i0] = packPCharString(ptr1)
	}
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
