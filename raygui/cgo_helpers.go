// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sat, 22 Aug 2020 07:53:22 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raygui

/*
#include "../lib/raygui/src/raygui.h"
#include "../lib/raygui/src/ricons.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("reference add into gc collector, gc collector count: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocTextMemory allocates memory for type C.Text in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextValue = unsafe.Sizeof([1]C.Text{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		var allocs0 *cgoAllocMap
		v0[i0], allocs0 = unpackMemoryPCharString(x[i0])
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackMemoryPCharString represents the data from Go string as *C.char and avoids copying.
func unpackMemoryPCharString(str string) (*C.char, *cgoAllocMap) {
	ptr0 := C.CString(str)
	mem0 := unsafe.Pointer(ptr0)
	allocs0 := new(cgoAllocMap)
	allocs0.Add(mem0)
	return ptr0, allocs0
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Text) ref() *C.Text {
	if x == nil {
		return nil
	}
	return x.ref9bb908f9
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Text) ResetRef() {
	if x == nil {
		return
	}
	x.ref9bb908f9 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Text) FreeRef() {
	if x != nil && x.allocs9bb908f9 != nil {
		x.allocs9bb908f9.(*cgoAllocMap).Free()
		x.ref9bb908f9 = nil
		return
	}
	if x != nil && x.ref9bb908f9 != nil && x.allocs9bb908f9 == nil {
		C.free(unsafe.Pointer(x.ref9bb908f9))
		x.ref9bb908f9 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeText(x *Text) {
	if x != nil && x.allocs9bb908f9 != nil {
		x.allocs9bb908f9.(*cgoAllocMap).Free()
		x.ref9bb908f9 = nil
		// fmt.Printf("Text memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs9bb908f9.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Text memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewText new Go object and Mapping to C object.
func NewText(gText []string) Text {
	obj := *new(Text)
	obj.gText = gText
	return obj
}

// NewTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTextRef(ref unsafe.Pointer) *Text {
	if ref == nil {
		return nil
	}
	obj := new(Text)
	obj.ref9bb908f9 = (*C.Text)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Text) PassRef() (*C.Text, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref9bb908f9 != nil {
		return x.ref9bb908f9, nil
	}
	mem9bb908f9 := unsafe.Pointer(new(C.Text))
	ref9bb908f9 := (*C.Text)(mem9bb908f9)
	allocs9bb908f9 := new(cgoAllocMap)
	// allocs9bb908f9.Add(mem9bb908f9)

	var ctext_allocs *cgoAllocMap
	ref9bb908f9.text, ctext_allocs = unpackSString(x.gText)
	allocs9bb908f9.Borrow(ctext_allocs)
	x.gText = *new([]string)

	x.ref9bb908f9 = ref9bb908f9
	x.allocs9bb908f9 = allocs9bb908f9
	defer func() {
		if len(x.allocs9bb908f9.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeText)
		}
	}()
	return ref9bb908f9, allocs9bb908f9

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Text) PassValue() (C.Text, *cgoAllocMap) {
	if x.ref9bb908f9 != nil {
		return *x.ref9bb908f9, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Text) Offset(index int32) *Text {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Text)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTextValue)))
	ret := NewTextRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Text) Convert() *text {
	if x.ref9bb908f9 != nil {
		return (*text)(unsafe.Pointer(x.ref9bb908f9))
	}
	x.PassRef()
	return (*text)(unsafe.Pointer(x.ref9bb908f9))
}

// GetText returns a reference to C object within a struct

// SetText update C object and binding struct

// allocGuiStylePropMemory allocates memory for type C.GuiStyleProp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGuiStylePropMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGuiStylePropValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGuiStylePropValue = unsafe.Sizeof([1]C.GuiStyleProp{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *GuiStyleProp) ref() *C.GuiStyleProp {
	if x == nil {
		return nil
	}
	return x.ref8760bcee
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *GuiStyleProp) ResetRef() {
	if x == nil {
		return
	}
	x.ref8760bcee = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *GuiStyleProp) FreeRef() {
	if x != nil && x.allocs8760bcee != nil {
		x.allocs8760bcee.(*cgoAllocMap).Free()
		x.ref8760bcee = nil
		return
	}
	if x != nil && x.ref8760bcee != nil && x.allocs8760bcee == nil {
		C.free(unsafe.Pointer(x.ref8760bcee))
		x.ref8760bcee = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeGuiStyleProp(x *GuiStyleProp) {
	if x != nil && x.allocs8760bcee != nil {
		x.allocs8760bcee.(*cgoAllocMap).Free()
		x.ref8760bcee = nil
		// fmt.Printf("GuiStyleProp memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs8760bcee.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.GuiStyleProp memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewGuiStyleProp new Go object and Mapping to C object.
func NewGuiStyleProp(gControlId uint16, gPropertyId uint16, gPropertyValue int32) GuiStyleProp {
	obj := *new(GuiStyleProp)
	obj.gControlId = gControlId
	obj.gPropertyId = gPropertyId
	obj.gPropertyValue = gPropertyValue
	return obj
}

// NewGuiStylePropRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewGuiStylePropRef(ref unsafe.Pointer) *GuiStyleProp {
	if ref == nil {
		return nil
	}
	obj := new(GuiStyleProp)
	obj.ref8760bcee = (*C.GuiStyleProp)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *GuiStyleProp) PassRef() (*C.GuiStyleProp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8760bcee != nil {
		return x.ref8760bcee, nil
	}
	mem8760bcee := unsafe.Pointer(new(C.GuiStyleProp))
	ref8760bcee := (*C.GuiStyleProp)(mem8760bcee)
	allocs8760bcee := new(cgoAllocMap)
	// allocs8760bcee.Add(mem8760bcee)

	var ccontrolId_allocs *cgoAllocMap
	ref8760bcee.controlId, ccontrolId_allocs = (C.ushort)(x.gControlId), cgoAllocsUnknown
	allocs8760bcee.Borrow(ccontrolId_allocs)
	x.gControlId = *new(uint16)

	var cpropertyId_allocs *cgoAllocMap
	ref8760bcee.propertyId, cpropertyId_allocs = (C.ushort)(x.gPropertyId), cgoAllocsUnknown
	allocs8760bcee.Borrow(cpropertyId_allocs)
	x.gPropertyId = *new(uint16)

	var cpropertyValue_allocs *cgoAllocMap
	ref8760bcee.propertyValue, cpropertyValue_allocs = (C.int)(x.gPropertyValue), cgoAllocsUnknown
	allocs8760bcee.Borrow(cpropertyValue_allocs)
	x.gPropertyValue = *new(int32)

	x.ref8760bcee = ref8760bcee
	x.allocs8760bcee = allocs8760bcee
	defer func() {
		if len(x.allocs8760bcee.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeGuiStyleProp)
		}
	}()
	return ref8760bcee, allocs8760bcee

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x GuiStyleProp) PassValue() (C.GuiStyleProp, *cgoAllocMap) {
	if x.ref8760bcee != nil {
		return *x.ref8760bcee, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *GuiStyleProp) Offset(index int32) *GuiStyleProp {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.GuiStyleProp)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfGuiStylePropValue)))
	ret := NewGuiStylePropRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *GuiStyleProp) Convert() *guiStyleProp {
	if x.ref8760bcee != nil {
		return (*guiStyleProp)(unsafe.Pointer(x.ref8760bcee))
	}
	x.PassRef()
	return (*guiStyleProp)(unsafe.Pointer(x.ref8760bcee))
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector2) ResetRef() {
	if x == nil {
		return
	}
	x.ref29ca61a5 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector2) FreeRef() {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		return
	}
	if x != nil && x.ref29ca61a5 != nil && x.allocs29ca61a5 == nil {
		C.free(unsafe.Pointer(x.ref29ca61a5))
		x.ref29ca61a5 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(gX float32, gY float32) Vector2 {
	obj := *new(Vector2)
	obj.gX = gX
	obj.gY = gY
	return obj
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Vector2) Offset(index int32) *Vector2 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	ret := NewVector2Ref(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Vector2) Convert() *vector2 {
	if x.ref29ca61a5 != nil {
		return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.PassRef()
	return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector3) ref() *C.Vector3 {
	if x == nil {
		return nil
	}
	return x.ref5ecd5133
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector3) ResetRef() {
	if x == nil {
		return
	}
	x.ref5ecd5133 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector3) FreeRef() {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		return
	}
	if x != nil && x.ref5ecd5133 != nil && x.allocs5ecd5133 == nil {
		C.free(unsafe.Pointer(x.ref5ecd5133))
		x.ref5ecd5133 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector3(x *Vector3) {
	if x != nil && x.allocs5ecd5133 != nil {
		x.allocs5ecd5133.(*cgoAllocMap).Free()
		x.ref5ecd5133 = nil
		// fmt.Printf("Vector3 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs5ecd5133.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector3 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector3 new Go object and Mapping to C object.
func NewVector3(gX float32, gY float32, gZ float32) Vector3 {
	obj := *new(Vector3)
	obj.gX = gX
	obj.gY = gY
	obj.gZ = gZ
	return obj
}

// NewVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector3Ref(ref unsafe.Pointer) *Vector3 {
	if ref == nil {
		return nil
	}
	obj := new(Vector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector3) PassRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		return x.ref5ecd5133, nil
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.gZ = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133
	defer func() {
		if len(x.allocs5ecd5133.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector3)
		}
	}()
	return ref5ecd5133, allocs5ecd5133

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector3) PassValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Vector3) Offset(index int32) *Vector3 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector3)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector3Value)))
	ret := NewVector3Ref(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Vector3) Convert() *vector3 {
	if x.ref5ecd5133 != nil {
		return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.PassRef()
	return (*vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Color) ref() *C.Color {
	if x == nil {
		return nil
	}
	return x.refa79767ed
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Color) ResetRef() {
	if x == nil {
		return
	}
	x.refa79767ed = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Color) FreeRef() {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		return
	}
	if x != nil && x.refa79767ed != nil && x.allocsa79767ed == nil {
		C.free(unsafe.Pointer(x.refa79767ed))
		x.refa79767ed = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeColor(x *Color) {
	if x != nil && x.allocsa79767ed != nil {
		x.allocsa79767ed.(*cgoAllocMap).Free()
		x.refa79767ed = nil
		// fmt.Printf("Color memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsa79767ed.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Color memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewColor new Go object and Mapping to C object.
func NewColor(gR byte, gG byte, gB byte, gA byte) Color {
	obj := *new(Color)
	obj.gR = gR
	obj.gG = gG
	obj.gB = gB
	obj.gA = gA
	return obj
}

// NewColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewColorRef(ref unsafe.Pointer) *Color {
	if ref == nil {
		return nil
	}
	obj := new(Color)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Color) PassRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		return x.refa79767ed, nil
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.gR), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.gR = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.gG), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.gG = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.gB), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.gB = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.gA), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.gA = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed
	defer func() {
		if len(x.allocsa79767ed.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeColor)
		}
	}()
	return refa79767ed, allocsa79767ed

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Color) PassValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Color) Offset(index int32) *Color {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Color)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfColorValue)))
	ret := NewColorRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Color) Convert() *color {
	if x.refa79767ed != nil {
		return (*color)(unsafe.Pointer(x.refa79767ed))
	}
	x.PassRef()
	return (*color)(unsafe.Pointer(x.refa79767ed))
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Rectangle) ref() *C.Rectangle {
	if x == nil {
		return nil
	}
	return x.refcee8783a
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Rectangle) ResetRef() {
	if x == nil {
		return
	}
	x.refcee8783a = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Rectangle) FreeRef() {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		return
	}
	if x != nil && x.refcee8783a != nil && x.allocscee8783a == nil {
		C.free(unsafe.Pointer(x.refcee8783a))
		x.refcee8783a = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeRectangle(x *Rectangle) {
	if x != nil && x.allocscee8783a != nil {
		x.allocscee8783a.(*cgoAllocMap).Free()
		x.refcee8783a = nil
		// fmt.Printf("Rectangle memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocscee8783a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Rectangle memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewRectangle new Go object and Mapping to C object.
func NewRectangle(gX float32, gY float32, gWidth float32, gHeight float32) Rectangle {
	obj := *new(Rectangle)
	obj.gX = gX
	obj.gY = gY
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	return obj
}

// NewRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewRectangleRef(ref unsafe.Pointer) *Rectangle {
	if ref == nil {
		return nil
	}
	obj := new(Rectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Rectangle) PassRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		return x.refcee8783a, nil
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.gWidth), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.gWidth = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.gHeight), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.gHeight = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a
	defer func() {
		if len(x.allocscee8783a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeRectangle)
		}
	}()
	return refcee8783a, allocscee8783a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Rectangle) PassValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Rectangle) Offset(index int32) *Rectangle {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	ret := NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Rectangle) Convert() *rectangle {
	if x.refcee8783a != nil {
		return (*rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.PassRef()
	return (*rectangle)(unsafe.Pointer(x.refcee8783a))
}

// allocTexture2DMemory allocates memory for type C.Texture2D in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTexture2DMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTexture2DValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTexture2DValue = unsafe.Sizeof([1]C.Texture2D{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Texture2D) ref() *C.Texture2D {
	if x == nil {
		return nil
	}
	return x.ref3c51a40b
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Texture2D) ResetRef() {
	if x == nil {
		return
	}
	x.ref3c51a40b = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Texture2D) FreeRef() {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		return
	}
	if x != nil && x.ref3c51a40b != nil && x.allocs3c51a40b == nil {
		C.free(unsafe.Pointer(x.ref3c51a40b))
		x.ref3c51a40b = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeTexture2D(x *Texture2D) {
	if x != nil && x.allocs3c51a40b != nil {
		x.allocs3c51a40b.(*cgoAllocMap).Free()
		x.ref3c51a40b = nil
		// fmt.Printf("Texture2D memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs3c51a40b.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Texture2D memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewTexture2D new Go object and Mapping to C object.
func NewTexture2D(gId uint32, gWidth int32, gHeight int32, gMipmaps int32, gFormat int32) Texture2D {
	obj := *new(Texture2D)
	obj.gId = gId
	obj.gWidth = gWidth
	obj.gHeight = gHeight
	obj.gMipmaps = gMipmaps
	obj.gFormat = gFormat
	return obj
}

// NewTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewTexture2DRef(ref unsafe.Pointer) *Texture2D {
	if ref == nil {
		return nil
	}
	obj := new(Texture2D)
	obj.ref3c51a40b = (*C.Texture2D)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Texture2D) PassRef() (*C.Texture2D, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref3c51a40b != nil {
		return x.ref3c51a40b, nil
	}
	mem3c51a40b := unsafe.Pointer(new(C.Texture2D))
	ref3c51a40b := (*C.Texture2D)(mem3c51a40b)
	allocs3c51a40b := new(cgoAllocMap)
	// allocs3c51a40b.Add(mem3c51a40b)

	var cid_allocs *cgoAllocMap
	ref3c51a40b.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref3c51a40b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref3c51a40b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref3c51a40b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref3c51a40b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs3c51a40b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref3c51a40b = ref3c51a40b
	x.allocs3c51a40b = allocs3c51a40b
	defer func() {
		if len(x.allocs3c51a40b.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeTexture2D)
		}
	}()
	return ref3c51a40b, allocs3c51a40b

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Texture2D) PassValue() (C.Texture2D, *cgoAllocMap) {
	if x.ref3c51a40b != nil {
		return *x.ref3c51a40b, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Texture2D) Offset(index int32) *Texture2D {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfTexture2DValue)))
	ret := NewTexture2DRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Texture2D) Convert() *texture2D {
	if x.ref3c51a40b != nil {
		return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
	}
	x.PassRef()
	return (*texture2D)(unsafe.Pointer(x.ref3c51a40b))
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []Rectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Font) ref() *C.Font {
	if x == nil {
		return nil
	}
	return x.ref70a6a7ec
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Font) ResetRef() {
	if x == nil {
		return
	}
	x.ref70a6a7ec = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Font) FreeRef() {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		return
	}
	if x != nil && x.ref70a6a7ec != nil && x.allocs70a6a7ec == nil {
		C.free(unsafe.Pointer(x.ref70a6a7ec))
		x.ref70a6a7ec = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeFont(x *Font) {
	if x != nil && x.allocs70a6a7ec != nil {
		x.allocs70a6a7ec.(*cgoAllocMap).Free()
		x.ref70a6a7ec = nil
		// fmt.Printf("Font memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs70a6a7ec.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Font memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewFont new Go object and Mapping to C object.
func NewFont(gBaseSize int32, gCharsCount int32, gTexture Texture2D, gRecs []Rectangle) Font {
	obj := *new(Font)
	obj.gBaseSize = gBaseSize
	obj.gCharsCount = gCharsCount
	obj.gTexture = gTexture
	obj.gRecs = gRecs
	return obj
}

// NewFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewFontRef(ref unsafe.Pointer) *Font {
	if ref == nil {
		return nil
	}
	obj := new(Font)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Font) PassRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		return x.ref70a6a7ec, nil
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.gBaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.gBaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.gCharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.gCharsCount = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.gTexture.PassValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.gTexture = *new(Texture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.gRecs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.gRecs = *new([]Rectangle)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec
	defer func() {
		if len(x.allocs70a6a7ec.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeFont)
		}
	}()
	return ref70a6a7ec, allocs70a6a7ec

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Font) PassValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Offset reads Go data structure out from plain C format.
func (x *Font) Offset(index int32) *Font {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Font)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfFontValue)))
	ret := NewFontRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Font) Convert() *font {
	if x.ref70a6a7ec != nil {
		return (*font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.PassRef()
	return (*font)(unsafe.Pointer(x.ref70a6a7ec))
}

// GetTexture returns a reference to C object within a struct
func (s *Font) GetTexture() *Texture2D {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Texture2D
	ret = NewTexture2DRef(unsafe.Pointer(&s.ref().texture))
	return ret
}

// GetRecs returns a reference to C object within a struct
func (s *Font) GetRecs(recsIndex int32) *Rectangle {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Rectangle
	// c struct pointer offset
	ptr0 := s.ref().recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(recsIndex)*uintptr(sizeOfRectangleValue)))

	ret = NewRectangleRef(unsafe.Pointer(ptr1))
	return ret
}

// SetRecs update C object and binding struct
func (s *Font) SetRecs(recsIndex int32, rectangle Rectangle) *Font {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.Rectangle
	if rectangle.ref() == nil {
		__ret, _ = rectangle.PassRef()
	} else {
		__ret = rectangle.ref()
	}
	ptr0 := s.ref().recs
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(recsIndex)*uintptr(sizeOfRectangleValue))

	*(*C.Rectangle)(ptr) = *__ret
	return s
}

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
