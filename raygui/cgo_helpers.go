// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Wed, 13 Jan 2021 14:37:51 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package raygui

/*
#include "../lib/raygui/src/raygui.h"
#include "../lib/raygui/src/ricons.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)
var allocReferenceCount int

func init() {
	allocReferenceCount = 0
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	defer a.mux.Unlock()

	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	allocReferenceCount++
	fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory alloc\n", ptr)
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	defer a.mux.RUnlock()

	isEmpty := len(a.m) == 0
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}

	b.mux.Lock()
	defer b.mux.Unlock()
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
}

func (a *cgoAllocMap) Free() {
	a.mux.Lock()
	defer a.mux.Unlock()

	for ptr := range a.m {
		C.free(ptr)
		delete(a.m, ptr)

		allocReferenceCount--
		fmt.Printf("INFO: MEMORY: [PTR %p] CGO memory free\n", ptr)
	}
}

// allocGuiStylePropMemory allocates memory for type C.GuiStyleProp in C.
// The caller is responsible for freeing the this memory via C.free.
func allocGuiStylePropMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfGuiStylePropValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfGuiStylePropValue = unsafe.Sizeof([1]C.GuiStyleProp{})

// newGuiStylePropRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newGuiStylePropRef(ref unsafe.Pointer) *gGuiStyleProp {
	if ref == nil {
		return nil
	}
	obj := new(gGuiStyleProp)
	obj.ref8760bcee = (*C.GuiStyleProp)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gGuiStyleProp) passRef() (*C.GuiStyleProp, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref8760bcee != nil {
		if x.allocs8760bcee != nil {
			return x.ref8760bcee, x.allocs8760bcee.(*cgoAllocMap)
		} else {
			return x.ref8760bcee, nil
		}
	}
	mem8760bcee := unsafe.Pointer(new(C.GuiStyleProp))
	ref8760bcee := (*C.GuiStyleProp)(mem8760bcee)
	allocs8760bcee := new(cgoAllocMap)
	// allocs8760bcee.Add(mem8760bcee)

	var ccontrolId_allocs *cgoAllocMap
	ref8760bcee.controlId, ccontrolId_allocs = (C.ushort)(x.gControlId), cgoAllocsUnknown
	allocs8760bcee.Borrow(ccontrolId_allocs)
	x.gControlId = *new(uint16)

	var cpropertyId_allocs *cgoAllocMap
	ref8760bcee.propertyId, cpropertyId_allocs = (C.ushort)(x.gPropertyId), cgoAllocsUnknown
	allocs8760bcee.Borrow(cpropertyId_allocs)
	x.gPropertyId = *new(uint16)

	var cpropertyValue_allocs *cgoAllocMap
	ref8760bcee.propertyValue, cpropertyValue_allocs = (C.int)(x.gPropertyValue), cgoAllocsUnknown
	allocs8760bcee.Borrow(cpropertyValue_allocs)
	x.gPropertyValue = *new(int32)

	x.ref8760bcee = ref8760bcee
	x.allocs8760bcee = allocs8760bcee

	return ref8760bcee, allocs8760bcee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gGuiStyleProp) passValue() (C.GuiStyleProp, *cgoAllocMap) {
	if x.ref8760bcee != nil {
		return *x.ref8760bcee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gGuiStyleProp) convert() *GuiStyleProp {
	if x.ref8760bcee != nil {
		return (*GuiStyleProp)(unsafe.Pointer(x.ref8760bcee))
	}
	x.passRef()
	return (*GuiStyleProp)(unsafe.Pointer(x.ref8760bcee))
}

// NewGuiStyleProp new Go object and Mapping to C object.
func NewGuiStyleProp(cControlId uint16, cPropertyId uint16, cPropertyValue int32) GuiStyleProp {
	obj := *new(gGuiStyleProp)
	obj.gControlId = cControlId
	obj.gPropertyId = cPropertyId
	obj.gPropertyValue = cPropertyValue

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocGuiStyleProp.")
	}
	return *(*GuiStyleProp)(unsafe.Pointer(ret0))
}

// AllocGuiStyleProp new Go object and Mapping to C object.
func AllocGuiStyleProp(cControlId uint16, cPropertyId uint16, cPropertyValue int32) (*GuiStyleProp, *cgoAllocMap) {
	obj := *new(gGuiStyleProp)
	obj.gControlId = cControlId
	obj.gPropertyId = cPropertyId
	obj.gPropertyValue = cPropertyValue

	ret0, alloc0 := obj.passRef()
	ret1 := (*GuiStyleProp)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *GuiStyleProp) Index(index int32) *GuiStyleProp {
	ptr1 := (*GuiStyleProp)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfGuiStylePropValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *GuiStyleProp) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*GuiStyleProp) {
			a.Free()
		})
	}
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// newVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector2Ref(ref unsafe.Pointer) *gVector2 {
	if ref == nil {
		return nil
	}
	obj := new(gVector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector2) passRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		if x.allocs29ca61a5 != nil {
			return x.ref29ca61a5, x.allocs29ca61a5.(*cgoAllocMap)
		} else {
			return x.ref29ca61a5, nil
		}
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5

	return ref29ca61a5, allocs29ca61a5
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector2) passValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVector2) convert() *Vector2 {
	if x.ref29ca61a5 != nil {
		return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.passRef()
	return (*Vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(cX float32, cY float32) Vector2 {
	obj := *new(gVector2)
	obj.gX = cX
	obj.gY = cY

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVector2.")
	}
	return *(*Vector2)(unsafe.Pointer(ret0))
}

// AllocVector2 new Go object and Mapping to C object.
func AllocVector2(cX float32, cY float32) (*Vector2, *cgoAllocMap) {
	obj := *new(gVector2)
	obj.gX = cX
	obj.gY = cY

	ret0, alloc0 := obj.passRef()
	ret1 := (*Vector2)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Vector2) Index(index int32) *Vector2 {
	ptr1 := (*Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Vector2) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Vector2) {
			a.Free()
		})
	}
}

// allocVector3Memory allocates memory for type C.Vector3 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector3Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector3Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector3Value = unsafe.Sizeof([1]C.Vector3{})

// newVector3Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newVector3Ref(ref unsafe.Pointer) *gVector3 {
	if ref == nil {
		return nil
	}
	obj := new(gVector3)
	obj.ref5ecd5133 = (*C.Vector3)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gVector3) passRef() (*C.Vector3, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref5ecd5133 != nil {
		if x.allocs5ecd5133 != nil {
			return x.ref5ecd5133, x.allocs5ecd5133.(*cgoAllocMap)
		} else {
			return x.ref5ecd5133, nil
		}
	}
	mem5ecd5133 := unsafe.Pointer(new(C.Vector3))
	ref5ecd5133 := (*C.Vector3)(mem5ecd5133)
	allocs5ecd5133 := new(cgoAllocMap)
	// allocs5ecd5133.Add(mem5ecd5133)

	var cx_allocs *cgoAllocMap
	ref5ecd5133.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref5ecd5133.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cz_allocs *cgoAllocMap
	ref5ecd5133.z, cz_allocs = (C.float)(x.gZ), cgoAllocsUnknown
	allocs5ecd5133.Borrow(cz_allocs)
	x.gZ = *new(float32)

	x.ref5ecd5133 = ref5ecd5133
	x.allocs5ecd5133 = allocs5ecd5133

	return ref5ecd5133, allocs5ecd5133
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gVector3) passValue() (C.Vector3, *cgoAllocMap) {
	if x.ref5ecd5133 != nil {
		return *x.ref5ecd5133, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gVector3) convert() *Vector3 {
	if x.ref5ecd5133 != nil {
		return (*Vector3)(unsafe.Pointer(x.ref5ecd5133))
	}
	x.passRef()
	return (*Vector3)(unsafe.Pointer(x.ref5ecd5133))
}

// NewVector3 new Go object and Mapping to C object.
func NewVector3(cX float32, cY float32, cZ float32) Vector3 {
	obj := *new(gVector3)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocVector3.")
	}
	return *(*Vector3)(unsafe.Pointer(ret0))
}

// AllocVector3 new Go object and Mapping to C object.
func AllocVector3(cX float32, cY float32, cZ float32) (*Vector3, *cgoAllocMap) {
	obj := *new(gVector3)
	obj.gX = cX
	obj.gY = cY
	obj.gZ = cZ

	ret0, alloc0 := obj.passRef()
	ret1 := (*Vector3)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Vector3) Index(index int32) *Vector3 {
	ptr1 := (*Vector3)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfVector3Value)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Vector3) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Vector3) {
			a.Free()
		})
	}
}

// allocColorMemory allocates memory for type C.Color in C.
// The caller is responsible for freeing the this memory via C.free.
func allocColorMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfColorValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfColorValue = unsafe.Sizeof([1]C.Color{})

// newColorRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newColorRef(ref unsafe.Pointer) *gColor {
	if ref == nil {
		return nil
	}
	obj := new(gColor)
	obj.refa79767ed = (*C.Color)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gColor) passRef() (*C.Color, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refa79767ed != nil {
		if x.allocsa79767ed != nil {
			return x.refa79767ed, x.allocsa79767ed.(*cgoAllocMap)
		} else {
			return x.refa79767ed, nil
		}
	}
	mema79767ed := unsafe.Pointer(new(C.Color))
	refa79767ed := (*C.Color)(mema79767ed)
	allocsa79767ed := new(cgoAllocMap)
	// allocsa79767ed.Add(mema79767ed)

	var cr_allocs *cgoAllocMap
	refa79767ed.r, cr_allocs = (C.uchar)(x.gR), cgoAllocsUnknown
	allocsa79767ed.Borrow(cr_allocs)
	x.gR = *new(byte)

	var cg_allocs *cgoAllocMap
	refa79767ed.g, cg_allocs = (C.uchar)(x.gG), cgoAllocsUnknown
	allocsa79767ed.Borrow(cg_allocs)
	x.gG = *new(byte)

	var cb_allocs *cgoAllocMap
	refa79767ed.b, cb_allocs = (C.uchar)(x.gB), cgoAllocsUnknown
	allocsa79767ed.Borrow(cb_allocs)
	x.gB = *new(byte)

	var ca_allocs *cgoAllocMap
	refa79767ed.a, ca_allocs = (C.uchar)(x.gA), cgoAllocsUnknown
	allocsa79767ed.Borrow(ca_allocs)
	x.gA = *new(byte)

	x.refa79767ed = refa79767ed
	x.allocsa79767ed = allocsa79767ed

	return refa79767ed, allocsa79767ed
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gColor) passValue() (C.Color, *cgoAllocMap) {
	if x.refa79767ed != nil {
		return *x.refa79767ed, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gColor) convert() *Color {
	if x.refa79767ed != nil {
		return (*Color)(unsafe.Pointer(x.refa79767ed))
	}
	x.passRef()
	return (*Color)(unsafe.Pointer(x.refa79767ed))
}

// NewColor new Go object and Mapping to C object.
func NewColor(cR byte, cG byte, cB byte, cA byte) Color {
	obj := *new(gColor)
	obj.gR = cR
	obj.gG = cG
	obj.gB = cB
	obj.gA = cA

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocColor.")
	}
	return *(*Color)(unsafe.Pointer(ret0))
}

// AllocColor new Go object and Mapping to C object.
func AllocColor(cR byte, cG byte, cB byte, cA byte) (*Color, *cgoAllocMap) {
	obj := *new(gColor)
	obj.gR = cR
	obj.gG = cG
	obj.gB = cB
	obj.gA = cA

	ret0, alloc0 := obj.passRef()
	ret1 := (*Color)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Color) Index(index int32) *Color {
	ptr1 := (*Color)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfColorValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Color) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Color) {
			a.Free()
		})
	}
}

// allocRectangleMemory allocates memory for type C.Rectangle in C.
// The caller is responsible for freeing the this memory via C.free.
func allocRectangleMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfRectangleValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfRectangleValue = unsafe.Sizeof([1]C.Rectangle{})

// newRectangleRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newRectangleRef(ref unsafe.Pointer) *gRectangle {
	if ref == nil {
		return nil
	}
	obj := new(gRectangle)
	obj.refcee8783a = (*C.Rectangle)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gRectangle) passRef() (*C.Rectangle, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refcee8783a != nil {
		if x.allocscee8783a != nil {
			return x.refcee8783a, x.allocscee8783a.(*cgoAllocMap)
		} else {
			return x.refcee8783a, nil
		}
	}
	memcee8783a := unsafe.Pointer(new(C.Rectangle))
	refcee8783a := (*C.Rectangle)(memcee8783a)
	allocscee8783a := new(cgoAllocMap)
	// allocscee8783a.Add(memcee8783a)

	var cx_allocs *cgoAllocMap
	refcee8783a.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocscee8783a.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	refcee8783a.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocscee8783a.Borrow(cy_allocs)
	x.gY = *new(float32)

	var cwidth_allocs *cgoAllocMap
	refcee8783a.width, cwidth_allocs = (C.float)(x.gWidth), cgoAllocsUnknown
	allocscee8783a.Borrow(cwidth_allocs)
	x.gWidth = *new(float32)

	var cheight_allocs *cgoAllocMap
	refcee8783a.height, cheight_allocs = (C.float)(x.gHeight), cgoAllocsUnknown
	allocscee8783a.Borrow(cheight_allocs)
	x.gHeight = *new(float32)

	x.refcee8783a = refcee8783a
	x.allocscee8783a = allocscee8783a

	return refcee8783a, allocscee8783a
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gRectangle) passValue() (C.Rectangle, *cgoAllocMap) {
	if x.refcee8783a != nil {
		return *x.refcee8783a, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gRectangle) convert() *Rectangle {
	if x.refcee8783a != nil {
		return (*Rectangle)(unsafe.Pointer(x.refcee8783a))
	}
	x.passRef()
	return (*Rectangle)(unsafe.Pointer(x.refcee8783a))
}

// NewRectangle new Go object and Mapping to C object.
func NewRectangle(cX float32, cY float32, cWidth float32, cHeight float32) Rectangle {
	obj := *new(gRectangle)
	obj.gX = cX
	obj.gY = cY
	obj.gWidth = cWidth
	obj.gHeight = cHeight

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocRectangle.")
	}
	return *(*Rectangle)(unsafe.Pointer(ret0))
}

// AllocRectangle new Go object and Mapping to C object.
func AllocRectangle(cX float32, cY float32, cWidth float32, cHeight float32) (*Rectangle, *cgoAllocMap) {
	obj := *new(gRectangle)
	obj.gX = cX
	obj.gY = cY
	obj.gWidth = cWidth
	obj.gHeight = cHeight

	ret0, alloc0 := obj.passRef()
	ret1 := (*Rectangle)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Rectangle) Index(index int32) *Rectangle {
	ptr1 := (*Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Rectangle) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Rectangle) {
			a.Free()
		})
	}
}

// allocImageMemory allocates memory for type C.Image in C.
// The caller is responsible for freeing the this memory via C.free.
func allocImageMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfImageValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfImageValue = unsafe.Sizeof([1]C.Image{})

// newImageRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newImageRef(ref unsafe.Pointer) *gImage {
	if ref == nil {
		return nil
	}
	obj := new(gImage)
	obj.ref4fc2b5b = (*C.Image)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gImage) passRef() (*C.Image, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4fc2b5b != nil {
		if x.allocs4fc2b5b != nil {
			return x.ref4fc2b5b, x.allocs4fc2b5b.(*cgoAllocMap)
		} else {
			return x.ref4fc2b5b, nil
		}
	}
	mem4fc2b5b := unsafe.Pointer(new(C.Image))
	ref4fc2b5b := (*C.Image)(mem4fc2b5b)
	allocs4fc2b5b := new(cgoAllocMap)
	// allocs4fc2b5b.Add(mem4fc2b5b)

	var cdata_allocs *cgoAllocMap
	ref4fc2b5b.data, cdata_allocs = *(*unsafe.Pointer)(unsafe.Pointer(&x.gData)), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cdata_allocs)
	x.gData = *new(unsafe.Pointer)

	var cwidth_allocs *cgoAllocMap
	ref4fc2b5b.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4fc2b5b.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4fc2b5b.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4fc2b5b.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4fc2b5b.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4fc2b5b = ref4fc2b5b
	x.allocs4fc2b5b = allocs4fc2b5b

	return ref4fc2b5b, allocs4fc2b5b
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gImage) passValue() (C.Image, *cgoAllocMap) {
	if x.ref4fc2b5b != nil {
		return *x.ref4fc2b5b, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gImage) convert() *Image {
	if x.ref4fc2b5b != nil {
		return (*Image)(unsafe.Pointer(x.ref4fc2b5b))
	}
	x.passRef()
	return (*Image)(unsafe.Pointer(x.ref4fc2b5b))
}

// NewImage new Go object and Mapping to C object.
func NewImage(cData unsafe.Pointer, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) Image {
	obj := *new(gImage)
	obj.gData = cData
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocImage.")
	}
	return *(*Image)(unsafe.Pointer(ret0))
}

// AllocImage new Go object and Mapping to C object.
func AllocImage(cData unsafe.Pointer, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*Image, *cgoAllocMap) {
	obj := *new(gImage)
	obj.gData = cData
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*Image)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Image) Index(index int32) *Image {
	ptr1 := (*Image)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfImageValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Image) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Image) {
			a.Free()
		})
	}
}

// allocTextureMemory allocates memory for type C.Texture in C.
// The caller is responsible for freeing the this memory via C.free.
func allocTextureMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfTextureValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfTextureValue = unsafe.Sizeof([1]C.Texture{})

// newTextureRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTextureRef(ref unsafe.Pointer) *gTexture {
	if ref == nil {
		return nil
	}
	obj := new(gTexture)
	obj.ref4ddb34ee = (*C.Texture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTexture) passRef() (*C.Texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ddb34ee != nil {
		if x.allocs4ddb34ee != nil {
			return x.ref4ddb34ee, x.allocs4ddb34ee.(*cgoAllocMap)
		} else {
			return x.ref4ddb34ee, nil
		}
	}
	mem4ddb34ee := unsafe.Pointer(new(C.Texture))
	ref4ddb34ee := (*C.Texture)(mem4ddb34ee)
	allocs4ddb34ee := new(cgoAllocMap)
	// allocs4ddb34ee.Add(mem4ddb34ee)

	var cid_allocs *cgoAllocMap
	ref4ddb34ee.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref4ddb34ee.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4ddb34ee.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4ddb34ee.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4ddb34ee.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4ddb34ee = ref4ddb34ee
	x.allocs4ddb34ee = allocs4ddb34ee

	return ref4ddb34ee, allocs4ddb34ee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTexture) passValue() (C.Texture, *cgoAllocMap) {
	if x.ref4ddb34ee != nil {
		return *x.ref4ddb34ee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTexture) convert() *Texture {
	if x.ref4ddb34ee != nil {
		return (*Texture)(unsafe.Pointer(x.ref4ddb34ee))
	}
	x.passRef()
	return (*Texture)(unsafe.Pointer(x.ref4ddb34ee))
}

// NewTexture new Go object and Mapping to C object.
func NewTexture(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) Texture {
	obj := *new(gTexture)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTexture.")
	}
	return *(*Texture)(unsafe.Pointer(ret0))
}

// AllocTexture new Go object and Mapping to C object.
func AllocTexture(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*Texture, *cgoAllocMap) {
	obj := *new(gTexture)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*Texture)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Texture) Index(index int32) *Texture {
	ptr1 := (*Texture)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Texture) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Texture) {
			a.Free()
		})
	}
}

// newTexture2DRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTexture2DRef(ref unsafe.Pointer) *gTexture2D {
	if ref == nil {
		return nil
	}
	obj := new(gTexture2D)
	obj.ref4ddb34ee = (*C.Texture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTexture2D) passRef() (*C.Texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ddb34ee != nil {
		if x.allocs4ddb34ee != nil {
			return x.ref4ddb34ee, x.allocs4ddb34ee.(*cgoAllocMap)
		} else {
			return x.ref4ddb34ee, nil
		}
	}
	mem4ddb34ee := unsafe.Pointer(new(C.Texture))
	ref4ddb34ee := (*C.Texture)(mem4ddb34ee)
	allocs4ddb34ee := new(cgoAllocMap)
	// allocs4ddb34ee.Add(mem4ddb34ee)

	var cid_allocs *cgoAllocMap
	ref4ddb34ee.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref4ddb34ee.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4ddb34ee.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4ddb34ee.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4ddb34ee.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4ddb34ee = ref4ddb34ee
	x.allocs4ddb34ee = allocs4ddb34ee

	return ref4ddb34ee, allocs4ddb34ee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTexture2D) passValue() (C.Texture, *cgoAllocMap) {
	if x.ref4ddb34ee != nil {
		return *x.ref4ddb34ee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTexture2D) convert() *Texture2D {
	if x.ref4ddb34ee != nil {
		return (*Texture2D)(unsafe.Pointer(x.ref4ddb34ee))
	}
	x.passRef()
	return (*Texture2D)(unsafe.Pointer(x.ref4ddb34ee))
}

// NewTexture2D new Go object and Mapping to C object.
func NewTexture2D(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) Texture2D {
	obj := *new(gTexture2D)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTexture2D.")
	}
	return *(*Texture2D)(unsafe.Pointer(ret0))
}

// AllocTexture2D new Go object and Mapping to C object.
func AllocTexture2D(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*Texture2D, *cgoAllocMap) {
	obj := *new(gTexture2D)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*Texture2D)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Texture2D) Index(index int32) *Texture2D {
	ptr1 := (*Texture2D)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Texture2D) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Texture2D) {
			a.Free()
		})
	}
}

// newTextureCubemapRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newTextureCubemapRef(ref unsafe.Pointer) *gTextureCubemap {
	if ref == nil {
		return nil
	}
	obj := new(gTextureCubemap)
	obj.ref4ddb34ee = (*C.Texture)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gTextureCubemap) passRef() (*C.Texture, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4ddb34ee != nil {
		if x.allocs4ddb34ee != nil {
			return x.ref4ddb34ee, x.allocs4ddb34ee.(*cgoAllocMap)
		} else {
			return x.ref4ddb34ee, nil
		}
	}
	mem4ddb34ee := unsafe.Pointer(new(C.Texture))
	ref4ddb34ee := (*C.Texture)(mem4ddb34ee)
	allocs4ddb34ee := new(cgoAllocMap)
	// allocs4ddb34ee.Add(mem4ddb34ee)

	var cid_allocs *cgoAllocMap
	ref4ddb34ee.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cwidth_allocs *cgoAllocMap
	ref4ddb34ee.width, cwidth_allocs = (C.int)(x.gWidth), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cwidth_allocs)
	x.gWidth = *new(int32)

	var cheight_allocs *cgoAllocMap
	ref4ddb34ee.height, cheight_allocs = (C.int)(x.gHeight), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cheight_allocs)
	x.gHeight = *new(int32)

	var cmipmaps_allocs *cgoAllocMap
	ref4ddb34ee.mipmaps, cmipmaps_allocs = (C.int)(x.gMipmaps), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cmipmaps_allocs)
	x.gMipmaps = *new(int32)

	var cformat_allocs *cgoAllocMap
	ref4ddb34ee.format, cformat_allocs = (C.int)(x.gFormat), cgoAllocsUnknown
	allocs4ddb34ee.Borrow(cformat_allocs)
	x.gFormat = *new(int32)

	x.ref4ddb34ee = ref4ddb34ee
	x.allocs4ddb34ee = allocs4ddb34ee

	return ref4ddb34ee, allocs4ddb34ee
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gTextureCubemap) passValue() (C.Texture, *cgoAllocMap) {
	if x.ref4ddb34ee != nil {
		return *x.ref4ddb34ee, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gTextureCubemap) convert() *TextureCubemap {
	if x.ref4ddb34ee != nil {
		return (*TextureCubemap)(unsafe.Pointer(x.ref4ddb34ee))
	}
	x.passRef()
	return (*TextureCubemap)(unsafe.Pointer(x.ref4ddb34ee))
}

// NewTextureCubemap new Go object and Mapping to C object.
func NewTextureCubemap(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) TextureCubemap {
	obj := *new(gTextureCubemap)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocTextureCubemap.")
	}
	return *(*TextureCubemap)(unsafe.Pointer(ret0))
}

// AllocTextureCubemap new Go object and Mapping to C object.
func AllocTextureCubemap(cId uint32, cWidth int32, cHeight int32, cMipmaps int32, cFormat int32) (*TextureCubemap, *cgoAllocMap) {
	obj := *new(gTextureCubemap)
	obj.gId = cId
	obj.gWidth = cWidth
	obj.gHeight = cHeight
	obj.gMipmaps = cMipmaps
	obj.gFormat = cFormat

	ret0, alloc0 := obj.passRef()
	ret1 := (*TextureCubemap)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *TextureCubemap) Index(index int32) *TextureCubemap {
	ptr1 := (*TextureCubemap)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfTextureValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *TextureCubemap) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*TextureCubemap) {
			a.Free()
		})
	}
}

// allocCharInfoMemory allocates memory for type C.CharInfo in C.
// The caller is responsible for freeing the this memory via C.free.
func allocCharInfoMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfCharInfoValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfCharInfoValue = unsafe.Sizeof([1]C.CharInfo{})

// newCharInfoRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newCharInfoRef(ref unsafe.Pointer) *gCharInfo {
	if ref == nil {
		return nil
	}
	obj := new(gCharInfo)
	obj.ref702c36c0 = (*C.CharInfo)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gCharInfo) passRef() (*C.CharInfo, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref702c36c0 != nil {
		if x.allocs702c36c0 != nil {
			return x.ref702c36c0, x.allocs702c36c0.(*cgoAllocMap)
		} else {
			return x.ref702c36c0, nil
		}
	}
	mem702c36c0 := unsafe.Pointer(new(C.CharInfo))
	ref702c36c0 := (*C.CharInfo)(mem702c36c0)
	allocs702c36c0 := new(cgoAllocMap)
	// allocs702c36c0.Add(mem702c36c0)

	var cvalue_allocs *cgoAllocMap
	ref702c36c0.value, cvalue_allocs = (C.int)(x.gValue), cgoAllocsUnknown
	allocs702c36c0.Borrow(cvalue_allocs)
	x.gValue = *new(int32)

	var coffsetX_allocs *cgoAllocMap
	ref702c36c0.offsetX, coffsetX_allocs = (C.int)(x.gOffsetX), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetX_allocs)
	x.gOffsetX = *new(int32)

	var coffsetY_allocs *cgoAllocMap
	ref702c36c0.offsetY, coffsetY_allocs = (C.int)(x.gOffsetY), cgoAllocsUnknown
	allocs702c36c0.Borrow(coffsetY_allocs)
	x.gOffsetY = *new(int32)

	var cadvanceX_allocs *cgoAllocMap
	ref702c36c0.advanceX, cadvanceX_allocs = (C.int)(x.gAdvanceX), cgoAllocsUnknown
	allocs702c36c0.Borrow(cadvanceX_allocs)
	x.gAdvanceX = *new(int32)

	var cimage_allocs *cgoAllocMap
	ref702c36c0.image, cimage_allocs = x.gImage.passValue()
	allocs702c36c0.Borrow(cimage_allocs)
	x.gImage = *new(gImage)

	x.ref702c36c0 = ref702c36c0
	x.allocs702c36c0 = allocs702c36c0

	return ref702c36c0, allocs702c36c0
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gCharInfo) passValue() (C.CharInfo, *cgoAllocMap) {
	if x.ref702c36c0 != nil {
		return *x.ref702c36c0, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gCharInfo) convert() *CharInfo {
	if x.ref702c36c0 != nil {
		return (*CharInfo)(unsafe.Pointer(x.ref702c36c0))
	}
	x.passRef()
	return (*CharInfo)(unsafe.Pointer(x.ref702c36c0))
}

// NewCharInfo new Go object and Mapping to C object.
func NewCharInfo(cValue int32, cOffsetX int32, cOffsetY int32, cAdvanceX int32, cImage Image) CharInfo {
	obj := *new(gCharInfo)
	obj.gValue = cValue
	obj.gOffsetX = cOffsetX
	obj.gOffsetY = cOffsetY
	obj.gAdvanceX = cAdvanceX
	obj.gImage = *newImageRef(unsafe.Pointer(&cImage))

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocCharInfo.")
	}
	return *(*CharInfo)(unsafe.Pointer(ret0))
}

// AllocCharInfo new Go object and Mapping to C object.
func AllocCharInfo(cValue int32, cOffsetX int32, cOffsetY int32, cAdvanceX int32, cImage Image) (*CharInfo, *cgoAllocMap) {
	obj := *new(gCharInfo)
	obj.gValue = cValue
	obj.gOffsetX = cOffsetX
	obj.gOffsetY = cOffsetY
	obj.gAdvanceX = cAdvanceX
	obj.gImage = *newImageRef(unsafe.Pointer(&cImage))

	ret0, alloc0 := obj.passRef()
	ret1 := (*CharInfo)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *CharInfo) Index(index int32) *CharInfo {
	ptr1 := (*CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfCharInfoValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *CharInfo) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*CharInfo) {
			a.Free()
		})
	}
}

// allocFontMemory allocates memory for type C.Font in C.
// The caller is responsible for freeing the this memory via C.free.
func allocFontMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfFontValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfFontValue = unsafe.Sizeof([1]C.Font{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackSRectangle transforms a sliced Go data structure into plain C format.
func unpackSRectangle(x []gRectangle) (unpacked *C.Rectangle, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.Rectangle) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocRectangleMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.Rectangle)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.Rectangle)(h.Data)
	return
}

// unpackSCharInfo transforms a sliced Go data structure into plain C format.
func unpackSCharInfo(x []gCharInfo) (unpacked *C.CharInfo, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.CharInfo) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocCharInfoMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.CharInfo)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].passValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.CharInfo)(h.Data)
	return
}

// newFontRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newFontRef(ref unsafe.Pointer) *gFont {
	if ref == nil {
		return nil
	}
	obj := new(gFont)
	obj.ref70a6a7ec = (*C.Font)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gFont) passRef() (*C.Font, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref70a6a7ec != nil {
		if x.allocs70a6a7ec != nil {
			return x.ref70a6a7ec, x.allocs70a6a7ec.(*cgoAllocMap)
		} else {
			return x.ref70a6a7ec, nil
		}
	}
	mem70a6a7ec := unsafe.Pointer(new(C.Font))
	ref70a6a7ec := (*C.Font)(mem70a6a7ec)
	allocs70a6a7ec := new(cgoAllocMap)
	// allocs70a6a7ec.Add(mem70a6a7ec)

	var cbaseSize_allocs *cgoAllocMap
	ref70a6a7ec.baseSize, cbaseSize_allocs = (C.int)(x.gBaseSize), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(cbaseSize_allocs)
	x.gBaseSize = *new(int32)

	var ccharsCount_allocs *cgoAllocMap
	ref70a6a7ec.charsCount, ccharsCount_allocs = (C.int)(x.gCharsCount), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsCount_allocs)
	x.gCharsCount = *new(int32)

	var ccharsPadding_allocs *cgoAllocMap
	ref70a6a7ec.charsPadding, ccharsPadding_allocs = (C.int)(x.gCharsPadding), cgoAllocsUnknown
	allocs70a6a7ec.Borrow(ccharsPadding_allocs)
	x.gCharsPadding = *new(int32)

	var ctexture_allocs *cgoAllocMap
	ref70a6a7ec.texture, ctexture_allocs = x.gTexture.passValue()
	allocs70a6a7ec.Borrow(ctexture_allocs)
	x.gTexture = *new(gTexture2D)

	var crecs_allocs *cgoAllocMap
	ref70a6a7ec.recs, crecs_allocs = unpackSRectangle(x.gRecs)
	allocs70a6a7ec.Borrow(crecs_allocs)
	x.gRecs = *new([]gRectangle)

	var cchars_allocs *cgoAllocMap
	ref70a6a7ec.chars, cchars_allocs = unpackSCharInfo(x.gChars)
	allocs70a6a7ec.Borrow(cchars_allocs)
	x.gChars = *new([]gCharInfo)

	x.ref70a6a7ec = ref70a6a7ec
	x.allocs70a6a7ec = allocs70a6a7ec

	return ref70a6a7ec, allocs70a6a7ec
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gFont) passValue() (C.Font, *cgoAllocMap) {
	if x.ref70a6a7ec != nil {
		return *x.ref70a6a7ec, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gFont) convert() *Font {
	if x.ref70a6a7ec != nil {
		return (*Font)(unsafe.Pointer(x.ref70a6a7ec))
	}
	x.passRef()
	return (*Font)(unsafe.Pointer(x.ref70a6a7ec))
}

// NewFont new Go object and Mapping to C object.
func NewFont(cBaseSize int32, cCharsCount int32, cCharsPadding int32, cTexture Texture2D, cRecs []Rectangle, cChars []CharInfo) Font {
	obj := *new(gFont)
	obj.gBaseSize = cBaseSize
	obj.gCharsCount = cCharsCount
	obj.gCharsPadding = cCharsPadding
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&cTexture))

	var recs0 []gRectangle
	for i0 := range cRecs {
		p0 := *newRectangleRef(unsafe.Pointer(&cRecs[i0]))
		recs0 = append(recs0, p0)
	}
	obj.gRecs = recs0

	var chars0 []gCharInfo
	for i0 := range cChars {
		p0 := *newCharInfoRef(unsafe.Pointer(&cChars[i0]))
		chars0 = append(chars0, p0)
	}
	obj.gChars = chars0

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocFont.")
	}
	return *(*Font)(unsafe.Pointer(ret0))
}

// AllocFont new Go object and Mapping to C object.
func AllocFont(cBaseSize int32, cCharsCount int32, cCharsPadding int32, cTexture Texture2D, cRecs []Rectangle, cChars []CharInfo) (*Font, *cgoAllocMap) {
	obj := *new(gFont)
	obj.gBaseSize = cBaseSize
	obj.gCharsCount = cCharsCount
	obj.gCharsPadding = cCharsPadding
	obj.gTexture = *newTexture2DRef(unsafe.Pointer(&cTexture))

	var recs0 []gRectangle
	for i0 := range cRecs {
		p0 := *newRectangleRef(unsafe.Pointer(&cRecs[i0]))
		recs0 = append(recs0, p0)
	}
	obj.gRecs = recs0

	var chars0 []gCharInfo
	for i0 := range cChars {
		p0 := *newCharInfoRef(unsafe.Pointer(&cChars[i0]))
		chars0 = append(chars0, p0)
	}
	obj.gChars = chars0

	ret0, alloc0 := obj.passRef()
	ret1 := (*Font)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *Font) Index(index int32) *Font {
	ptr1 := (*Font)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfFontValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *Font) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*Font) {
			a.Free()
		})
	}
}

// Recs returns a reference to C object within a struct
func (x *Font) Recser(index int32) *Rectangle {
	var ret *Rectangle

	ptr0 := x.Recs
	ptr1 := (*C.Rectangle)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfRectangleValue)))
	ret = newRectangleRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// Chars returns a reference to C object within a struct
func (x *Font) Charser(index int32) *CharInfo {
	var ret *CharInfo

	ptr0 := x.Chars
	ptr1 := (*C.CharInfo)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfCharInfoValue)))
	ret = newCharInfoRef(unsafe.Pointer(ptr1)).convert()

	return ret
}

// allocMultiTextMemory allocates memory for type C.MultiText in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMultiTextMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMultiTextValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMultiTextValue = unsafe.Sizeof([1]C.MultiText{})

// allocPCharMemory allocates memory for type *C.char in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPCharMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPCharValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPCharValue = unsafe.Sizeof([1]*C.char{})

// unpackSString transforms a sliced Go data structure into plain C format.
func unpackSString(x []string) (unpacked **C.char, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(***C.char) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocPCharMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]*C.char)(unsafe.Pointer(h0))
	for i0 := range x {
		var allocs0 *cgoAllocMap
		v0[i0], allocs0 = unpackMemoryPCharString(x[i0])
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (**C.char)(h.Data)
	return
}

// unpackMemoryPCharString represents the data from Go string as *C.char and avoids copying.
func unpackMemoryPCharString(str string) (*C.char, *cgoAllocMap) {
	ptr0 := C.CString(str)
	mem0 := unsafe.Pointer(ptr0)
	allocs0 := new(cgoAllocMap)
	allocs0.Add(mem0)
	return ptr0, allocs0
}

type stringHeader struct {
	Data unsafe.Pointer
	Len  int
}

// newMultiTextRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func newMultiTextRef(ref unsafe.Pointer) *gMultiText {
	if ref == nil {
		return nil
	}
	obj := new(gMultiText)
	obj.refdf1ec495 = (*C.MultiText)(unsafe.Pointer(ref))
	return obj
}

// passRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *gMultiText) passRef() (*C.MultiText, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refdf1ec495 != nil {
		if x.allocsdf1ec495 != nil {
			return x.refdf1ec495, x.allocsdf1ec495.(*cgoAllocMap)
		} else {
			return x.refdf1ec495, nil
		}
	}
	memdf1ec495 := unsafe.Pointer(new(C.MultiText))
	refdf1ec495 := (*C.MultiText)(memdf1ec495)
	allocsdf1ec495 := new(cgoAllocMap)
	// allocsdf1ec495.Add(memdf1ec495)

	var ctext_allocs *cgoAllocMap
	refdf1ec495.text, ctext_allocs = unpackSString(x.gText)
	allocsdf1ec495.Borrow(ctext_allocs)
	x.gText = *new([]string)

	x.refdf1ec495 = refdf1ec495
	x.allocsdf1ec495 = allocsdf1ec495

	return refdf1ec495, allocsdf1ec495
}

// passValue does the same as passRef except that it will try to dereference the returned pointer.
func (x gMultiText) passValue() (C.MultiText, *cgoAllocMap) {
	if x.refdf1ec495 != nil {
		return *x.refdf1ec495, nil
	}
	ref, allocs := x.passRef()
	return *ref, allocs
}

// convert struct for mapping C struct unanimous.
func (x *gMultiText) convert() *MultiText {
	if x.refdf1ec495 != nil {
		return (*MultiText)(unsafe.Pointer(x.refdf1ec495))
	}
	x.passRef()
	return (*MultiText)(unsafe.Pointer(x.refdf1ec495))
}

// NewMultiText new Go object and Mapping to C object.
func NewMultiText(cText []string) MultiText {
	obj := *new(gMultiText)
	obj.gText = cText

	ret0, alloc0 := obj.passRef()

	if len(alloc0.m) > 0 {
		panic("Cgo memory alloced, please use func AllocMultiText.")
	}
	return *(*MultiText)(unsafe.Pointer(ret0))
}

// AllocMultiText new Go object and Mapping to C object.
func AllocMultiText(cText []string) (*MultiText, *cgoAllocMap) {
	obj := *new(gMultiText)
	obj.gText = cText

	ret0, alloc0 := obj.passRef()
	ret1 := (*MultiText)(unsafe.Pointer(ret0))
	return ret1, alloc0
}

// Index reads Go data structure out from plain C format.
func (x *MultiText) Index(index int32) *MultiText {
	ptr1 := (*MultiText)(unsafe.Pointer(uintptr(unsafe.Pointer(x)) + uintptr(index)*uintptr(sizeOfMultiTextValue)))
	return ptr1
}

// GC is register for garbage collection.
func (x *MultiText) GC(a *cgoAllocMap, args ...*cgoAllocMap) {
	for i := range args {
		a.Borrow(args[i])
	}
	if len(a.m) > 0 {
		for ptr := range a.m {
			fmt.Printf("INFO: MEMORY: [PTR %p] GC register\n", ptr)
		}
		runtime.SetFinalizer(x, func(*MultiText) {
			a.Free()
		})
	}
}

// Text returns a reference to C object within a struct

// safeString ensures that the string is NULL-terminated, a NULL-terminated copy is created otherwise.
func safeString(str string) string {
	if len(str) > 0 && str[len(str)-1] != '\x00' {
		str = str + "\x00"
	} else if len(str) == 0 {
		str = "\x00"
	}
	return str
}

// unpackPCharString represents the data from Go string as *C.char and avoids copying.
func unpackPCharString(str string) (*C.char, *cgoAllocMap) {
	str = safeString(str)
	h := (*stringHeader)(unsafe.Pointer(&str))
	return (*C.char)(h.Data), cgoAllocsUnknown
}

// packPCharString creates a Go string backed by *C.char and avoids copying.
func packPCharString(p *C.char) (raw string) {
	if p != nil && *p != 0 {
		h := (*stringHeader)(unsafe.Pointer(&raw))
		h.Data = unsafe.Pointer(p)
		for *p != 0 {
			p = (*C.char)(unsafe.Pointer(uintptr(unsafe.Pointer(p)) + 1)) // p++
		}
		h.Len = int(uintptr(unsafe.Pointer(p)) - uintptr(h.Data))
	}
	return
}

// RawString reperesents a string backed by data on the C side.
type RawString string

// Copy returns a Go-managed copy of raw string.
func (raw RawString) Copy() string {
	if len(raw) == 0 {
		return ""
	}
	h := (*stringHeader)(unsafe.Pointer(&raw))
	return C.GoStringN((*C.char)(h.Data), C.int(h.Len))
}
