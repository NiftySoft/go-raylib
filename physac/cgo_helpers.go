// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Sun, 30 Aug 2020 12:21:54 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package physac

/*
#include "../lib/raylib/src/physac.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("reference add into gc collector, gc collector count: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2 new Go object and Mapping to C object.
func NewVector2(gX float32, gY float32) Vector2 {
	obj := *new(Vector2)
	obj.gX = gX
	obj.gY = gY
	return obj
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.gX), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.gX = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.gY), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.gY = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Vector2) Index(index int32) *Vector2 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfVector2Value)))
	ret := NewVector2Ref(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Vector2) Convert() *vector2 {
	if x.ref29ca61a5 != nil {
		return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
	}
	x.PassRef()
	return (*vector2)(unsafe.Pointer(x.ref29ca61a5))
}

// allocMatrix2x2Memory allocates memory for type C.Matrix2x2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrix2x2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrix2x2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrix2x2Value = unsafe.Sizeof([1]C.Matrix2x2{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix2x2) ref() *C.Matrix2x2 {
	if x == nil {
		return nil
	}
	return x.refb92f06e6
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMatrix2x2(x *Matrix2x2) {
	if x != nil && x.allocsb92f06e6 != nil {
		x.allocsb92f06e6.(*cgoAllocMap).Free()
		x.refb92f06e6 = nil
		// fmt.Printf("Matrix2x2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsb92f06e6.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Matrix2x2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewMatrix2x2 new Go object and Mapping to C object.
func NewMatrix2x2(gM00 float32, gM01 float32, gM10 float32, gM11 float32) Matrix2x2 {
	obj := *new(Matrix2x2)
	obj.gM00 = gM00
	obj.gM01 = gM01
	obj.gM10 = gM10
	obj.gM11 = gM11
	return obj
}

// NewMatrix2x2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrix2x2Ref(ref unsafe.Pointer) *Matrix2x2 {
	if ref == nil {
		return nil
	}
	obj := new(Matrix2x2)
	obj.refb92f06e6 = (*C.Matrix2x2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix2x2) PassRef() (*C.Matrix2x2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb92f06e6 != nil {
		return x.refb92f06e6, nil
	}
	memb92f06e6 := unsafe.Pointer(new(C.Matrix2x2))
	refb92f06e6 := (*C.Matrix2x2)(memb92f06e6)
	allocsb92f06e6 := new(cgoAllocMap)
	// allocsb92f06e6.Add(memb92f06e6)

	var cm00_allocs *cgoAllocMap
	refb92f06e6.m00, cm00_allocs = (C.float)(x.gM00), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm00_allocs)
	x.gM00 = *new(float32)

	var cm01_allocs *cgoAllocMap
	refb92f06e6.m01, cm01_allocs = (C.float)(x.gM01), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm01_allocs)
	x.gM01 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refb92f06e6.m10, cm10_allocs = (C.float)(x.gM10), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm10_allocs)
	x.gM10 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refb92f06e6.m11, cm11_allocs = (C.float)(x.gM11), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm11_allocs)
	x.gM11 = *new(float32)

	x.refb92f06e6 = refb92f06e6
	x.allocsb92f06e6 = allocsb92f06e6
	defer func() {
		if len(x.allocsb92f06e6.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMatrix2x2)
		}
	}()
	return refb92f06e6, allocsb92f06e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix2x2) PassValue() (C.Matrix2x2, *cgoAllocMap) {
	if x.refb92f06e6 != nil {
		return *x.refb92f06e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *Matrix2x2) Index(index int32) *Matrix2x2 {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.Matrix2x2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfMatrix2x2Value)))
	ret := NewMatrix2x2Ref(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *Matrix2x2) Convert() *matrix2x2 {
	if x.refb92f06e6 != nil {
		return (*matrix2x2)(unsafe.Pointer(x.refb92f06e6))
	}
	x.PassRef()
	return (*matrix2x2)(unsafe.Pointer(x.refb92f06e6))
}

// allocPolygonDataMemory allocates memory for type C.PolygonData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPolygonDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPolygonDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPolygonDataValue = unsafe.Sizeof([1]C.PolygonData{})

// allocA24Vector2Memory allocates memory for type [24]C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA24Vector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA24Vector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA24Vector2Value = unsafe.Sizeof([1][24]C.Vector2{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA24Vector2 transforms a sliced Go data structure into plain C format.
func unpackA24Vector2(x [24]Vector2) (unpacked [24]C.Vector2, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[24]C.Vector2) {
		go allocs.Free()
	})

	mem0 := allocA24Vector2Memory(1)
	allocs.Add(mem0)
	v0 := (*[24]C.Vector2)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[24]C.Vector2)(mem0)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *PolygonData) ref() *C.PolygonData {
	if x == nil {
		return nil
	}
	return x.ref87a94eb7
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePolygonData(x *PolygonData) {
	if x != nil && x.allocs87a94eb7 != nil {
		x.allocs87a94eb7.(*cgoAllocMap).Free()
		x.ref87a94eb7 = nil
		// fmt.Printf("PolygonData memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs87a94eb7.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PolygonData memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewPolygonData new Go object and Mapping to C object.
func NewPolygonData(gVertexCount uint32, gPositions [24]Vector2, gNormals [24]Vector2) PolygonData {
	obj := *new(PolygonData)
	obj.gVertexCount = gVertexCount
	obj.gPositions = gPositions
	obj.gNormals = gNormals
	return obj
}

// NewPolygonDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPolygonDataRef(ref unsafe.Pointer) *PolygonData {
	if ref == nil {
		return nil
	}
	obj := new(PolygonData)
	obj.ref87a94eb7 = (*C.PolygonData)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PolygonData) PassRef() (*C.PolygonData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87a94eb7 != nil {
		return x.ref87a94eb7, nil
	}
	mem87a94eb7 := unsafe.Pointer(new(C.PolygonData))
	ref87a94eb7 := (*C.PolygonData)(mem87a94eb7)
	allocs87a94eb7 := new(cgoAllocMap)
	// allocs87a94eb7.Add(mem87a94eb7)

	var cvertexCount_allocs *cgoAllocMap
	ref87a94eb7.vertexCount, cvertexCount_allocs = (C.uint)(x.gVertexCount), cgoAllocsUnknown
	allocs87a94eb7.Borrow(cvertexCount_allocs)
	x.gVertexCount = *new(uint32)

	var cpositions_allocs *cgoAllocMap
	ref87a94eb7.positions, cpositions_allocs = unpackA24Vector2(x.gPositions)
	allocs87a94eb7.Borrow(cpositions_allocs)
	x.gPositions = *new([24]Vector2)

	var cnormals_allocs *cgoAllocMap
	ref87a94eb7.normals, cnormals_allocs = unpackA24Vector2(x.gNormals)
	allocs87a94eb7.Borrow(cnormals_allocs)
	x.gNormals = *new([24]Vector2)

	x.ref87a94eb7 = ref87a94eb7
	x.allocs87a94eb7 = allocs87a94eb7
	defer func() {
		if len(x.allocs87a94eb7.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePolygonData)
		}
	}()
	return ref87a94eb7, allocs87a94eb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PolygonData) PassValue() (C.PolygonData, *cgoAllocMap) {
	if x.ref87a94eb7 != nil {
		return *x.ref87a94eb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *PolygonData) Index(index int32) *PolygonData {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.PolygonData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPolygonDataValue)))
	ret := NewPolygonDataRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *PolygonData) Convert() *polygonData {
	if x.ref87a94eb7 != nil {
		return (*polygonData)(unsafe.Pointer(x.ref87a94eb7))
	}
	x.PassRef()
	return (*polygonData)(unsafe.Pointer(x.ref87a94eb7))
}

// GetPositions returns a reference to C object within a struct
func (s *PolygonData) GetPositions(positionsIndex int32) *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	// c struct pointer offset
	ptr0 := &s.ref().positions
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(positionsIndex)*uintptr(sizeOfVector2Value)))
	ret = NewVector2Ref(unsafe.Pointer(ptr1))

	return ret
}

// SetPositions update C object and binding struct
func (s *PolygonData) SetPositions(positionsIndex int32, vector2 Vector2) *PolygonData {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.Vector2
	if vector2.ref() == nil {
		__ret, _ = vector2.PassRef()
	} else {
		__ret = vector2.ref()
	}
	ptr0 := &s.ref().positions
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(positionsIndex)*uintptr(sizeOfVector2Value))

	*(*C.Vector2)(ptr) = *__ret
	return s
}

// GetNormals returns a reference to C object within a struct
func (s *PolygonData) GetNormals(normalsIndex int32) *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	// c struct pointer offset
	ptr0 := &s.ref().normals
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(normalsIndex)*uintptr(sizeOfVector2Value)))
	ret = NewVector2Ref(unsafe.Pointer(ptr1))

	return ret
}

// SetNormals update C object and binding struct
func (s *PolygonData) SetNormals(normalsIndex int32, vector2 Vector2) *PolygonData {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.Vector2
	if vector2.ref() == nil {
		__ret, _ = vector2.PassRef()
	} else {
		__ret = vector2.ref()
	}
	ptr0 := &s.ref().normals
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(normalsIndex)*uintptr(sizeOfVector2Value))

	*(*C.Vector2)(ptr) = *__ret
	return s
}

// allocPhysicsShapeMemory allocates memory for type C.PhysicsShape in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsShapeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsShapeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsShapeValue = unsafe.Sizeof([1]C.PhysicsShape{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocStruct_PhysicsBodyDataMemory allocates memory for type C.struct_PhysicsBodyData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_PhysicsBodyDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_PhysicsBodyDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_PhysicsBodyDataValue = unsafe.Sizeof([1]C.struct_PhysicsBodyData{})

// unpackSPhysicsBodyData transforms a sliced Go data structure into plain C format.
func unpackSPhysicsBodyData(x []PhysicsBodyData) (unpacked *C.struct_PhysicsBodyData, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_PhysicsBodyData) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_PhysicsBodyDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_PhysicsBodyData)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_PhysicsBodyData)(h.Data)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicsShape) ref() *C.PhysicsShape {
	if x == nil {
		return nil
	}
	return x.ref4c540f1a
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePhysicsShape(x *PhysicsShape) {
	if x != nil && x.allocs4c540f1a != nil {
		x.allocs4c540f1a.(*cgoAllocMap).Free()
		x.ref4c540f1a = nil
		// fmt.Printf("PhysicsShape memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs4c540f1a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PhysicsShape memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewPhysicsShape new Go object and Mapping to C object.
func NewPhysicsShape(gType PhysicsShapeType, gBody []PhysicsBodyData, gRadius float32, gTransform Matrix2x2, gVertexData PolygonData) PhysicsShape {
	obj := *new(PhysicsShape)
	obj.gType = gType
	obj.gBody = gBody
	obj.gRadius = gRadius
	obj.gTransform = gTransform
	obj.gVertexData = gVertexData
	return obj
}

// NewPhysicsShapeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicsShapeRef(ref unsafe.Pointer) *PhysicsShape {
	if ref == nil {
		return nil
	}
	obj := new(PhysicsShape)
	obj.ref4c540f1a = (*C.PhysicsShape)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicsShape) PassRef() (*C.PhysicsShape, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c540f1a != nil {
		return x.ref4c540f1a, nil
	}
	mem4c540f1a := unsafe.Pointer(new(C.PhysicsShape))
	ref4c540f1a := (*C.PhysicsShape)(mem4c540f1a)
	allocs4c540f1a := new(cgoAllocMap)
	// allocs4c540f1a.Add(mem4c540f1a)

	var c_type_allocs *cgoAllocMap
	ref4c540f1a._type, c_type_allocs = (C.PhysicsShapeType)(x.gType), cgoAllocsUnknown
	allocs4c540f1a.Borrow(c_type_allocs)
	x.gType = *new(PhysicsShapeType)

	var cbody_allocs *cgoAllocMap
	ref4c540f1a.body, cbody_allocs = unpackSPhysicsBodyData(x.gBody)
	allocs4c540f1a.Borrow(cbody_allocs)
	x.gBody = *new([]PhysicsBodyData)

	var cradius_allocs *cgoAllocMap
	ref4c540f1a.radius, cradius_allocs = (C.float)(x.gRadius), cgoAllocsUnknown
	allocs4c540f1a.Borrow(cradius_allocs)
	x.gRadius = *new(float32)

	var ctransform_allocs *cgoAllocMap
	ref4c540f1a.transform, ctransform_allocs = x.gTransform.PassValue()
	allocs4c540f1a.Borrow(ctransform_allocs)
	x.gTransform = *new(Matrix2x2)

	var cvertexData_allocs *cgoAllocMap
	ref4c540f1a.vertexData, cvertexData_allocs = x.gVertexData.PassValue()
	allocs4c540f1a.Borrow(cvertexData_allocs)
	x.gVertexData = *new(PolygonData)

	x.ref4c540f1a = ref4c540f1a
	x.allocs4c540f1a = allocs4c540f1a
	defer func() {
		if len(x.allocs4c540f1a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePhysicsShape)
		}
	}()
	return ref4c540f1a, allocs4c540f1a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicsShape) PassValue() (C.PhysicsShape, *cgoAllocMap) {
	if x.ref4c540f1a != nil {
		return *x.ref4c540f1a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *PhysicsShape) Index(index int32) *PhysicsShape {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.PhysicsShape)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPhysicsShapeValue)))
	ret := NewPhysicsShapeRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *PhysicsShape) Convert() *physicsShape {
	if x.ref4c540f1a != nil {
		return (*physicsShape)(unsafe.Pointer(x.ref4c540f1a))
	}
	x.PassRef()
	return (*physicsShape)(unsafe.Pointer(x.ref4c540f1a))
}

// GetType returns a reference to C object within a struct

// GetBody returns a reference to C object within a struct
func (s *PhysicsShape) GetBody(bodyIndex int32) *PhysicsBodyData {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *PhysicsBodyData
	// c struct pointer offset
	ptr0 := s.ref().body
	ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyIndex)*uintptr(sizeOfPhysicsBodyDataValue)))

	ret = NewPhysicsBodyDataRef(unsafe.Pointer(ptr1))
	return ret
}

// SetBody update C object and binding struct
func (s *PhysicsShape) SetBody(bodyIndex int32, physicsBodyData PhysicsBodyData) *PhysicsShape {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.struct_PhysicsBodyData
	if physicsBodyData.ref() == nil {
		__ret, _ = physicsBodyData.PassRef()
	} else {
		__ret = physicsBodyData.ref()
	}
	ptr0 := s.ref().body
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyIndex)*uintptr(sizeOfPhysicsBodyDataValue))

	*(*C.struct_PhysicsBodyData)(ptr) = *__ret
	return s
}

// GetTransform returns a reference to C object within a struct
func (s *PhysicsShape) GetTransform() *Matrix2x2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Matrix2x2
	ret = NewMatrix2x2Ref(unsafe.Pointer(&s.ref().transform))
	return ret
}

// GetVertexData returns a reference to C object within a struct
func (s *PhysicsShape) GetVertexData() *PolygonData {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *PolygonData
	ret = NewPolygonDataRef(unsafe.Pointer(&s.ref().vertexData))
	return ret
}

// allocPhysicsBodyDataMemory allocates memory for type C.PhysicsBodyData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsBodyDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsBodyDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsBodyDataValue = unsafe.Sizeof([1]C.PhysicsBodyData{})

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicsBodyData) ref() *C.PhysicsBodyData {
	if x == nil {
		return nil
	}
	return x.refd780e53
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePhysicsBodyData(x *PhysicsBodyData) {
	if x != nil && x.allocsd780e53 != nil {
		x.allocsd780e53.(*cgoAllocMap).Free()
		x.refd780e53 = nil
		// fmt.Printf("PhysicsBodyData memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsd780e53.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PhysicsBodyData memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewPhysicsBodyData new Go object and Mapping to C object.
func NewPhysicsBodyData(gId uint32, gEnabled bool, gPosition Vector2, gVelocity Vector2, gForce Vector2, gAngularVelocity float32, gTorque float32, gOrient float32, gInertia float32, gInverseInertia float32, gMass float32, gInverseMass float32, gStaticFriction float32, gDynamicFriction float32, gRestitution float32, gUseGravity bool, gIsGrounded bool, gFreezeOrient bool, gShape PhysicsShape) PhysicsBodyData {
	obj := *new(PhysicsBodyData)
	obj.gId = gId
	obj.gEnabled = gEnabled
	obj.gPosition = gPosition
	obj.gVelocity = gVelocity
	obj.gForce = gForce
	obj.gAngularVelocity = gAngularVelocity
	obj.gTorque = gTorque
	obj.gOrient = gOrient
	obj.gInertia = gInertia
	obj.gInverseInertia = gInverseInertia
	obj.gMass = gMass
	obj.gInverseMass = gInverseMass
	obj.gStaticFriction = gStaticFriction
	obj.gDynamicFriction = gDynamicFriction
	obj.gRestitution = gRestitution
	obj.gUseGravity = gUseGravity
	obj.gIsGrounded = gIsGrounded
	obj.gFreezeOrient = gFreezeOrient
	obj.gShape = gShape
	return obj
}

// NewPhysicsBodyDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicsBodyDataRef(ref unsafe.Pointer) *PhysicsBodyData {
	if ref == nil {
		return nil
	}
	obj := new(PhysicsBodyData)
	obj.refd780e53 = (*C.PhysicsBodyData)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicsBodyData) PassRef() (*C.PhysicsBodyData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd780e53 != nil {
		return x.refd780e53, nil
	}
	memd780e53 := unsafe.Pointer(new(C.PhysicsBodyData))
	refd780e53 := (*C.PhysicsBodyData)(memd780e53)
	allocsd780e53 := new(cgoAllocMap)
	// allocsd780e53.Add(memd780e53)

	var cid_allocs *cgoAllocMap
	refd780e53.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocsd780e53.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cenabled_allocs *cgoAllocMap
	refd780e53.enabled, cenabled_allocs = (C._Bool)(x.gEnabled), cgoAllocsUnknown
	allocsd780e53.Borrow(cenabled_allocs)
	x.gEnabled = *new(bool)

	var cposition_allocs *cgoAllocMap
	refd780e53.position, cposition_allocs = x.gPosition.PassValue()
	allocsd780e53.Borrow(cposition_allocs)
	x.gPosition = *new(Vector2)

	var cvelocity_allocs *cgoAllocMap
	refd780e53.velocity, cvelocity_allocs = x.gVelocity.PassValue()
	allocsd780e53.Borrow(cvelocity_allocs)
	x.gVelocity = *new(Vector2)

	var cforce_allocs *cgoAllocMap
	refd780e53.force, cforce_allocs = x.gForce.PassValue()
	allocsd780e53.Borrow(cforce_allocs)
	x.gForce = *new(Vector2)

	var cangularVelocity_allocs *cgoAllocMap
	refd780e53.angularVelocity, cangularVelocity_allocs = (C.float)(x.gAngularVelocity), cgoAllocsUnknown
	allocsd780e53.Borrow(cangularVelocity_allocs)
	x.gAngularVelocity = *new(float32)

	var ctorque_allocs *cgoAllocMap
	refd780e53.torque, ctorque_allocs = (C.float)(x.gTorque), cgoAllocsUnknown
	allocsd780e53.Borrow(ctorque_allocs)
	x.gTorque = *new(float32)

	var corient_allocs *cgoAllocMap
	refd780e53.orient, corient_allocs = (C.float)(x.gOrient), cgoAllocsUnknown
	allocsd780e53.Borrow(corient_allocs)
	x.gOrient = *new(float32)

	var cinertia_allocs *cgoAllocMap
	refd780e53.inertia, cinertia_allocs = (C.float)(x.gInertia), cgoAllocsUnknown
	allocsd780e53.Borrow(cinertia_allocs)
	x.gInertia = *new(float32)

	var cinverseInertia_allocs *cgoAllocMap
	refd780e53.inverseInertia, cinverseInertia_allocs = (C.float)(x.gInverseInertia), cgoAllocsUnknown
	allocsd780e53.Borrow(cinverseInertia_allocs)
	x.gInverseInertia = *new(float32)

	var cmass_allocs *cgoAllocMap
	refd780e53.mass, cmass_allocs = (C.float)(x.gMass), cgoAllocsUnknown
	allocsd780e53.Borrow(cmass_allocs)
	x.gMass = *new(float32)

	var cinverseMass_allocs *cgoAllocMap
	refd780e53.inverseMass, cinverseMass_allocs = (C.float)(x.gInverseMass), cgoAllocsUnknown
	allocsd780e53.Borrow(cinverseMass_allocs)
	x.gInverseMass = *new(float32)

	var cstaticFriction_allocs *cgoAllocMap
	refd780e53.staticFriction, cstaticFriction_allocs = (C.float)(x.gStaticFriction), cgoAllocsUnknown
	allocsd780e53.Borrow(cstaticFriction_allocs)
	x.gStaticFriction = *new(float32)

	var cdynamicFriction_allocs *cgoAllocMap
	refd780e53.dynamicFriction, cdynamicFriction_allocs = (C.float)(x.gDynamicFriction), cgoAllocsUnknown
	allocsd780e53.Borrow(cdynamicFriction_allocs)
	x.gDynamicFriction = *new(float32)

	var crestitution_allocs *cgoAllocMap
	refd780e53.restitution, crestitution_allocs = (C.float)(x.gRestitution), cgoAllocsUnknown
	allocsd780e53.Borrow(crestitution_allocs)
	x.gRestitution = *new(float32)

	var cuseGravity_allocs *cgoAllocMap
	refd780e53.useGravity, cuseGravity_allocs = (C._Bool)(x.gUseGravity), cgoAllocsUnknown
	allocsd780e53.Borrow(cuseGravity_allocs)
	x.gUseGravity = *new(bool)

	var cisGrounded_allocs *cgoAllocMap
	refd780e53.isGrounded, cisGrounded_allocs = (C._Bool)(x.gIsGrounded), cgoAllocsUnknown
	allocsd780e53.Borrow(cisGrounded_allocs)
	x.gIsGrounded = *new(bool)

	var cfreezeOrient_allocs *cgoAllocMap
	refd780e53.freezeOrient, cfreezeOrient_allocs = (C._Bool)(x.gFreezeOrient), cgoAllocsUnknown
	allocsd780e53.Borrow(cfreezeOrient_allocs)
	x.gFreezeOrient = *new(bool)

	var cshape_allocs *cgoAllocMap
	refd780e53.shape, cshape_allocs = x.gShape.PassValue()
	allocsd780e53.Borrow(cshape_allocs)
	x.gShape = *new(PhysicsShape)

	x.refd780e53 = refd780e53
	x.allocsd780e53 = allocsd780e53
	defer func() {
		if len(x.allocsd780e53.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePhysicsBodyData)
		}
	}()
	return refd780e53, allocsd780e53

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicsBodyData) PassValue() (C.PhysicsBodyData, *cgoAllocMap) {
	if x.refd780e53 != nil {
		return *x.refd780e53, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *PhysicsBodyData) Index(index int32) *PhysicsBodyData {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPhysicsBodyDataValue)))
	ret := NewPhysicsBodyDataRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *PhysicsBodyData) Convert() *physicsBodyData {
	if x.refd780e53 != nil {
		return (*physicsBodyData)(unsafe.Pointer(x.refd780e53))
	}
	x.PassRef()
	return (*physicsBodyData)(unsafe.Pointer(x.refd780e53))
}

// GetPosition returns a reference to C object within a struct
func (s *PhysicsBodyData) GetPosition() *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.ref().position))
	return ret
}

// GetVelocity returns a reference to C object within a struct
func (s *PhysicsBodyData) GetVelocity() *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.ref().velocity))
	return ret
}

// GetForce returns a reference to C object within a struct
func (s *PhysicsBodyData) GetForce() *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.ref().force))
	return ret
}

// GetShape returns a reference to C object within a struct
func (s *PhysicsBodyData) GetShape() *PhysicsShape {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *PhysicsShape
	ret = NewPhysicsShapeRef(unsafe.Pointer(&s.ref().shape))
	return ret
}

// allocPhysicsManifoldDataMemory allocates memory for type C.PhysicsManifoldData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsManifoldDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsManifoldDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsManifoldDataValue = unsafe.Sizeof([1]C.PhysicsManifoldData{})

// allocA2Vector2Memory allocates memory for type [2]C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Vector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Vector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Vector2Value = unsafe.Sizeof([1][2]C.Vector2{})

// unpackA2Vector2 transforms a sliced Go data structure into plain C format.
func unpackA2Vector2(x [2]Vector2) (unpacked [2]C.Vector2, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.Vector2) {
		go allocs.Free()
	})

	mem0 := allocA2Vector2Memory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.Vector2)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[2]C.Vector2)(mem0)
	return
}

// ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicsManifoldData) ref() *C.PhysicsManifoldData {
	if x == nil {
		return nil
	}
	return x.ref10b92967
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePhysicsManifoldData(x *PhysicsManifoldData) {
	if x != nil && x.allocs10b92967 != nil {
		x.allocs10b92967.(*cgoAllocMap).Free()
		x.ref10b92967 = nil
		// fmt.Printf("PhysicsManifoldData memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs10b92967.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PhysicsManifoldData memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("reference delete from gc collector, gc collector count: %d\n", len(gc.references))
			}
		}
	}
}

// NewPhysicsManifoldData new Go object and Mapping to C object.
func NewPhysicsManifoldData(gId uint32, gBodyA []PhysicsBodyData, gBodyB []PhysicsBodyData, gPenetration float32, gNormal Vector2, gContacts [2]Vector2, gContactsCount uint32, gRestitution float32, gDynamicFriction float32, gStaticFriction float32) PhysicsManifoldData {
	obj := *new(PhysicsManifoldData)
	obj.gId = gId
	obj.gBodyA = gBodyA
	obj.gBodyB = gBodyB
	obj.gPenetration = gPenetration
	obj.gNormal = gNormal
	obj.gContacts = gContacts
	obj.gContactsCount = gContactsCount
	obj.gRestitution = gRestitution
	obj.gDynamicFriction = gDynamicFriction
	obj.gStaticFriction = gStaticFriction
	return obj
}

// NewPhysicsManifoldDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicsManifoldDataRef(ref unsafe.Pointer) *PhysicsManifoldData {
	if ref == nil {
		return nil
	}
	obj := new(PhysicsManifoldData)
	obj.ref10b92967 = (*C.PhysicsManifoldData)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicsManifoldData) PassRef() (*C.PhysicsManifoldData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref10b92967 != nil {
		return x.ref10b92967, nil
	}
	mem10b92967 := unsafe.Pointer(new(C.PhysicsManifoldData))
	ref10b92967 := (*C.PhysicsManifoldData)(mem10b92967)
	allocs10b92967 := new(cgoAllocMap)
	// allocs10b92967.Add(mem10b92967)

	var cid_allocs *cgoAllocMap
	ref10b92967.id, cid_allocs = (C.uint)(x.gId), cgoAllocsUnknown
	allocs10b92967.Borrow(cid_allocs)
	x.gId = *new(uint32)

	var cbodyA_allocs *cgoAllocMap
	ref10b92967.bodyA, cbodyA_allocs = unpackSPhysicsBodyData(x.gBodyA)
	allocs10b92967.Borrow(cbodyA_allocs)
	x.gBodyA = *new([]PhysicsBodyData)

	var cbodyB_allocs *cgoAllocMap
	ref10b92967.bodyB, cbodyB_allocs = unpackSPhysicsBodyData(x.gBodyB)
	allocs10b92967.Borrow(cbodyB_allocs)
	x.gBodyB = *new([]PhysicsBodyData)

	var cpenetration_allocs *cgoAllocMap
	ref10b92967.penetration, cpenetration_allocs = (C.float)(x.gPenetration), cgoAllocsUnknown
	allocs10b92967.Borrow(cpenetration_allocs)
	x.gPenetration = *new(float32)

	var cnormal_allocs *cgoAllocMap
	ref10b92967.normal, cnormal_allocs = x.gNormal.PassValue()
	allocs10b92967.Borrow(cnormal_allocs)
	x.gNormal = *new(Vector2)

	var ccontacts_allocs *cgoAllocMap
	ref10b92967.contacts, ccontacts_allocs = unpackA2Vector2(x.gContacts)
	allocs10b92967.Borrow(ccontacts_allocs)
	x.gContacts = *new([2]Vector2)

	var ccontactsCount_allocs *cgoAllocMap
	ref10b92967.contactsCount, ccontactsCount_allocs = (C.uint)(x.gContactsCount), cgoAllocsUnknown
	allocs10b92967.Borrow(ccontactsCount_allocs)
	x.gContactsCount = *new(uint32)

	var crestitution_allocs *cgoAllocMap
	ref10b92967.restitution, crestitution_allocs = (C.float)(x.gRestitution), cgoAllocsUnknown
	allocs10b92967.Borrow(crestitution_allocs)
	x.gRestitution = *new(float32)

	var cdynamicFriction_allocs *cgoAllocMap
	ref10b92967.dynamicFriction, cdynamicFriction_allocs = (C.float)(x.gDynamicFriction), cgoAllocsUnknown
	allocs10b92967.Borrow(cdynamicFriction_allocs)
	x.gDynamicFriction = *new(float32)

	var cstaticFriction_allocs *cgoAllocMap
	ref10b92967.staticFriction, cstaticFriction_allocs = (C.float)(x.gStaticFriction), cgoAllocsUnknown
	allocs10b92967.Borrow(cstaticFriction_allocs)
	x.gStaticFriction = *new(float32)

	x.ref10b92967 = ref10b92967
	x.allocs10b92967 = allocs10b92967
	defer func() {
		if len(x.allocs10b92967.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePhysicsManifoldData)
		}
	}()
	return ref10b92967, allocs10b92967

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicsManifoldData) PassValue() (C.PhysicsManifoldData, *cgoAllocMap) {
	if x.ref10b92967 != nil {
		return *x.ref10b92967, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// Index reads Go data structure out from plain C format.
func (x *PhysicsManifoldData) Index(index int32) *PhysicsManifoldData {
	ptr0, _ := x.PassRef()
	ptr1 := (*C.PhysicsManifoldData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(index)*uintptr(sizeOfPhysicsManifoldDataValue)))
	ret := NewPhysicsManifoldDataRef(unsafe.Pointer(ptr1))
	return ret
}

// Convert struct for mapping C struct unanimous.
func (x *PhysicsManifoldData) Convert() *physicsManifoldData {
	if x.ref10b92967 != nil {
		return (*physicsManifoldData)(unsafe.Pointer(x.ref10b92967))
	}
	x.PassRef()
	return (*physicsManifoldData)(unsafe.Pointer(x.ref10b92967))
}

// GetBodyA returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetBodyA(bodyAIndex int32) *PhysicsBodyData {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *PhysicsBodyData
	// c struct pointer offset
	ptr0 := s.ref().bodyA
	ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyAIndex)*uintptr(sizeOfPhysicsBodyDataValue)))

	ret = NewPhysicsBodyDataRef(unsafe.Pointer(ptr1))
	return ret
}

// SetBodyA update C object and binding struct
func (s *PhysicsManifoldData) SetBodyA(bodyAIndex int32, physicsBodyData PhysicsBodyData) *PhysicsManifoldData {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.struct_PhysicsBodyData
	if physicsBodyData.ref() == nil {
		__ret, _ = physicsBodyData.PassRef()
	} else {
		__ret = physicsBodyData.ref()
	}
	ptr0 := s.ref().bodyA
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyAIndex)*uintptr(sizeOfPhysicsBodyDataValue))

	*(*C.struct_PhysicsBodyData)(ptr) = *__ret
	return s
}

// GetBodyB returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetBodyB(bodyBIndex int32) *PhysicsBodyData {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *PhysicsBodyData
	// c struct pointer offset
	ptr0 := s.ref().bodyB
	ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyBIndex)*uintptr(sizeOfPhysicsBodyDataValue)))

	ret = NewPhysicsBodyDataRef(unsafe.Pointer(ptr1))
	return ret
}

// SetBodyB update C object and binding struct
func (s *PhysicsManifoldData) SetBodyB(bodyBIndex int32, physicsBodyData PhysicsBodyData) *PhysicsManifoldData {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.struct_PhysicsBodyData
	if physicsBodyData.ref() == nil {
		__ret, _ = physicsBodyData.PassRef()
	} else {
		__ret = physicsBodyData.ref()
	}
	ptr0 := s.ref().bodyB
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyBIndex)*uintptr(sizeOfPhysicsBodyDataValue))

	*(*C.struct_PhysicsBodyData)(ptr) = *__ret
	return s
}

// GetNormal returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetNormal() *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.ref().normal))
	return ret
}

// GetContacts returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetContacts(contactsIndex int32) *Vector2 {
	if s.ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	// c struct pointer offset
	ptr0 := &s.ref().contacts
	ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(contactsIndex)*uintptr(sizeOfVector2Value)))
	ret = NewVector2Ref(unsafe.Pointer(ptr1))

	return ret
}

// SetContacts update C object and binding struct
func (s *PhysicsManifoldData) SetContacts(contactsIndex int32, vector2 Vector2) *PhysicsManifoldData {

	if s.ref() == nil {
		s.PassRef()
	}

	var __ret *C.Vector2
	if vector2.ref() == nil {
		__ret, _ = vector2.PassRef()
	} else {
		__ret = vector2.ref()
	}
	ptr0 := &s.ref().contacts
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(contactsIndex)*uintptr(sizeOfVector2Value))

	*(*C.Vector2)(ptr) = *__ret
	return s
}
