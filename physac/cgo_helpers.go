// THE AUTOGENERATED LICENSE. ALL THE RIGHTS ARE RESERVED BY ROBOTS.

// WARNING: This file has automatically been generated on Fri, 31 Jul 2020 15:51:23 CST.
// Code generated by https://git.io/c-for-go. DO NOT EDIT.

package physac

/*
#include "../lib/raylib/src/physac.h"
#include <stdlib.h>
#include "cgo_helpers.h"
*/
import "C"
import (
	"fmt"
	"runtime"
	"sync"
	"unsafe"
)

// cgoAllocMap stores pointers to C allocated memory for future reference.
type reference struct {
	count int
}

type collector struct {
	mux        sync.RWMutex
	references map[unsafe.Pointer]*reference
}

var gc = new(collector)

type cgoAllocMap struct {
	mux sync.RWMutex
	m   map[unsafe.Pointer]struct{}
}

var cgoAllocsUnknown = new(cgoAllocMap)

func init() {
	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
}

func (a *cgoAllocMap) Add(ptr unsafe.Pointer) {
	a.mux.Lock()
	gc.mux.Lock() // gc lock
	if a.m == nil {
		a.m = make(map[unsafe.Pointer]struct{})
	}
	a.m[ptr] = struct{}{}

	if gc.references == nil {
		gc.references = make(map[unsafe.Pointer]*reference)
	}
	if _, ok := gc.references[ptr]; ok {
		panic("The memory address already exists.")
	}
	gc.references[ptr] = &reference{}
	gc.references[ptr].count += 1
	fmt.Printf("add reference, still exist: %d\n", len(gc.references))

	a.mux.Unlock()
	gc.mux.Unlock() // gc unlock
}

func (a *cgoAllocMap) IsEmpty() bool {
	a.mux.RLock()
	isEmpty := len(a.m) == 0
	a.mux.RUnlock()
	return isEmpty
}

func (a *cgoAllocMap) Borrow(b *cgoAllocMap) {
	if b == nil || b.IsEmpty() {
		return
	}
	b.mux.Lock()
	a.mux.Lock()
	for ptr := range b.m {
		if a.m == nil {
			a.m = make(map[unsafe.Pointer]struct{})
		}
		a.m[ptr] = struct{}{}
		delete(b.m, ptr)
	}
	a.mux.Unlock()
	b.mux.Unlock()
}

func (a *cgoAllocMap) Free() {
	// a.mux.Lock()
	// for ptr := range a.m {
	// 	C.free(ptr)
	// 	delete(a.m, ptr)
	// }
	// a.mux.Unlock()
}

// allocVector2Memory allocates memory for type C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocVector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfVector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfVector2Value = unsafe.Sizeof([1]C.Vector2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Vector2) Ref() *C.Vector2 {
	if x == nil {
		return nil
	}
	return x.ref29ca61a5
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Vector2) ResetRef() {
	if x == nil {
		return
	}
	x.ref29ca61a5 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Vector2) FreeRef() {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		return
	}
	if x != nil && x.ref29ca61a5 != nil && x.allocs29ca61a5 == nil {
		C.free(unsafe.Pointer(x.ref29ca61a5))
		x.ref29ca61a5 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeVector2(x *Vector2) {
	if x != nil && x.allocs29ca61a5 != nil {
		x.allocs29ca61a5.(*cgoAllocMap).Free()
		x.ref29ca61a5 = nil
		// fmt.Printf("Vector2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs29ca61a5.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Vector2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewVector2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewVector2Ref(ref unsafe.Pointer) *Vector2 {
	if ref == nil {
		return nil
	}
	obj := new(Vector2)
	obj.ref29ca61a5 = (*C.Vector2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Vector2) PassRef() (*C.Vector2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref29ca61a5 != nil {
		return x.ref29ca61a5, nil
	}
	mem29ca61a5 := unsafe.Pointer(new(C.Vector2))
	ref29ca61a5 := (*C.Vector2)(mem29ca61a5)
	allocs29ca61a5 := new(cgoAllocMap)
	// allocs29ca61a5.Add(mem29ca61a5)

	var cx_allocs *cgoAllocMap
	ref29ca61a5.x, cx_allocs = (C.float)(x.X), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cx_allocs)
	x.X = *new(float32)

	var cy_allocs *cgoAllocMap
	ref29ca61a5.y, cy_allocs = (C.float)(x.Y), cgoAllocsUnknown
	allocs29ca61a5.Borrow(cy_allocs)
	x.Y = *new(float32)

	x.ref29ca61a5 = ref29ca61a5
	x.allocs29ca61a5 = allocs29ca61a5
	defer func() {
		if len(x.allocs29ca61a5.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeVector2)
		}
	}()
	return ref29ca61a5, allocs29ca61a5

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Vector2) PassValue() (C.Vector2, *cgoAllocMap) {
	if x.ref29ca61a5 != nil {
		return *x.ref29ca61a5, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// GetX returns a reference to C object within a struct
func (s *Vector2) GetX() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().x))
	return ret
}

// SetX update C object and binding struct
func (s *Vector2) SetX(x float32) *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().x = (C.float)(x)
	return s
}

// GetY returns a reference to C object within a struct
func (s *Vector2) GetY() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().y))
	return ret
}

// SetY update C object and binding struct
func (s *Vector2) SetY(y float32) *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().y = (C.float)(y)
	return s
}

// allocMatrix2x2Memory allocates memory for type C.Matrix2x2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocMatrix2x2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfMatrix2x2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfMatrix2x2Value = unsafe.Sizeof([1]C.Matrix2x2{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *Matrix2x2) Ref() *C.Matrix2x2 {
	if x == nil {
		return nil
	}
	return x.refb92f06e6
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *Matrix2x2) ResetRef() {
	if x == nil {
		return
	}
	x.refb92f06e6 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *Matrix2x2) FreeRef() {
	if x != nil && x.allocsb92f06e6 != nil {
		x.allocsb92f06e6.(*cgoAllocMap).Free()
		x.refb92f06e6 = nil
		return
	}
	if x != nil && x.refb92f06e6 != nil && x.allocsb92f06e6 == nil {
		C.free(unsafe.Pointer(x.refb92f06e6))
		x.refb92f06e6 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freeMatrix2x2(x *Matrix2x2) {
	if x != nil && x.allocsb92f06e6 != nil {
		x.allocsb92f06e6.(*cgoAllocMap).Free()
		x.refb92f06e6 = nil
		// fmt.Printf("Matrix2x2 memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsb92f06e6.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.Matrix2x2 memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewMatrix2x2Ref creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewMatrix2x2Ref(ref unsafe.Pointer) *Matrix2x2 {
	if ref == nil {
		return nil
	}
	obj := new(Matrix2x2)
	obj.refb92f06e6 = (*C.Matrix2x2)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *Matrix2x2) PassRef() (*C.Matrix2x2, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refb92f06e6 != nil {
		return x.refb92f06e6, nil
	}
	memb92f06e6 := unsafe.Pointer(new(C.Matrix2x2))
	refb92f06e6 := (*C.Matrix2x2)(memb92f06e6)
	allocsb92f06e6 := new(cgoAllocMap)
	// allocsb92f06e6.Add(memb92f06e6)

	var cm00_allocs *cgoAllocMap
	refb92f06e6.m00, cm00_allocs = (C.float)(x.M00), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm00_allocs)
	x.M00 = *new(float32)

	var cm01_allocs *cgoAllocMap
	refb92f06e6.m01, cm01_allocs = (C.float)(x.M01), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm01_allocs)
	x.M01 = *new(float32)

	var cm10_allocs *cgoAllocMap
	refb92f06e6.m10, cm10_allocs = (C.float)(x.M10), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm10_allocs)
	x.M10 = *new(float32)

	var cm11_allocs *cgoAllocMap
	refb92f06e6.m11, cm11_allocs = (C.float)(x.M11), cgoAllocsUnknown
	allocsb92f06e6.Borrow(cm11_allocs)
	x.M11 = *new(float32)

	x.refb92f06e6 = refb92f06e6
	x.allocsb92f06e6 = allocsb92f06e6
	defer func() {
		if len(x.allocsb92f06e6.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freeMatrix2x2)
		}
	}()
	return refb92f06e6, allocsb92f06e6

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x Matrix2x2) PassValue() (C.Matrix2x2, *cgoAllocMap) {
	if x.refb92f06e6 != nil {
		return *x.refb92f06e6, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// GetM00 returns a reference to C object within a struct
func (s *Matrix2x2) GetM00() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().m00))
	return ret
}

// SetM00 update C object and binding struct
func (s *Matrix2x2) SetM00(m00 float32) *Matrix2x2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().m00 = (C.float)(m00)
	return s
}

// GetM01 returns a reference to C object within a struct
func (s *Matrix2x2) GetM01() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().m01))
	return ret
}

// SetM01 update C object and binding struct
func (s *Matrix2x2) SetM01(m01 float32) *Matrix2x2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().m01 = (C.float)(m01)
	return s
}

// GetM10 returns a reference to C object within a struct
func (s *Matrix2x2) GetM10() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().m10))
	return ret
}

// SetM10 update C object and binding struct
func (s *Matrix2x2) SetM10(m10 float32) *Matrix2x2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().m10 = (C.float)(m10)
	return s
}

// GetM11 returns a reference to C object within a struct
func (s *Matrix2x2) GetM11() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().m11))
	return ret
}

// SetM11 update C object and binding struct
func (s *Matrix2x2) SetM11(m11 float32) *Matrix2x2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().m11 = (C.float)(m11)
	return s
}

// allocPolygonDataMemory allocates memory for type C.PolygonData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPolygonDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPolygonDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPolygonDataValue = unsafe.Sizeof([1]C.PolygonData{})

// allocA24Vector2Memory allocates memory for type [24]C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA24Vector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA24Vector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA24Vector2Value = unsafe.Sizeof([1][24]C.Vector2{})

const sizeOfPtr = unsafe.Sizeof(&struct{}{})

// unpackA24Vector2 transforms a sliced Go data structure into plain C format.
func unpackA24Vector2(x [24]Vector2) (unpacked [24]C.Vector2, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[24]C.Vector2) {
		go allocs.Free()
	})

	mem0 := allocA24Vector2Memory(1)
	allocs.Add(mem0)
	v0 := (*[24]C.Vector2)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[24]C.Vector2)(mem0)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PolygonData) Ref() *C.PolygonData {
	if x == nil {
		return nil
	}
	return x.ref87a94eb7
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *PolygonData) ResetRef() {
	if x == nil {
		return
	}
	x.ref87a94eb7 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PolygonData) FreeRef() {
	if x != nil && x.allocs87a94eb7 != nil {
		x.allocs87a94eb7.(*cgoAllocMap).Free()
		x.ref87a94eb7 = nil
		return
	}
	if x != nil && x.ref87a94eb7 != nil && x.allocs87a94eb7 == nil {
		C.free(unsafe.Pointer(x.ref87a94eb7))
		x.ref87a94eb7 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePolygonData(x *PolygonData) {
	if x != nil && x.allocs87a94eb7 != nil {
		x.allocs87a94eb7.(*cgoAllocMap).Free()
		x.ref87a94eb7 = nil
		// fmt.Printf("PolygonData memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs87a94eb7.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PolygonData memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewPolygonDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPolygonDataRef(ref unsafe.Pointer) *PolygonData {
	if ref == nil {
		return nil
	}
	obj := new(PolygonData)
	obj.ref87a94eb7 = (*C.PolygonData)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PolygonData) PassRef() (*C.PolygonData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref87a94eb7 != nil {
		return x.ref87a94eb7, nil
	}
	mem87a94eb7 := unsafe.Pointer(new(C.PolygonData))
	ref87a94eb7 := (*C.PolygonData)(mem87a94eb7)
	allocs87a94eb7 := new(cgoAllocMap)
	// allocs87a94eb7.Add(mem87a94eb7)

	var cvertexCount_allocs *cgoAllocMap
	ref87a94eb7.vertexCount, cvertexCount_allocs = (C.uint)(x.VertexCount), cgoAllocsUnknown
	allocs87a94eb7.Borrow(cvertexCount_allocs)
	x.VertexCount = *new(uint32)

	var cpositions_allocs *cgoAllocMap
	ref87a94eb7.positions, cpositions_allocs = unpackA24Vector2(x.Positions)
	allocs87a94eb7.Borrow(cpositions_allocs)
	x.Positions = *new([24]Vector2)

	var cnormals_allocs *cgoAllocMap
	ref87a94eb7.normals, cnormals_allocs = unpackA24Vector2(x.Normals)
	allocs87a94eb7.Borrow(cnormals_allocs)
	x.Normals = *new([24]Vector2)

	x.ref87a94eb7 = ref87a94eb7
	x.allocs87a94eb7 = allocs87a94eb7
	defer func() {
		if len(x.allocs87a94eb7.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePolygonData)
		}
	}()
	return ref87a94eb7, allocs87a94eb7

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PolygonData) PassValue() (C.PolygonData, *cgoAllocMap) {
	if x.ref87a94eb7 != nil {
		return *x.ref87a94eb7, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// GetVertexCount returns a reference to C object within a struct
func (s *PolygonData) GetVertexCount() *uint32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *uint32
	ret = (*uint32)(unsafe.Pointer(&s.Ref().vertexCount))
	return ret
}

// SetVertexCount update C object and binding struct
func (s *PolygonData) SetVertexCount(vertexCount uint32) *PolygonData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().vertexCount = (C.uint)(vertexCount)
	return s
}

// GetPositions returns a reference to C object within a struct
func (s *PolygonData) GetPositions() [24]Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret [24]Vector2
	// c struct pointer offset
	ptr0 := &s.Ref().positions
	for i0 := range ret {
		ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfVector2Value)))
		ret[i0] = *NewVector2Ref(unsafe.Pointer(ptr1))
	}
	return ret
}

// SetPositions update C object and binding struct
func (s *PolygonData) SetPositions(positionsIndex int32, vector2 Vector2) *PolygonData {

	if s.Ref() == nil {
		s.PassRef()
	}

	var __ret *C.Vector2
	if vector2.Ref() == nil {
		__ret, _ = vector2.PassRef()
	} else {
		__ret = vector2.Ref()
	}
	ptr0 := &s.Ref().positions
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(positionsIndex)*uintptr(sizeOfVector2Value))

	*(*C.Vector2)(ptr) = *__ret
	return s
}

// GetNormals returns a reference to C object within a struct
func (s *PolygonData) GetNormals() [24]Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret [24]Vector2
	// c struct pointer offset
	ptr0 := &s.Ref().normals
	for i0 := range ret {
		ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfVector2Value)))
		ret[i0] = *NewVector2Ref(unsafe.Pointer(ptr1))
	}
	return ret
}

// SetNormals update C object and binding struct
func (s *PolygonData) SetNormals(normalsIndex int32, vector2 Vector2) *PolygonData {

	if s.Ref() == nil {
		s.PassRef()
	}

	var __ret *C.Vector2
	if vector2.Ref() == nil {
		__ret, _ = vector2.PassRef()
	} else {
		__ret = vector2.Ref()
	}
	ptr0 := &s.Ref().normals
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(normalsIndex)*uintptr(sizeOfVector2Value))

	*(*C.Vector2)(ptr) = *__ret
	return s
}

// allocPhysicsShapeMemory allocates memory for type C.PhysicsShape in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsShapeMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsShapeValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsShapeValue = unsafe.Sizeof([1]C.PhysicsShape{})

type sliceHeader struct {
	Data unsafe.Pointer
	Len  int
	Cap  int
}

// allocStruct_PhysicsBodyDataMemory allocates memory for type C.struct_PhysicsBodyData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocStruct_PhysicsBodyDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfStruct_PhysicsBodyDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfStruct_PhysicsBodyDataValue = unsafe.Sizeof([1]C.struct_PhysicsBodyData{})

// unpackSPhysicsBodyData transforms a sliced Go data structure into plain C format.
func unpackSPhysicsBodyData(x []PhysicsBodyData) (unpacked *C.struct_PhysicsBodyData, allocs *cgoAllocMap) {
	if x == nil {
		return nil, nil
	}
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(**C.struct_PhysicsBodyData) {
		go allocs.Free()
	})

	len0 := len(x)
	mem0 := allocStruct_PhysicsBodyDataMemory(len0)
	allocs.Add(mem0)
	h0 := &sliceHeader{
		Data: mem0,
		Cap:  len0,
		Len:  len0,
	}
	v0 := *(*[]C.struct_PhysicsBodyData)(unsafe.Pointer(h0))
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	h := (*sliceHeader)(unsafe.Pointer(&v0))
	unpacked = (*C.struct_PhysicsBodyData)(h.Data)
	return
}

// packSPhysicsBodyData reads sliced Go data structure out from plain C format.
func packSPhysicsBodyData(v []PhysicsBodyData, ptr0 *C.struct_PhysicsBodyData) {
	// c struct pointer offset
	for i0 := range v {
		ptr1 := (*C.struct_PhysicsBodyData)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfStruct_PhysicsBodyDataValue)))
		v[i0] = *NewPhysicsBodyDataRef(unsafe.Pointer(ptr1))
	}
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicsShape) Ref() *C.PhysicsShape {
	if x == nil {
		return nil
	}
	return x.ref4c540f1a
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *PhysicsShape) ResetRef() {
	if x == nil {
		return
	}
	x.ref4c540f1a = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicsShape) FreeRef() {
	if x != nil && x.allocs4c540f1a != nil {
		x.allocs4c540f1a.(*cgoAllocMap).Free()
		x.ref4c540f1a = nil
		return
	}
	if x != nil && x.ref4c540f1a != nil && x.allocs4c540f1a == nil {
		C.free(unsafe.Pointer(x.ref4c540f1a))
		x.ref4c540f1a = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePhysicsShape(x *PhysicsShape) {
	if x != nil && x.allocs4c540f1a != nil {
		x.allocs4c540f1a.(*cgoAllocMap).Free()
		x.ref4c540f1a = nil
		// fmt.Printf("PhysicsShape memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs4c540f1a.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PhysicsShape memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewPhysicsShapeRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicsShapeRef(ref unsafe.Pointer) *PhysicsShape {
	if ref == nil {
		return nil
	}
	obj := new(PhysicsShape)
	obj.ref4c540f1a = (*C.PhysicsShape)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicsShape) PassRef() (*C.PhysicsShape, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref4c540f1a != nil {
		return x.ref4c540f1a, nil
	}
	mem4c540f1a := unsafe.Pointer(new(C.PhysicsShape))
	ref4c540f1a := (*C.PhysicsShape)(mem4c540f1a)
	allocs4c540f1a := new(cgoAllocMap)
	// allocs4c540f1a.Add(mem4c540f1a)

	var c_type_allocs *cgoAllocMap
	ref4c540f1a._type, c_type_allocs = (C.PhysicsShapeType)(x.Type), cgoAllocsUnknown
	allocs4c540f1a.Borrow(c_type_allocs)
	x.Type = *new(PhysicsShapeType)

	var cbody_allocs *cgoAllocMap
	ref4c540f1a.body, cbody_allocs = unpackSPhysicsBodyData(x.Body)
	allocs4c540f1a.Borrow(cbody_allocs)
	x.Body = *new([]PhysicsBodyData)

	var cradius_allocs *cgoAllocMap
	ref4c540f1a.radius, cradius_allocs = (C.float)(x.Radius), cgoAllocsUnknown
	allocs4c540f1a.Borrow(cradius_allocs)
	x.Radius = *new(float32)

	var ctransform_allocs *cgoAllocMap
	ref4c540f1a.transform, ctransform_allocs = x.Transform.PassValue()
	allocs4c540f1a.Borrow(ctransform_allocs)
	x.Transform = *new(Matrix2x2)

	var cvertexData_allocs *cgoAllocMap
	ref4c540f1a.vertexData, cvertexData_allocs = x.VertexData.PassValue()
	allocs4c540f1a.Borrow(cvertexData_allocs)
	x.VertexData = *new(PolygonData)

	x.ref4c540f1a = ref4c540f1a
	x.allocs4c540f1a = allocs4c540f1a
	defer func() {
		if len(x.allocs4c540f1a.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePhysicsShape)
		}
	}()
	return ref4c540f1a, allocs4c540f1a

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicsShape) PassValue() (C.PhysicsShape, *cgoAllocMap) {
	if x.ref4c540f1a != nil {
		return *x.ref4c540f1a, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// GetType returns a reference to C object within a struct

// SetType update C object and binding struct

// GetBody returns a reference to C object within a struct
func (s *PhysicsShape) GetBody(bodyCount int32) []PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []PhysicsBodyData
	ret = make([]PhysicsBodyData, bodyCount)
	packSPhysicsBodyData(ret, s.Ref().body)
	return ret
}

// SetBody update C object and binding struct
func (s *PhysicsShape) SetBody(bodyIndex int32, physicsBodyData PhysicsBodyData) *PhysicsShape {

	if s.Ref() == nil {
		s.PassRef()
	}

	var __ret *C.struct_PhysicsBodyData
	if physicsBodyData.Ref() == nil {
		__ret, _ = physicsBodyData.PassRef()
	} else {
		__ret = physicsBodyData.Ref()
	}
	ptr0 := s.Ref().body
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyIndex)*uintptr(sizeOfPhysicsBodyDataValue))

	*(*C.struct_PhysicsBodyData)(ptr) = *__ret
	return s
}

// GetRadius returns a reference to C object within a struct
func (s *PhysicsShape) GetRadius() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().radius))
	return ret
}

// SetRadius update C object and binding struct
func (s *PhysicsShape) SetRadius(radius float32) *PhysicsShape {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().radius = (C.float)(radius)
	return s
}

// GetTransform returns a reference to C object within a struct
func (s *PhysicsShape) GetTransform() *Matrix2x2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Matrix2x2
	ret = NewMatrix2x2Ref(unsafe.Pointer(&s.Ref().transform))
	return ret
}

// SetTransform update C object and binding struct
func (s *PhysicsShape) SetTransform(transform *Matrix2x2) *PhysicsShape {
	if s.Ref() == nil {
		s.PassRef()
	}
	if transform.Ref() == nil {
		__ret, _ := transform.PassRef()
		s.Ref().transform = *__ret
	} else {
		s.Ref().transform = *transform.Ref()
	}
	return s
}

// GetVertexData returns a reference to C object within a struct
func (s *PhysicsShape) GetVertexData() *PolygonData {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *PolygonData
	ret = NewPolygonDataRef(unsafe.Pointer(&s.Ref().vertexData))
	return ret
}

// SetVertexData update C object and binding struct
func (s *PhysicsShape) SetVertexData(vertexData *PolygonData) *PhysicsShape {
	if s.Ref() == nil {
		s.PassRef()
	}
	if vertexData.Ref() == nil {
		__ret, _ := vertexData.PassRef()
		s.Ref().vertexData = *__ret
	} else {
		s.Ref().vertexData = *vertexData.Ref()
	}
	return s
}

// allocPhysicsBodyDataMemory allocates memory for type C.PhysicsBodyData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsBodyDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsBodyDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsBodyDataValue = unsafe.Sizeof([1]C.PhysicsBodyData{})

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicsBodyData) Ref() *C.PhysicsBodyData {
	if x == nil {
		return nil
	}
	return x.refd780e53
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *PhysicsBodyData) ResetRef() {
	if x == nil {
		return
	}
	x.refd780e53 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicsBodyData) FreeRef() {
	if x != nil && x.allocsd780e53 != nil {
		x.allocsd780e53.(*cgoAllocMap).Free()
		x.refd780e53 = nil
		return
	}
	if x != nil && x.refd780e53 != nil && x.allocsd780e53 == nil {
		C.free(unsafe.Pointer(x.refd780e53))
		x.refd780e53 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePhysicsBodyData(x *PhysicsBodyData) {
	if x != nil && x.allocsd780e53 != nil {
		x.allocsd780e53.(*cgoAllocMap).Free()
		x.refd780e53 = nil
		// fmt.Printf("PhysicsBodyData memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocsd780e53.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PhysicsBodyData memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewPhysicsBodyDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicsBodyDataRef(ref unsafe.Pointer) *PhysicsBodyData {
	if ref == nil {
		return nil
	}
	obj := new(PhysicsBodyData)
	obj.refd780e53 = (*C.PhysicsBodyData)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicsBodyData) PassRef() (*C.PhysicsBodyData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.refd780e53 != nil {
		return x.refd780e53, nil
	}
	memd780e53 := unsafe.Pointer(new(C.PhysicsBodyData))
	refd780e53 := (*C.PhysicsBodyData)(memd780e53)
	allocsd780e53 := new(cgoAllocMap)
	// allocsd780e53.Add(memd780e53)

	var cid_allocs *cgoAllocMap
	refd780e53.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocsd780e53.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var cenabled_allocs *cgoAllocMap
	refd780e53.enabled, cenabled_allocs = (C._Bool)(x.Enabled), cgoAllocsUnknown
	allocsd780e53.Borrow(cenabled_allocs)
	x.Enabled = *new(bool)

	var cposition_allocs *cgoAllocMap
	refd780e53.position, cposition_allocs = x.Position.PassValue()
	allocsd780e53.Borrow(cposition_allocs)
	x.Position = *new(Vector2)

	var cvelocity_allocs *cgoAllocMap
	refd780e53.velocity, cvelocity_allocs = x.Velocity.PassValue()
	allocsd780e53.Borrow(cvelocity_allocs)
	x.Velocity = *new(Vector2)

	var cforce_allocs *cgoAllocMap
	refd780e53.force, cforce_allocs = x.Force.PassValue()
	allocsd780e53.Borrow(cforce_allocs)
	x.Force = *new(Vector2)

	var cangularVelocity_allocs *cgoAllocMap
	refd780e53.angularVelocity, cangularVelocity_allocs = (C.float)(x.AngularVelocity), cgoAllocsUnknown
	allocsd780e53.Borrow(cangularVelocity_allocs)
	x.AngularVelocity = *new(float32)

	var ctorque_allocs *cgoAllocMap
	refd780e53.torque, ctorque_allocs = (C.float)(x.Torque), cgoAllocsUnknown
	allocsd780e53.Borrow(ctorque_allocs)
	x.Torque = *new(float32)

	var corient_allocs *cgoAllocMap
	refd780e53.orient, corient_allocs = (C.float)(x.Orient), cgoAllocsUnknown
	allocsd780e53.Borrow(corient_allocs)
	x.Orient = *new(float32)

	var cinertia_allocs *cgoAllocMap
	refd780e53.inertia, cinertia_allocs = (C.float)(x.Inertia), cgoAllocsUnknown
	allocsd780e53.Borrow(cinertia_allocs)
	x.Inertia = *new(float32)

	var cinverseInertia_allocs *cgoAllocMap
	refd780e53.inverseInertia, cinverseInertia_allocs = (C.float)(x.InverseInertia), cgoAllocsUnknown
	allocsd780e53.Borrow(cinverseInertia_allocs)
	x.InverseInertia = *new(float32)

	var cmass_allocs *cgoAllocMap
	refd780e53.mass, cmass_allocs = (C.float)(x.Mass), cgoAllocsUnknown
	allocsd780e53.Borrow(cmass_allocs)
	x.Mass = *new(float32)

	var cinverseMass_allocs *cgoAllocMap
	refd780e53.inverseMass, cinverseMass_allocs = (C.float)(x.InverseMass), cgoAllocsUnknown
	allocsd780e53.Borrow(cinverseMass_allocs)
	x.InverseMass = *new(float32)

	var cstaticFriction_allocs *cgoAllocMap
	refd780e53.staticFriction, cstaticFriction_allocs = (C.float)(x.StaticFriction), cgoAllocsUnknown
	allocsd780e53.Borrow(cstaticFriction_allocs)
	x.StaticFriction = *new(float32)

	var cdynamicFriction_allocs *cgoAllocMap
	refd780e53.dynamicFriction, cdynamicFriction_allocs = (C.float)(x.DynamicFriction), cgoAllocsUnknown
	allocsd780e53.Borrow(cdynamicFriction_allocs)
	x.DynamicFriction = *new(float32)

	var crestitution_allocs *cgoAllocMap
	refd780e53.restitution, crestitution_allocs = (C.float)(x.Restitution), cgoAllocsUnknown
	allocsd780e53.Borrow(crestitution_allocs)
	x.Restitution = *new(float32)

	var cuseGravity_allocs *cgoAllocMap
	refd780e53.useGravity, cuseGravity_allocs = (C._Bool)(x.UseGravity), cgoAllocsUnknown
	allocsd780e53.Borrow(cuseGravity_allocs)
	x.UseGravity = *new(bool)

	var cisGrounded_allocs *cgoAllocMap
	refd780e53.isGrounded, cisGrounded_allocs = (C._Bool)(x.IsGrounded), cgoAllocsUnknown
	allocsd780e53.Borrow(cisGrounded_allocs)
	x.IsGrounded = *new(bool)

	var cfreezeOrient_allocs *cgoAllocMap
	refd780e53.freezeOrient, cfreezeOrient_allocs = (C._Bool)(x.FreezeOrient), cgoAllocsUnknown
	allocsd780e53.Borrow(cfreezeOrient_allocs)
	x.FreezeOrient = *new(bool)

	var cshape_allocs *cgoAllocMap
	refd780e53.shape, cshape_allocs = x.Shape.PassValue()
	allocsd780e53.Borrow(cshape_allocs)
	x.Shape = *new(PhysicsShape)

	x.refd780e53 = refd780e53
	x.allocsd780e53 = allocsd780e53
	defer func() {
		if len(x.allocsd780e53.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePhysicsBodyData)
		}
	}()
	return refd780e53, allocsd780e53

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicsBodyData) PassValue() (C.PhysicsBodyData, *cgoAllocMap) {
	if x.refd780e53 != nil {
		return *x.refd780e53, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// GetId returns a reference to C object within a struct
func (s *PhysicsBodyData) GetId() *uint32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *uint32
	ret = (*uint32)(unsafe.Pointer(&s.Ref().id))
	return ret
}

// SetId update C object and binding struct
func (s *PhysicsBodyData) SetId(id uint32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().id = (C.uint)(id)
	return s
}

// GetEnabled returns a reference to C object within a struct
func (s *PhysicsBodyData) GetEnabled() *bool {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *bool
	ret = (*bool)(unsafe.Pointer(&s.Ref().enabled))
	return ret
}

// SetEnabled update C object and binding struct
func (s *PhysicsBodyData) SetEnabled(enabled bool) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().enabled = (C._Bool)(enabled)
	return s
}

// GetPosition returns a reference to C object within a struct
func (s *PhysicsBodyData) GetPosition() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().position))
	return ret
}

// SetPosition update C object and binding struct
func (s *PhysicsBodyData) SetPosition(position *Vector2) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	if position.Ref() == nil {
		__ret, _ := position.PassRef()
		s.Ref().position = *__ret
	} else {
		s.Ref().position = *position.Ref()
	}
	return s
}

// GetVelocity returns a reference to C object within a struct
func (s *PhysicsBodyData) GetVelocity() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().velocity))
	return ret
}

// SetVelocity update C object and binding struct
func (s *PhysicsBodyData) SetVelocity(velocity *Vector2) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	if velocity.Ref() == nil {
		__ret, _ := velocity.PassRef()
		s.Ref().velocity = *__ret
	} else {
		s.Ref().velocity = *velocity.Ref()
	}
	return s
}

// GetForce returns a reference to C object within a struct
func (s *PhysicsBodyData) GetForce() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().force))
	return ret
}

// SetForce update C object and binding struct
func (s *PhysicsBodyData) SetForce(force *Vector2) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	if force.Ref() == nil {
		__ret, _ := force.PassRef()
		s.Ref().force = *__ret
	} else {
		s.Ref().force = *force.Ref()
	}
	return s
}

// GetAngularVelocity returns a reference to C object within a struct
func (s *PhysicsBodyData) GetAngularVelocity() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().angularVelocity))
	return ret
}

// SetAngularVelocity update C object and binding struct
func (s *PhysicsBodyData) SetAngularVelocity(angularVelocity float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().angularVelocity = (C.float)(angularVelocity)
	return s
}

// GetTorque returns a reference to C object within a struct
func (s *PhysicsBodyData) GetTorque() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().torque))
	return ret
}

// SetTorque update C object and binding struct
func (s *PhysicsBodyData) SetTorque(torque float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().torque = (C.float)(torque)
	return s
}

// GetOrient returns a reference to C object within a struct
func (s *PhysicsBodyData) GetOrient() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().orient))
	return ret
}

// SetOrient update C object and binding struct
func (s *PhysicsBodyData) SetOrient(orient float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().orient = (C.float)(orient)
	return s
}

// GetInertia returns a reference to C object within a struct
func (s *PhysicsBodyData) GetInertia() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().inertia))
	return ret
}

// SetInertia update C object and binding struct
func (s *PhysicsBodyData) SetInertia(inertia float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().inertia = (C.float)(inertia)
	return s
}

// GetInverseInertia returns a reference to C object within a struct
func (s *PhysicsBodyData) GetInverseInertia() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().inverseInertia))
	return ret
}

// SetInverseInertia update C object and binding struct
func (s *PhysicsBodyData) SetInverseInertia(inverseInertia float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().inverseInertia = (C.float)(inverseInertia)
	return s
}

// GetMass returns a reference to C object within a struct
func (s *PhysicsBodyData) GetMass() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().mass))
	return ret
}

// SetMass update C object and binding struct
func (s *PhysicsBodyData) SetMass(mass float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().mass = (C.float)(mass)
	return s
}

// GetInverseMass returns a reference to C object within a struct
func (s *PhysicsBodyData) GetInverseMass() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().inverseMass))
	return ret
}

// SetInverseMass update C object and binding struct
func (s *PhysicsBodyData) SetInverseMass(inverseMass float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().inverseMass = (C.float)(inverseMass)
	return s
}

// GetStaticFriction returns a reference to C object within a struct
func (s *PhysicsBodyData) GetStaticFriction() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().staticFriction))
	return ret
}

// SetStaticFriction update C object and binding struct
func (s *PhysicsBodyData) SetStaticFriction(staticFriction float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().staticFriction = (C.float)(staticFriction)
	return s
}

// GetDynamicFriction returns a reference to C object within a struct
func (s *PhysicsBodyData) GetDynamicFriction() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().dynamicFriction))
	return ret
}

// SetDynamicFriction update C object and binding struct
func (s *PhysicsBodyData) SetDynamicFriction(dynamicFriction float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().dynamicFriction = (C.float)(dynamicFriction)
	return s
}

// GetRestitution returns a reference to C object within a struct
func (s *PhysicsBodyData) GetRestitution() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().restitution))
	return ret
}

// SetRestitution update C object and binding struct
func (s *PhysicsBodyData) SetRestitution(restitution float32) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().restitution = (C.float)(restitution)
	return s
}

// GetUseGravity returns a reference to C object within a struct
func (s *PhysicsBodyData) GetUseGravity() *bool {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *bool
	ret = (*bool)(unsafe.Pointer(&s.Ref().useGravity))
	return ret
}

// SetUseGravity update C object and binding struct
func (s *PhysicsBodyData) SetUseGravity(useGravity bool) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().useGravity = (C._Bool)(useGravity)
	return s
}

// GetIsGrounded returns a reference to C object within a struct
func (s *PhysicsBodyData) GetIsGrounded() *bool {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *bool
	ret = (*bool)(unsafe.Pointer(&s.Ref().isGrounded))
	return ret
}

// SetIsGrounded update C object and binding struct
func (s *PhysicsBodyData) SetIsGrounded(isGrounded bool) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().isGrounded = (C._Bool)(isGrounded)
	return s
}

// GetFreezeOrient returns a reference to C object within a struct
func (s *PhysicsBodyData) GetFreezeOrient() *bool {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *bool
	ret = (*bool)(unsafe.Pointer(&s.Ref().freezeOrient))
	return ret
}

// SetFreezeOrient update C object and binding struct
func (s *PhysicsBodyData) SetFreezeOrient(freezeOrient bool) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().freezeOrient = (C._Bool)(freezeOrient)
	return s
}

// GetShape returns a reference to C object within a struct
func (s *PhysicsBodyData) GetShape() *PhysicsShape {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *PhysicsShape
	ret = NewPhysicsShapeRef(unsafe.Pointer(&s.Ref().shape))
	return ret
}

// SetShape update C object and binding struct
func (s *PhysicsBodyData) SetShape(shape *PhysicsShape) *PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	if shape.Ref() == nil {
		__ret, _ := shape.PassRef()
		s.Ref().shape = *__ret
	} else {
		s.Ref().shape = *shape.Ref()
	}
	return s
}

// allocPhysicsManifoldDataMemory allocates memory for type C.PhysicsManifoldData in C.
// The caller is responsible for freeing the this memory via C.free.
func allocPhysicsManifoldDataMemory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfPhysicsManifoldDataValue))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfPhysicsManifoldDataValue = unsafe.Sizeof([1]C.PhysicsManifoldData{})

// allocA2Vector2Memory allocates memory for type [2]C.Vector2 in C.
// The caller is responsible for freeing the this memory via C.free.
func allocA2Vector2Memory(n int) unsafe.Pointer {
	mem, err := C.calloc(C.size_t(n), (C.size_t)(sizeOfA2Vector2Value))
	if err != nil {
		panic("memory alloc error: " + err.Error())
	}
	return mem
}

const sizeOfA2Vector2Value = unsafe.Sizeof([1][2]C.Vector2{})

// unpackA2Vector2 transforms a sliced Go data structure into plain C format.
func unpackA2Vector2(x [2]Vector2) (unpacked [2]C.Vector2, allocs *cgoAllocMap) {
	allocs = new(cgoAllocMap)
	defer runtime.SetFinalizer(&unpacked, func(*[2]C.Vector2) {
		go allocs.Free()
	})

	mem0 := allocA2Vector2Memory(1)
	allocs.Add(mem0)
	v0 := (*[2]C.Vector2)(mem0)
	for i0 := range x {
		allocs0 := new(cgoAllocMap)
		v0[i0], allocs0 = x[i0].PassValue()
		allocs.Borrow(allocs0)
	}
	unpacked = *(*[2]C.Vector2)(mem0)
	return
}

// Ref returns the underlying reference to C object or nil if struct is nil.
func (x *PhysicsManifoldData) Ref() *C.PhysicsManifoldData {
	if x == nil {
		return nil
	}
	return x.ref10b92967
}

// ResetRef set ref nil if memory freed by CGo call C function.
func (x *PhysicsManifoldData) ResetRef() {
	if x == nil {
		return
	}
	x.ref10b92967 = nil
}

// FreeRef invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func (x *PhysicsManifoldData) FreeRef() {
	if x != nil && x.allocs10b92967 != nil {
		x.allocs10b92967.(*cgoAllocMap).Free()
		x.ref10b92967 = nil
		return
	}
	if x != nil && x.ref10b92967 != nil && x.allocs10b92967 == nil {
		C.free(unsafe.Pointer(x.ref10b92967))
		x.ref10b92967 = nil
		return
	}
}

// Auto free invokes alloc map's free mechanism that cleanups any allocated memory using C free.
// Does nothing if struct is nil or has no allocation map.
func freePhysicsManifoldData(x *PhysicsManifoldData) {
	if x != nil && x.allocs10b92967 != nil {
		x.allocs10b92967.(*cgoAllocMap).Free()
		x.ref10b92967 = nil
		// fmt.Printf("PhysicsManifoldData memory: %p free\n", x)
		// return
	}
	gc.mux.Lock()         // gc lock
	defer gc.mux.Unlock() // gc unlock
	a := x.allocs10b92967.(*cgoAllocMap)
	if gc.references == nil {
		return
	}
	for ptr := range a.m {
		// C.free(ptr)
		// delete(a.m, ptr)
		if _, ok := gc.references[ptr]; ok {
			gc.references[ptr].count -= 1
			if gc.references[ptr].count == 0 {
				fmt.Printf("C.PhysicsManifoldData memory: %p free\n", ptr)
				C.free(ptr)
				delete(gc.references, ptr)
				fmt.Printf("del reference, still exist: %d\n", len(gc.references))
			}
		}
	}
}

// NewPhysicsManifoldDataRef creates a new wrapper struct with underlying reference set to the original C object.
// Returns nil if the provided pointer to C object is nil too.
func NewPhysicsManifoldDataRef(ref unsafe.Pointer) *PhysicsManifoldData {
	if ref == nil {
		return nil
	}
	obj := new(PhysicsManifoldData)
	obj.ref10b92967 = (*C.PhysicsManifoldData)(unsafe.Pointer(ref))
	return obj
}

// PassRef returns the underlying C object, otherwise it will allocate one and set its values
// from this wrapping struct, counting allocations into an allocation map.
func (x *PhysicsManifoldData) PassRef() (*C.PhysicsManifoldData, *cgoAllocMap) {
	if x == nil {
		return nil, nil
	} else if x.ref10b92967 != nil {
		return x.ref10b92967, nil
	}
	mem10b92967 := unsafe.Pointer(new(C.PhysicsManifoldData))
	ref10b92967 := (*C.PhysicsManifoldData)(mem10b92967)
	allocs10b92967 := new(cgoAllocMap)
	// allocs10b92967.Add(mem10b92967)

	var cid_allocs *cgoAllocMap
	ref10b92967.id, cid_allocs = (C.uint)(x.Id), cgoAllocsUnknown
	allocs10b92967.Borrow(cid_allocs)
	x.Id = *new(uint32)

	var cbodyA_allocs *cgoAllocMap
	ref10b92967.bodyA, cbodyA_allocs = unpackSPhysicsBodyData(x.BodyA)
	allocs10b92967.Borrow(cbodyA_allocs)
	x.BodyA = *new([]PhysicsBodyData)

	var cbodyB_allocs *cgoAllocMap
	ref10b92967.bodyB, cbodyB_allocs = unpackSPhysicsBodyData(x.BodyB)
	allocs10b92967.Borrow(cbodyB_allocs)
	x.BodyB = *new([]PhysicsBodyData)

	var cpenetration_allocs *cgoAllocMap
	ref10b92967.penetration, cpenetration_allocs = (C.float)(x.Penetration), cgoAllocsUnknown
	allocs10b92967.Borrow(cpenetration_allocs)
	x.Penetration = *new(float32)

	var cnormal_allocs *cgoAllocMap
	ref10b92967.normal, cnormal_allocs = x.Normal.PassValue()
	allocs10b92967.Borrow(cnormal_allocs)
	x.Normal = *new(Vector2)

	var ccontacts_allocs *cgoAllocMap
	ref10b92967.contacts, ccontacts_allocs = unpackA2Vector2(x.Contacts)
	allocs10b92967.Borrow(ccontacts_allocs)
	x.Contacts = *new([2]Vector2)

	var ccontactsCount_allocs *cgoAllocMap
	ref10b92967.contactsCount, ccontactsCount_allocs = (C.uint)(x.ContactsCount), cgoAllocsUnknown
	allocs10b92967.Borrow(ccontactsCount_allocs)
	x.ContactsCount = *new(uint32)

	var crestitution_allocs *cgoAllocMap
	ref10b92967.restitution, crestitution_allocs = (C.float)(x.Restitution), cgoAllocsUnknown
	allocs10b92967.Borrow(crestitution_allocs)
	x.Restitution = *new(float32)

	var cdynamicFriction_allocs *cgoAllocMap
	ref10b92967.dynamicFriction, cdynamicFriction_allocs = (C.float)(x.DynamicFriction), cgoAllocsUnknown
	allocs10b92967.Borrow(cdynamicFriction_allocs)
	x.DynamicFriction = *new(float32)

	var cstaticFriction_allocs *cgoAllocMap
	ref10b92967.staticFriction, cstaticFriction_allocs = (C.float)(x.StaticFriction), cgoAllocsUnknown
	allocs10b92967.Borrow(cstaticFriction_allocs)
	x.StaticFriction = *new(float32)

	x.ref10b92967 = ref10b92967
	x.allocs10b92967 = allocs10b92967
	defer func() {
		if len(x.allocs10b92967.(*cgoAllocMap).m) > 0 {
			runtime.SetFinalizer(x, freePhysicsManifoldData)
		}
	}()
	return ref10b92967, allocs10b92967

}

// PassValue does the same as PassRef except that it will try to dereference the returned pointer.
func (x PhysicsManifoldData) PassValue() (C.PhysicsManifoldData, *cgoAllocMap) {
	if x.ref10b92967 != nil {
		return *x.ref10b92967, nil
	}
	ref, allocs := x.PassRef()
	return *ref, allocs
}

// GetId returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetId() *uint32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *uint32
	ret = (*uint32)(unsafe.Pointer(&s.Ref().id))
	return ret
}

// SetId update C object and binding struct
func (s *PhysicsManifoldData) SetId(id uint32) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().id = (C.uint)(id)
	return s
}

// GetBodyA returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetBodyA(bodyACount int32) []PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []PhysicsBodyData
	ret = make([]PhysicsBodyData, bodyACount)
	packSPhysicsBodyData(ret, s.Ref().bodyA)
	return ret
}

// SetBodyA update C object and binding struct
func (s *PhysicsManifoldData) SetBodyA(bodyAIndex int32, physicsBodyData PhysicsBodyData) *PhysicsManifoldData {

	if s.Ref() == nil {
		s.PassRef()
	}

	var __ret *C.struct_PhysicsBodyData
	if physicsBodyData.Ref() == nil {
		__ret, _ = physicsBodyData.PassRef()
	} else {
		__ret = physicsBodyData.Ref()
	}
	ptr0 := s.Ref().bodyA
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyAIndex)*uintptr(sizeOfPhysicsBodyDataValue))

	*(*C.struct_PhysicsBodyData)(ptr) = *__ret
	return s
}

// GetBodyB returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetBodyB(bodyBCount int32) []PhysicsBodyData {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret []PhysicsBodyData
	ret = make([]PhysicsBodyData, bodyBCount)
	packSPhysicsBodyData(ret, s.Ref().bodyB)
	return ret
}

// SetBodyB update C object and binding struct
func (s *PhysicsManifoldData) SetBodyB(bodyBIndex int32, physicsBodyData PhysicsBodyData) *PhysicsManifoldData {

	if s.Ref() == nil {
		s.PassRef()
	}

	var __ret *C.struct_PhysicsBodyData
	if physicsBodyData.Ref() == nil {
		__ret, _ = physicsBodyData.PassRef()
	} else {
		__ret = physicsBodyData.Ref()
	}
	ptr0 := s.Ref().bodyB
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(bodyBIndex)*uintptr(sizeOfPhysicsBodyDataValue))

	*(*C.struct_PhysicsBodyData)(ptr) = *__ret
	return s
}

// GetPenetration returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetPenetration() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().penetration))
	return ret
}

// SetPenetration update C object and binding struct
func (s *PhysicsManifoldData) SetPenetration(penetration float32) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().penetration = (C.float)(penetration)
	return s
}

// GetNormal returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetNormal() *Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *Vector2
	ret = NewVector2Ref(unsafe.Pointer(&s.Ref().normal))
	return ret
}

// SetNormal update C object and binding struct
func (s *PhysicsManifoldData) SetNormal(normal *Vector2) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	if normal.Ref() == nil {
		__ret, _ := normal.PassRef()
		s.Ref().normal = *__ret
	} else {
		s.Ref().normal = *normal.Ref()
	}
	return s
}

// GetContacts returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetContacts() [2]Vector2 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret [2]Vector2
	// c struct pointer offset
	ptr0 := &s.Ref().contacts
	for i0 := range ret {
		ptr1 := (*C.Vector2)(unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(i0)*uintptr(sizeOfVector2Value)))
		ret[i0] = *NewVector2Ref(unsafe.Pointer(ptr1))
	}
	return ret
}

// SetContacts update C object and binding struct
func (s *PhysicsManifoldData) SetContacts(contactsIndex int32, vector2 Vector2) *PhysicsManifoldData {

	if s.Ref() == nil {
		s.PassRef()
	}

	var __ret *C.Vector2
	if vector2.Ref() == nil {
		__ret, _ = vector2.PassRef()
	} else {
		__ret = vector2.Ref()
	}
	ptr0 := &s.Ref().contacts
	ptr := unsafe.Pointer(uintptr(unsafe.Pointer(ptr0)) + uintptr(contactsIndex)*uintptr(sizeOfVector2Value))

	*(*C.Vector2)(ptr) = *__ret
	return s
}

// GetContactsCount returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetContactsCount() *uint32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *uint32
	ret = (*uint32)(unsafe.Pointer(&s.Ref().contactsCount))
	return ret
}

// SetContactsCount update C object and binding struct
func (s *PhysicsManifoldData) SetContactsCount(contactsCount uint32) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().contactsCount = (C.uint)(contactsCount)
	return s
}

// GetRestitution returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetRestitution() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().restitution))
	return ret
}

// SetRestitution update C object and binding struct
func (s *PhysicsManifoldData) SetRestitution(restitution float32) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().restitution = (C.float)(restitution)
	return s
}

// GetDynamicFriction returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetDynamicFriction() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().dynamicFriction))
	return ret
}

// SetDynamicFriction update C object and binding struct
func (s *PhysicsManifoldData) SetDynamicFriction(dynamicFriction float32) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().dynamicFriction = (C.float)(dynamicFriction)
	return s
}

// GetStaticFriction returns a reference to C object within a struct
func (s *PhysicsManifoldData) GetStaticFriction() *float32 {
	if s.Ref() == nil {
		s.PassRef()
	}
	var ret *float32
	ret = (*float32)(unsafe.Pointer(&s.Ref().staticFriction))
	return ret
}

// SetStaticFriction update C object and binding struct
func (s *PhysicsManifoldData) SetStaticFriction(staticFriction float32) *PhysicsManifoldData {
	if s.Ref() == nil {
		s.PassRef()
	}
	s.Ref().staticFriction = (C.float)(staticFriction)
	return s
}
